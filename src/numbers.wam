;; number encoding
;;
;;   numbers block
;;     a block in which to store discrete i64s and f64s
;;     alloc number blocks as needed, of size immobile block size.
;;     never deallocated, tracked in a list for debugging
;;
;;   track used/unused
;;     use linked-list impl similar to pairs, alloc and dealloc will be very
;;     similar value of a free # is the address of the next free number in the
;;     list has value -1
;;
;;   number box types
;;                                               STTT
;;     i64              xxxx xxxx xxxx xxxx xxxx 0000 0000 0001
;;     f64              xxxx xxxx xxxx xxxx xxxx 0001 0000 0001
;;     rational         xxxx xxxx xxxx xxxx xxxx 0010 0000 0001
;;     complex          xxxx xxxx xxxx xxxx xxxx 0011 0000 0001
;;     integer          rrrr rrrr rrrr rrrr rrrr ?100 0000 0001
;;
;;     S = sign bit, only used by integers, 1 => negative, 0 => positive
;;
;;     TTT = type code
;;
;;     i64
;;       the box value is an address of an x64 block
;;
;;     f64
;;       the box value is an address of an x64 block
;;
;;     rational
;;       pair stored in box value, car is num, cdr is denom; num and denomm must
;;       be exact and must not be complex or rational
;;
;;     complex
;;       pair stored in box value, car is re, cdr is im; re and im
;;       must not be complex
;;
;;     integer
;;       box value is a block ref containing up to 2^16 64-bit digits
;;
;; exhaustive list of number encodings
;;
;;   f64
;;   tagged 29-bit
;;   i64
;;   integer
;;   rational 29-bit  29-bit
;;   rational 29-bit  i64
;;   rational 29-bit  integer
;;   rational i64     29-bit
;;   rational i64     i64
;;   rational i64     integer
;;   rational integer 29-bit
;;   rational integer i64
;;   rational integer integer
;;   complex ... 169 binary combinations of { 29-bit i64 integer } + rationals
;;
;;   => 182 different possible encoding structures for a number
;;

(module

 (import "block-mgr" "alloc-block"    (func $alloc-block    (param i32 i32)     (result i32)))
 (import "block-mgr" "dealloc-block"  (func $dealloc-block  (param i32 i32)))
 (import "block-mgr" "get-block-addr" (func $get-block-addr (param i32)         (result i32)))
 (import "block-mgr" "get-block-size" (func $get-block-size (param i32)         (result i32)))
 (import "block-mgr" "init-blockset"  (func $init-blockset  (param i32 i32)))
 (import "block-mgr" "resize-block"   (func $resize-block   (param i32 i32 i32) (result i32)))
 (import "pairs" "make-pair"          (func $make-pair      (param i32 i32)     (result i32)))
 (import "pairs" "dealloc-pair"       (func $dealloc-pair   (param i32)))
 (import "pairs" "get-pair-car"       (func $get-pair-car   (param i32)         (result i32)))
 (import "pairs" "get-pair-cdr"       (func $get-pair-cdr   (param i32)         (result i32)))
 (import "pairs" "set-pair-car"       (func $set-pair-car   (param i32 i32)))
 (import "pairs" "set-pair-cdr"       (func $set-pair-cdr   (param i32 i32)))

 (include "./block-mgr-memory-proxy-imports.wam")

 (include "./constants.wam")
 (include "./globals.wam")
 (include "./values.wam")
 (include "./boxes.wam")
 (include "./block-mgr-memory-proxies.wam")

 (memory $memory (debug (export "memory")) 1)

 (debug
  (global $debug (export "#debug") (mut i32) (i32.const 0))
  (global $p1 (export "p1") (mut i32) (i32.const 0))
  (global $p2 (export "p2") (mut i32) (i32.const 0))
  (global $p3 (export "p3") (mut i32) (i32.const 0))
  (global $p4 (export "p4") (mut i32) (i32.const 0)))

 ;;     i64              xxxx xxxx xxxx xxxx xxxx 0000 0000 0001
 ;;     f64              xxxx xxxx xxxx xxxx xxxx 0001 0000 0001
 ;;     rational         xxxx xxxx xxxx xxxx xxxx 0010 0000 0001
 ;;     complex          xxxx xxxx xxxx xxxx xxxx 0011 0000 0001
 ;;     integer          rrrr rrrr rrrr rrrr rrrr ?100 0000 0001

 (define _number-block-size    (i32.const 0x400))

 (define _number-type-i64      (i32.const 0x00000001))
 (define _number-type-f64      (i32.const 0x00000101))
 (define _number-type-rational (i32.const 0x00000201))
 (define _number-type-complex  (i32.const 0x00000301))
 (define _number-type-integer  (i32.const 0x00000401))
 (define _number-type-mask     (i32.const 0x000007ff))

 (define _integer-sign-flag      (i32.const 0x00000800))
 (define _integer-sign-flag-mask (i32.const 0xfffff7ff))

 (debug
  (global $number-block-size    (export "number-block-size")    i32 _number-block-size)

  (global $number-type-i64      (export "number-type-i64")      i32 _number-type-i64)
  (global $number-type-f64      (export "number-type-f64")      i32 _number-type-f64)
  (global $number-type-complex  (export "number-type-complex")  i32 _number-type-complex)
  (global $number-type-rational (export "number-type-rational") i32 _number-type-rational)
  (global $number-type-integer  (export "number-type-integer")  i32 _number-type-integer)
  (global $number-type-mask     (export "number-type-mask")     i32 _number-type-mask))

 (const #i32-size 4)
 (const #i64-size 8)

 (const #i32-size-bits 2)
 (const #i64-size-bits 3)

 (global $x64-free-list (debug (export "x64-free-list")) (mut i32) (i32.const 0))
 (debug
  (global $x64-block-list (debug (export "x64-block-list")) (mut i32) (i32.const 0))
  (global $x64-count (debug (export "x64-count")) (mut i32) (i32.const 0)))

 (macro %get-next-free-x64
   (expr ,x64)
   (i32.load ,x64))

 (debug
  (func $get-next-free-x64
    (param $x64 i32)
    (result i32)
    (%get-next-free-x64 $x64)))

 (global $integer-1e16  (debug (export "integer-1e16"))  (mut i32) (i32.const 0))
 (global $integer-1e32  (debug (export "integer-1e32"))  (mut i32) (i32.const 0))
 (global $integer-1e64  (debug (export "integer-1e64"))  (mut i32) (i32.const 0))
 (global $integer-1e128 (debug (export "integer-1e128")) (mut i32) (i32.const 0))
 (global $integer-1e256 (debug (export "integer-1e256")) (mut i32) (i32.const 0))

 (define _small-integer-0 (i32.const 0))
 (define _small-integer-1 (i32.const 8))

 (define _i32-1e4  (i32.const 10000))
 (define _i32-1e8  (i32.const 100000000))
 (define _i64-1e16 (i64.const 10000000000000000))

 (define _integer-1e16  (global.get $integer-1e16))
 (define _integer-1e32  (global.get $integer-1e32))
 (define _integer-1e64  (global.get $integer-1e64))
 (define _integer-1e128 (global.get $integer-1e128))
 (define _integer-1e256 (global.get $integer-1e256))

 (start $init-numbers)
 (func $init-numbers (debug (export "init-numbers"))

   ($init-blockset _numbers-blockset _number-block-size)

   ($init-blockset-memory-proxies _numbers-blockset)

   (global.set $x64-free-list _null)
   (debug
    (global.set $x64-block-list _null)
    (global.set $x64-count (i32.const 0)))

   (global.set $integer-1e16  ($make-integer _i64-1e16 (i32.const 1)))
   (global.set $integer-1e32  ($square-integer (global.get $integer-1e16)))
   (global.set $integer-1e64  ($square-integer (global.get $integer-1e32)))
   (global.set $integer-1e128 ($square-integer (global.get $integer-1e64)))
   (global.set $integer-1e256 ($square-integer (global.get $integer-1e128))))

 (macro %make-integer-number-type
   (expr ,digits)
   (i32.or _number-type-integer
           (i32.shl ,digits (i32.const 12))))

 (macro %get-integer-sign-flag
   (expr ,int)
   (i32.and (%get-box-type ,int) _integer-sign-flag))

 (macro %set-integer-sign-flag
   (label $int)
   (expr ,v)
   (%set-box-type $int (i32.or (i32.and (%get-box-type $int) _integer-sign-flag-mask)
                               ,v)))

 (macro %clear-integer-sign-flag
   (label $int)
   (%set-integer-sign-flag $int (i32.const 0)))

 (macro %is-negative-integer
   (expr ,int)
   (i32.eq (%get-integer-sign-flag ,int) _integer-sign-flag))

 (macro %set-negative-integer
   (label $int)
   (%set-integer-sign-flag $int _integer-sign-flag))

 (macro %get-number-type
   (expr ,x)
   (i32.and _number-type-mask (%get-box-type ,x)))

 (macro %get-integer-addr
   (expr ,int)
   ($get-block-addr (%get-box-value ,int)))

 (macro %get-integer-digit-addr
   (expr ,int)
   (expr ,n)
   (i32.add (%get-integer-addr ,int) (i32.shl ,n (i32.const 3))))

 (macro %get-integer-size
   (expr ,int)
   (i32.shr_u (i32.and (%get-box-type ,int)
                       (i32.xor _number-type-mask (i32.const -1)))
              (i32.const 12)))

 (macro %get-integer-byte-size
   (expr ,int)
   (i32.shl (%get-integer-size ,int) (i32.const 3)))

 (macro %get-i64-digit-addr
   (expr ,int)
   (expr ,idx)
   (i32.add (%get-integer-addr ,int) (i32.shl ,idx (i32.const #i64-size-bits))))

 (macro %get-i32-digit-addr
   (expr ,int)
   (expr ,idx)
   (i32.add (%get-integer-addr ,int) (i32.shl ,idx (i32.const #i32-size-bits))))

 (macro %make-small-integer
   (expr ,v)
   (%make-value (i32.shl ,v _tag-size-bits) _tag-small-integer))

 (macro %negate-small-integer
   (expr ,x)
   (i32.sub (i32.const 0) ,x))

 (macro %get-small-integer-value
   (expr ,x)
   (i32.shr_s (%get-value-data ,x) _tag-size-bits))

 (define _i64-small-integer-mask         (i64.const 0xffffffffe0000000))
 (define _i64-small-integer-overflow-bit (i64.const 0x0000000020000000))

 (macro %is-small-value-i64
   (expr ,v)
   (i64.le_u (i64.add (i64.and ,v _i64-small-integer-mask)
                      _i64-small-integer-overflow-bit)
             _i64-small-integer-overflow-bit))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Allocation
 ;;

 (func $alloc-integer (export "alloc-integer")
   (param $i64-digits i32)
   (result i32)

   (local $addr i32)
   (local $block i32)
   (local $size i32)

   (if (i32.eqz $i64-digits) (then (unreachable)))

   (set! $size (i32.shl $i64-digits (i32.const #i64-size-bits)))

   (set! $block ($alloc-block _numbers-blockset $size))

   (set! $addr ($get-block-addr $block))

   (memory.fill $addr (i32.const 0) $size)

   (%make-box (%make-integer-number-type $i64-digits) $block))

 (func $resize-integer (export "resize-integer")
   (param $x i32)
   (param $i64-digits i32)

   (local $new-size i32)
   (local $old-size i32)
   (local $sign-flag i32)

   (set! $old-size (%get-integer-byte-size $x))
   (set! $new-size (i32.shl $i64-digits (i32.const #i64-size-bits)))
   (set! $sign-flag (%get-integer-sign-flag $x))

   (%set-box-type $x (%make-integer-number-type $i64-digits))
   (%set-box-value $x ($resize-block _numbers-blockset (%get-box-value $x) $new-size))
   (%set-integer-sign-flag $x $sign-flag)

   (if (i32.gt_u $new-size $old-size)
       (then
        (memory.fill (i32.add (%get-integer-addr $x) $old-size)
                     (i32.const 0)
                     (i32.sub $new-size $old-size)))))

 (func $alloc-x64 (debug (export "alloc-x64"))
   (result i32)

   (if (i32.eq (global.get $x64-free-list) _null)
       (then
        ($alloc-x64-block)))

   (debug
    (%global.incr i32 $x64-count))

   (global.get $x64-free-list)
   (global.set $x64-free-list (%get-next-free-x64 (global.get $x64-free-list))))

 (func $alloc-x64-block (debug (export "alloc-x64-block"))

   (local $addr i32)
   (local $block i32)
   (local $end-addr i32)
   (local $last-addr i32)
   (local $next-x64 i32)
   (local $x64 i32)

   (set! $block ($alloc-block _numbers-blockset _number-block-size))

   (debug
    (global.set $x64-block-list ($make-pair $block (global.get $x64-block-list))))

   (set! $addr ($get-block-addr $block))
   (set! $end-addr (i32.add $addr _number-block-size))

   (set! $last-addr (global.get $x64-free-list))
   (loop $again
     (if (i32.lt_u $addr $end-addr)
         (then
          (i32.store $addr $last-addr)
          (set! $last-addr $addr)
          (%incr-n i32 $addr #i64-size)
          (br $again))))

   (global.set $x64-free-list $last-addr))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Deallocation
 ;;

 (func $dealloc-number (export "dealloc-number")
   (param $x i32)

   (local $type i32)
   (local $value i32)

   (if (i32.eq (%get-value-tag $x) _tag-small-integer)
       (then
        (return)))

   (set! $type (%get-number-type $x))
   (set! $value (%get-box-value $x))

   (if (i32.ne $x (i32.const 0x1d1))
       (then
        (global.set $p4 $x)))

   (if (i32.or (i32.eq $type _number-type-f64)
               (i32.eq $type _number-type-i64))
       (then
        ($dealloc-x64 $value)
        (%dealloc-box $x)
        (return)))

   (if (i32.or (i32.eq $type _number-type-complex)
               (i32.eq $type _number-type-rational))
       (then
        ($dealloc-number ($get-pair-car $value))
        ($dealloc-number ($get-pair-cdr $value))
        ($dealloc-pair (%get-value-data $value))
        (%dealloc-box $x)
        (return)))

   (if (i32.eq $type _number-type-integer)
       (then
        ($dealloc-block _numbers-blockset $value)
        (%dealloc-box $x)
        (return)))

   ($invalid-number-type))

 (func $dealloc-x64 (debug (export "dealloc-x64"))
   (param $x64 i32)

   (if (i32.and (i32.const 0x7) $x64)
       (then
        (unreachable)))
   (i32.store $x64 (global.get $x64-free-list))

   (debug
    (%global.decr i32 $x64-count))

   (global.set $x64-free-list $x64))


 ;;-----------------------------------------------------------------------------
 ;;
 ;; Number Constructors
 ;;

 (func $make-small-integer (export "make-small-integer")
   (param $x i32)
   (result i32)
   (%make-small-integer $x))

 (func $make-boxed-i64 (export "make-boxed-i64")
   (param $x i64)
   (result i32)

   (local $x64 i32)
   (set! $x64 ($alloc-x64))
   (i64.store $x64 $x)

   (%make-box _number-type-i64 $x64))

 (macro %assert
   (expr ,v)
   (debug (if (i32.eqz ,v) (then unreachable))))

 (func $make-boxed-f64 (export "make-boxed-f64")
   (param $x f64)
   (result i32)

   (local $v i32)
   (local $x64 i32)
   (set! $x64 ($alloc-x64))
   (f64.store $x64 $x)

   (set! $v (%make-box _number-type-f64 $x64))
   (%assert ($is-inexact $v))
   $v)

 (func $make-rational (export "make-rational")
   (param $n i32)
   (param $d i32)
   (result i32)

   (%make-box _number-type-rational ($make-pair $n $d)))

 (func $make-complex (export "make-complex")
   (param $re i32)
   (param $im i32)
   (result i32)

   (%make-box _number-type-complex ($make-pair $re $im)))

 (func $make-integer (export "make-integer")
   (param $x i64)
   (param $size i32)
   (result i32)

   (local $int i32)
   (set! $int ($alloc-integer $size))

   (if (i64.lt_s $x (i64.const 0))
       (then
        (%set-negative-integer $int)
        (i64.store (%get-integer-addr $int) (i64.sub (i64.const 0) $x)))
     (else
      (i64.store (%get-integer-addr $int) $x)))

   $int)

 (func $make-integer-i64 (debug (export "make-integer-i64"))
   (param $x i64)
   (result i32)
   ($make-integer $x (i32.const 1)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Parsing and display support for integers
 ;;

 (func $multiply-add-integer-i32 (export "multiply-add-integer-i32")
   (param $int i32)
   (param $n i32)
   (param $k i32)

   (local $addr i32)
   (local $c i64)
   (local $end-addr i32)
   (local $m i64)
   (local $v i64)

   (set! $m (i64.extend_i32_u $n))
   (set! $c (i64.extend_i32_u $k))

   (set! $addr (%get-integer-addr $int))
   (set! $end-addr (i32.add $addr (%get-integer-byte-size $int)))

   (loop $again
     (if (i32.lt_u $addr $end-addr)
         (then
          (set! $v (i64.add (i64.mul (i64.load32_u $addr) $m) $c))
          (i32.store $addr (i32.wrap_i64 $v))
          (set! $c (i64.shr_u $v (i64.const 32)))
          (%incr-n i32 $addr #i32-size)
          (br $again))))

   (debug (if (i64.ne $c (i64.const 0)) (then (unreachable)))))


 (func $multiply-integer-i32 (export "multiply-integer-i32")
   (param $int i32)
   (param $n i32)

   ($multiply-add-integer-i32 $int $n (i32.const 0)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Basic Arithmetic
 ;;

 (macro %binop
   (label $name)
   (expr ,export)
   (expr ,i64-binop)
   (label $int-binop)

   (func $name ,export
     (param $a i32)
     (param $b i32)
     (result i32)

     (local $a-int i32)
     (local $a-is-small i32)
     (local $a-type i32)
     (local $a-value i32)
     (local $b-int i32)
     (local $b-is-small i32)
     (local $b-type i32)
     (local $b-value i32)
     (local $i64-result i64)

     (if (i32.eq (%get-value-tag $a) _tag-small-integer)
         (then
          (set! $a-is-small (i32.const 1)))
       (else
        (set! $a-type (%get-number-type $a))
        (set! $a-value (%get-box-value $a))))

     (if (i32.eq (%get-value-tag $b) _tag-small-integer)
         (then
          (set! $b-is-small (i32.const 1)))
       (else
        (set! $b-type (%get-number-type $b))
        (set! $b-value (%get-box-value $b))))

     (if (i32.and $a-is-small $b-is-small)
         (then
          (return
           (set! $i64-result (,i64-binop (i64.extend_i32_s (%get-small-integer-value $a))
                                         (i64.extend_i32_s (%get-small-integer-value $b))))

           (if (%is-small-value-i64 $i64-result)
               (then
                (return (%make-small-integer (i32.wrap_i64 $i64-result)))))

           (return ($make-boxed-i64 $i64-result)))))

     (set! $a-int (if (result i32) $a-is-small
                    (then
                     ($make-integer-i64 (i64.extend_i32_s (%get-small-integer-value $a))))
                    (else
                     (if (result i32) (i32.eq $a-type _number-type-i64)
                       (then
                        ($make-integer-i64 (i64.load $a-value)))
                       (else
                        $a)))))

     (set! $b-int (if (result i32) $b-is-small
                    (then
                     ($make-integer-i64 (i64.extend_i32_s (%get-small-integer-value $b))))
                    (else
                     (if (result i32) (i32.eq $b-type _number-type-i64)
                       (then
                        ($make-integer-i64 (i64.load $b-value)))
                       (else
                        $b)))))

     ($int-binop $a-int $b-int)))

 (macro %binop-2
   (label $name)
   (expr ,export)
   (label $i64-binop)
   (label $int-binop)

   (func $name ,export
     (param $a i32)
     (param $b i32)
     (result i32 i32)

     (local $a-int i32)
     (local $a-is-small i32)
     (local $a-type i32)
     (local $a-value i32)
     (local $b-int i32)
     (local $b-is-small i32)
     (local $b-type i32)
     (local $b-value i32)
     (local $v1 i64)
     (local $v2 i64)

     (if (i32.eq (%get-value-tag $a) _tag-small-integer)
         (then
          (set! $a-is-small (i32.const 1)))
       (else
        (set! $a-type (%get-number-type $a))
        (set! $a-value (%get-box-value $a))))

     (if (i32.eq (%get-value-tag $b) _tag-small-integer)
         (then
          (set! $b-is-small (i32.const 1)))
       (else
        (set! $b-type (%get-number-type $b))
        (set! $b-value (%get-box-value $b))))

     (if (i32.and $a-is-small $b-is-small)
         (then
          (return
           (set! $v2
                 (set! $v1 ($i64-binop (i64.extend_i32_s (%get-small-integer-value $a))
                                       (i64.extend_i32_s (%get-small-integer-value $b)))))
           ($make-boxed-i64 $v2)
           ($make-boxed-i64 $v1))))

     (set! $a-int (if (result i32) $a-is-small
                    (then
                     ($make-integer-i64 (i64.extend_i32_s (%get-small-integer-value $a))))
                    (else
                     (if (result i32) (i32.eq $a-type _number-type-i64)
                       (then
                        ($make-integer-i64 (i64.load $a-value)))
                       (else
                        $a)))))

     (set! $b-int (if (result i32) $b-is-small
                    (then
                     ($make-integer-i64 (i64.extend_i32_s (%get-small-integer-value $b))))
                    (else
                     (if (result i32) (i32.eq $b-type _number-type-i64)
                       (then
                        ($make-integer-i64 (i64.load $b-value)))
                       (else
                        $b)))))

     ($int-binop $a-int $b-int)))

 (%binop $add       (debug (export "add"))       i64.add   $integer-addition)
 (%binop $subtract  (debug (export "subtract"))  i64.sub   $integer-subtraction)
 (%binop $multiply  (debug (export "multiply"))  i64.mul   $integer-multiplication)
 (%binop $quotient  (debug (export "quotient"))  i64.div_s $integer-quotient)
 (%binop $remainder (debug (export "remainder")) i64.rem_s $integer-remainder)

 (%binop-2 $divide (debug (export "divide")) $i64-division $integer-division)

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Basic Integer Arithmetic
 ;;

 (func $integer-addition (debug (export "integer-addition"))
   (param $a i32)
   (param $b i32)
   (result i32)

   (local $a-sign-flag i32)
   (local $b-sign-flag i32)
   (local $result i32)

   (set! $a-sign-flag (%get-integer-sign-flag $a))
   (set! $b-sign-flag (%get-integer-sign-flag $b))

   (if (i32.xor $a-sign-flag $b-sign-flag)
       (then
           (if (i32.ge_s ($compare-integer-digits $a $b) (i32.const 0))
               (then
                (set! $result ($subtract-integer-digits $a $b))
                (%set-integer-sign-flag $result $a-sign-flag))
             (else
              (set! $result ($subtract-integer-digits $b $a))
              (%set-integer-sign-flag $result $b-sign-flag))))
     (else
      (set! $result ($add-integer-digits $a $b))
      (%set-integer-sign-flag $result $a-sign-flag)))

   $result)

 (func $integer-subtraction (debug (export "integer-subtraction"))
   (param $a i32)
   (param $b i32)
   (result i32)

   (local $a-sign-flag i32)
   (local $b-sign-flag i32)
   (local $result i32)

   (set! $a-sign-flag (%get-integer-sign-flag $a))
   (set! $b-sign-flag (%get-integer-sign-flag $b))

   (if (i32.xor $a-sign-flag $b-sign-flag)
       (then
        (set! $result ($add-integer-digits $a $b))
        (%set-integer-sign-flag $result $a-sign-flag))
     (else
      (if (i32.ge_s ($compare-integer-digits $a $b) (i32.const 0))
          (then
           (set! $result ($subtract-integer-digits $a $b))
           (%set-integer-sign-flag $result $a-sign-flag))
        (else
         (set! $result ($subtract-integer-digits $b $a))
         (%set-integer-sign-flag $result $b-sign-flag)))))

   $result)

 (func $integer-multiplication (debug (export "integer-multiplication"))
   (param $a i32)
   (param $b i32)
   (result i32)

   (local $result i32)

   (set! $result ($multiply-integer-digits $a $b))

   (%set-integer-sign-flag $result (i32.xor (%get-integer-sign-flag $a)
                                            (%get-integer-sign-flag $b)))

   $result)

 (func $integer-quotient (debug (export "integer-quotient"))
   (param $a i32)
   (param $b i32)
   (result i32)

   (local $quot i32)
   (local $rem i32)

   (set! $rem
         (set! $quot ($integer-division $a $b)))

   ($dealloc-number $rem)
   $quot)

 (func $integer-remainder (debug (export "integer-remainder"))
   (param $a i32)
   (param $b i32)
   (result i32)

   (local $quot i32)
   (local $rem i32)

   (set! $rem
         (set! $quot ($integer-division $a $b)))

   ($dealloc-number $quot)
   $rem)

 (func $integer-division (debug (export "integer-division"))
   (param $a i32)
   (param $b i32)
   (result i32 i32)

   (local $quot i32)
   (local $rem i32)

   (set! $quot
         (set! $rem ($divide-integer-digits $a $b)))

   (if (%is-negative-integer $a)
       (then
        (%set-negative-integer $rem)
        (if (i32.eqz (%is-negative-integer $b))
            (then
             (%set-negative-integer $quot))))
     (else
      (if (%is-negative-integer $b)
          (then
           (%set-negative-integer $quot)))))

   $quot
   $rem)

 (func $i64-division (debug (export "i64-division"))
   (param $a i64)
   (param $b i64)
   (result i64 i64)

   (i64.div_s $a $b)
   (i64.rem_s $a $b))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Integer Digit Arithmetic
 ;;

 (func $add-integer-digits (debug (export "add-integer-digits"))
   (param $a i32)
   (param $b i32)
   (result i32)

   (local $a-addr i32)
   (local $a-end i32)
   (local $a-size i32)
   (local $a-value i64)
   (local $b-addr i32)
   (local $b-end i32)
   (local $b-size i32)
   (local $b-value i64)
   (local $carry i64)
   (local $result i32)
   (local $result-addr i32)
   (local $result-end i32)
   (local $result-size i32)
   (local $sum i64)
   (local $value i64)

   (set! $a-size (%get-integer-size $a))
   (set! $b-size (%get-integer-size $b))

   (set! $result-size (i32.add (if (result i32) (i32.ge_u $a-size $b-size)
                                 (then $a)
                                 (else $b))
                               (i32.const 1)))

   (set! $result ($alloc-integer $result-size))

   (set! $a-addr (%get-integer-addr $a))
   (set! $a-end (i32.add $a-addr (i32.shl $a-size (i32.const 3))))

   (set! $b-addr (%get-integer-addr $b))
   (set! $b-end (i32.add $b-addr (i32.shl $b-size (i32.const 3))))

   (set! $result-addr (%get-integer-addr $result))
   (set! $result-end (i32.add $result-addr (i32.shl $result-size (i32.const 3))))

   (set! $carry (i64.const 0))

   (loop $again
     (set! $a-value (if (result i64) (i32.lt_u $a-addr $a-end)
                      (then (i64.load $a-addr))
                      (else (i64.const 0))))

     (set! $b-value (if (result i64) (i32.lt_u $b-addr $b-end)
                      (then (i64.load $b-addr))
                      (else (i64.const 0))))

     (set! $sum (i64.add $a-value $b-value))
     (set! $value (i64.add $sum $carry))

     (set! $carry (if (result i64) (i32.or (i64.lt_u $value $a-value)
                                           (i64.lt_u $sum $a-value))
                    (then (i64.const 1))
                    (else (i64.const 0))))

     (i64.store $result-addr $value)

     (%incr-n i32 $a-addr 8)
     (%incr-n i32 $b-addr 8)
     (%incr-n i32 $result-addr 8)

     (if (i32.lt_u $result-addr $result-end)
         (then
          (br $again))))

   $result)

 (func $subtract-integer-digits (debug (export "subtract-integer-digits"))
   (param $a i32)
   (param $b i32)
   (result i32)

   (local $a-addr i32)
   (local $a-end i32)
   (local $a-size i32)
   (local $a-value i64)
   (local $b-addr i32)
   (local $b-end i32)
   (local $b-size i32)
   (local $b-value i64)
   (local $carry i64)
   (local $difference i64)
   (local $result i32)
   (local $result-addr i32)
   (local $result-end i32)
   (local $result-size i32)
   (local $value i64)

   (set! $a-size (%get-integer-size $a))
   (set! $b-size (%get-integer-size $b))

   (set! $result-size (i32.add (if (result i32) (i32.ge_u $a-size $b-size)
                                 (then $a)
                                 (else $b))
                               (i32.const 1)))

   (set! $result ($alloc-integer $result-size))

   (set! $a-addr (%get-integer-addr $a))
   (set! $a-end (i32.add $a-addr (i32.shl $a-size (i32.const 3))))

   (set! $b-addr (%get-integer-addr $b))
   (set! $b-end (i32.add $b-addr (i32.shl $b-size (i32.const 3))))

   (set! $result-addr (%get-integer-addr $result))
   (set! $result-end (i32.add $result-addr (i32.shl $result-size (i32.const 3))))

   (set! $carry (i64.const 0))

   (loop $again
     (set! $a-value (if (result i64) (i32.lt_u $a-addr $a-end)
                      (then (i64.load $a-addr))
                      (else (i64.const 0))))

     (set! $b-value (if (result i64) (i32.lt_u $b-addr $b-end)
                      (then (i64.load $b-addr))
                      (else (i64.const 0))))

     (set! $difference (i64.sub $a-value $b-value))
     (set! $value (i64.add $difference $carry))

     (set! $carry (if (result i64) (i32.or (i64.gt_u $difference $a-value)
                                           (i64.gt_u $value $a-value))
                    (then (i64.const -1))
                    (else (i64.const 0))))

     (i64.store $result-addr $value)

     (%incr-n i32 $a-addr 8)
     (%incr-n i32 $b-addr 8)
     (%incr-n i32 $result-addr 8)

     (if (i32.lt_u $result-addr $result-end)
         (then
          (br $again))))

   $result)

 (func $multiply-integer-digits/dealloc (export "multiply-integer-digits/dealloc")
   (param $x i32)
   (param $y i32)
   (result i32)

   (local $z i32)

   (set! $z ($multiply-integer-digits $x $y))

   ($dealloc-number $x)
   ($dealloc-number $y)

   $z)

 (func $multiply-integer-digits/dealloc-1 (export "multiply-integer-digits/dealloc-1")
   (param $x i32)
   (param $y i32)
   (result i32)

   (local $z i32)

   (set! $z ($multiply-integer-digits $x $y))

   ($dealloc-number $x)

   $z)

 (func $square-integer/dealloc (export "square-integer/dealloc")
   (param $x i32)
   (result i32)

   ($multiply-integer-digits/dealloc-1 $x $x))

 (func $square-integer (export "square-integer")
   (param $x i32)
   (result i32)

   ($multiply-integer-digits $x $x))

 (func $multiply-integer-digits (export "multiply-integer-digits")
   (param $x i32)
   (param $y i32)
   (result i32)

   (local $c i64)
   (local $x-addr i32)
   (local $x-end i32)
   (local $x-i i64)
   (local $y-addr i32)
   (local $y-base-addr i32)
   (local $y-end i32)
   (local $z i32)
   (local $z-addr i32)
   (local $z-base-addr i32)
   (local $z-end i32)
   (local $z-j i64)

   (set! $z ($alloc-integer ($calc-product-integer-size $x $y)))

   (set! $x-addr      (%get-integer-addr $x))
   (set! $y-base-addr (%get-integer-addr $y))
   (set! $z-base-addr (%get-integer-addr $z))

   (set! $x-end (i32.add $x-addr      (%get-integer-byte-size $x)))
   (set! $y-end (i32.add $y-base-addr (%get-integer-byte-size $y)))
   (set! $z-end (i32.add $z-base-addr (%get-integer-byte-size $z)))

   (loop $x-digits
     (if (i32.lt_u $x-addr $x-end)
         (then
          (set! $x-i (i64.load32_u $x-addr))
          (set! $c (i64.const 0))

          (set! $y-addr $y-base-addr)
          (set! $z-addr $z-base-addr)

          (loop $y-digits
            (if (i32.and (i32.lt_u $y-addr $y-end)
                         (i32.lt_u $z-addr $z-end))
                (then
                 (set! $z-j (i64.add (i64.add (i64.load32_u $z-addr)
                                              (i64.mul $x-i (i64.load32_u $y-addr)))
                                     $c))

                 (i32.store $z-addr (i32.wrap_i64 $z-j))
                 (set! $c (i64.shr_u $z-j (i64.const 32)))

                 (%incr-n i32 $y-addr 4)
                 (%incr-n i32 $z-addr 4)
                 (br $y-digits))))

          (i32.store $z-addr (i32.wrap_i64 $c))

          (%incr-n i32 $x-addr 4)
          (%incr-n i32 $z-base-addr 4)
          (br $x-digits))))

   (%set-integer-sign-flag $x (i32.xor (%get-integer-sign-flag $x)
                                       (%get-integer-sign-flag $y)))

   $z)

 (func $calc-product-integer-size (debug (export "calc-product-integer-size"))
   (param $a i32)
   (param $b i32)
   (result i32)

   (i32.shr_u (i32.add (i32.add ($get-integer-bit-size $a) ($get-integer-bit-size $b))
                       (i32.const 0x3f))
              (i32.const 6)))

 (func $get-integer-bit-size (debug (export "get-integer-bit-size"))
   (param $x i32)
   (result i32)

   (local $digit i64)
   (local $offset i32)

   (set! $digit
         (set! $offset ($find-integer-leading-digit $x)))

   (i32.add (i32.sub (i32.const 64) (i32.wrap_i64 (i64.clz $digit)))
            (i32.shl $offset (i32.const 3))))

 (func $get-integer-digit-size (debug (export "get-integer-digit-size"))
   (param $x i32)
   (result i32)

   (local $digit i64)
   (local $offset i32)

   (set! $digit
         (set! $offset ($find-integer-leading-digit $x)))

   (i32.add (i32.shr_u $offset (i32.const 3)) (i32.const 1)))

 (func $find-integer-leading-digit (debug (export "find-integer-leading-digit"))
   (param $x i32)
   (result i64 i32)

   (local $addr i32)
   (local $base-addr i32)
   (local $digit i64)

   (set! $base-addr (%get-integer-addr $x))
   (set! $addr (i32.add $base-addr (%get-integer-byte-size $x)))

   (loop $again
     (if (i32.gt_u $addr $base-addr)
         (then
          (%decr-n i32 $addr 8)
          (set! $digit (i64.load $addr))
          (if (i64.eqz $digit)
              (then
               (br $again))))))

   $digit
   (i32.sub $addr $base-addr))

 (func $quotient/dealloc-1 (debug (export "quotient/dealloc-1"))
   (param $a i32)
   (param $b i32)
   (result i32)

   ($quotient $a $b)
   ($dealloc-number $a))

 ;; (func $modulo/dealloc-1 (debug (export "modulo/dealloc-1"))
 ;;   (param $a i32)
 ;;   (param $b i32)
 ;;   (result i32)

 ;;   ($modulo $a $b)
 ;;   ($dealloc-number $a))

 (func $integer-remainder/dealloc-1 (debug (export "integer-remainder/dealloc-1"))
   (param $a i32)
   (param $b i32)
   (result i32)

   ($integer-remainder $a $b)
   ($dealloc-number $a))

 (func $divide-integer-digits (debug (export "divide-integer-digits"))
   (param $a i32)
   (param $b i32)
   (result i32 i32)

   (local $bit-place i32)
   (local $div i32)
   (local $div-bits i32)
   (local $quot i32)
   (local $quot-size i32)
   (local $rem i32)
   (local $rem-bits i32)
   (local $shift-bits i32)

   (set! $div ($copy-integer $b))
   (set! $rem ($copy-integer $a))

   (%clear-integer-sign-flag $div)
   (%clear-integer-sign-flag $rem)

   ;; This calculation depends on $copy-integer omitting leading
   ;; zero digits in the copy.
   (set! $quot-size (i32.add (i32.sub (%get-integer-size $rem)
                                      (%get-integer-size $div))
                             (i32.const 1)))

   (if (i32.le_s $quot-size (i32.const 0))
       (then
        ;; div size > rem size => div > rem => quot = 0
        (set! $quot ($alloc-integer (i32.const 1))))

     (else
      (set! $quot ($alloc-integer $quot-size))

      (set! $rem-bits ($get-integer-bit-size $rem))
      (set! $div-bits $rem-bits)

      (set! $bit-place (i32.sub $rem-bits ($get-integer-bit-size $div)))

      ($shift-integer $div $bit-place)

      (loop $again
        (if (i32.ge_s $bit-place (i32.const 0))
            (then
             (if ($lt-integer $rem $div)
                 (then
                  (%decr i32 $bit-place)

                  ($shift-integer $div (i32.const -1))
                  (br $again)))

             (set! $rem ($subtract-integer-digits $rem $div)) ;; todo dealloc rem
             ($set-integer-bit $quot $bit-place)

             (set! $rem-bits ($get-integer-bit-size $rem)) ;; todo: track digit, offset here
             (set! $shift-bits (i32.sub $rem-bits ($get-integer-bit-size $div)))
             ;;(set! $shift-bits (i32.sub $rem-bits $div-bits)) ;; NB: shift-bits is always < 0

             (set! $bit-place (i32.add $bit-place $shift-bits))

             (set! $div-bits $rem-bits)
             ($shift-integer $div $shift-bits)

             (br $again))))))

   ($dealloc-number $div)
   $rem
   $quot)

 (func $shift-integer (debug (export "shift-integer"))
   (param $x i32)
   (param $n i32)

   (if (i32.gt_s $n (i32.const 0))
       (then
        (return ($shift-integer-left $x $n))))

   (if (i32.lt_s $n (i32.const 0))
       (then
        (return ($shift-integer-right $x (i32.sub (i32.const 0) $n))))))

 (func $shift-integer-left (debug (export "shift-integer-left"))
   (param $x i32)
   (param $n i32)

   (local $base-addr i32)
   (local $carry-shift i64)
   (local $dest-addr i32)
   (local $digit i64)
   (local $digit-shift i64)
   (local $new-size i32)
   (local $next-digit i64)
   (local $old-size i32)
   (local $shift-digits i32)
   (local $src-addr i32)

   (set! $old-size (%get-integer-size $x))
   (set! $shift-digits (i32.shr_u (i32.add $n (i32.const 0x3f)) (i32.const 6)))
   (set! $new-size (i32.add $old-size $shift-digits))

   ($resize-integer $x $new-size)

   (set! $digit-shift (i64.extend_i32_u (i32.and $n (i32.const 0x3f))))
   (set! $carry-shift (i64.sub (i64.const 64) $digit-shift))

   (set! $base-addr (%get-integer-addr $x))

   (if (i64.eqz $digit-shift)
       (then
        (set! $dest-addr (i32.add $base-addr (i32.shl $shift-digits (i32.const 3))))
        (memory.copy $dest-addr $base-addr (i32.shl $old-size (i32.const 3))))

     (else
      (set! $dest-addr (i32.sub (i32.add $base-addr (%get-integer-byte-size $x)) (i32.const 8)))

      (set! $src-addr (i32.sub $dest-addr (i32.shl $shift-digits (i32.const 3))))
      (set! $next-digit (i64.load $src-addr))

      (i64.store $dest-addr (i64.shr_u $next-digit $carry-shift))

      (loop $again
        (%decr-n i32 $dest-addr 8)
        (if (i32.gt_u $src-addr $base-addr)
            (then
             (%decr-n i32 $src-addr 8)
             (set! $digit $next-digit)
             (set! $next-digit (i64.load $src-addr))

             (i64.store $dest-addr (i64.or (i64.shl $digit $digit-shift)
                                           (i64.shr_u $next-digit $carry-shift)))
             (br $again))))

      (i64.store $dest-addr (i64.shl $next-digit $digit-shift))))

   (memory.fill $base-addr (i32.const 0) (i32.sub $dest-addr $base-addr)))

 (func $shift-integer-right (debug (export "shift-integer-right"))
   (param $x i32)
   (param $n i32)

   (local $base-addr i32)
   (local $bit-size i32)
   (local $carry-shift i64)
   (local $dest-addr i32)
   (local $digit i64)
   (local $digit-shift i64)
   (local $end-addr i32)
   (local $new-bit-size i32)
   (local $new-byte-size i32)
   (local $new-size i32)
   (local $next-digit i64)
   (local $src-addr i32)

   (set! $bit-size ($get-integer-bit-size $x))
   (set! $new-bit-size (i32.sub $bit-size $n))

   (if (i32.le_s $new-bit-size (i32.const 0))
       (then
        ($resize-integer $x (i32.const 1))
        ($set-integer-i64-digit $x (i32.const 0) (i64.const 0))
        (return)))

   (set! $new-size (i32.shr_u (i32.add $new-bit-size (i32.const 0x3f)) (i32.const 6)))
   (set! $new-byte-size (i32.shl $new-size (i32.const 3)))

   (set! $digit-shift (i64.extend_i32_u (i32.and $n (i32.const 0x3f))))
   (set! $carry-shift (i64.sub (i64.const 64) $digit-shift))

   (set! $base-addr (%get-integer-addr $x))
   (set! $dest-addr $base-addr)
   (set! $end-addr (i32.add $base-addr (%get-integer-byte-size $x)))
   (set! $src-addr (i32.add $base-addr (i32.and (i32.shr_u $n (i32.const 3))
                                                (i32.const 0xfffffff8))))

   (set! $next-digit (i64.load $src-addr))

   (loop $again
     (%incr-n i32 $src-addr 8)
     (if (i32.lt_u $src-addr $end-addr)
         (then
          (set! $digit $next-digit)
          (set! $next-digit (i64.load $src-addr))
          (i64.store $dest-addr (i64.or (i64.shr_u $digit $digit-shift)
                                        (i64.shl $next-digit $carry-shift)))
          (%incr-n i32 $dest-addr 8)
          (br $again))))

   (i64.store $dest-addr (i64.shr_u $next-digit $digit-shift))

   (if (i32.lt_u $new-byte-size (%get-integer-byte-size $x))
       (then
        ($resize-integer $x $new-size))))

 (func $set-integer-bit (debug (export "set-integer-bit"))
   (param $x i32)
   (param $n i32)

   (local $addr i32)

   (set! $addr (%get-integer-digit-addr $x (i32.shr_u $n (i32.const 6))))

   (i64.store $addr (i64.or (i64.load $addr)
                            (i64.shl (i64.const 1)
                                     (i64.extend_i32_u (i32.and $n (i32.const 0x3f)))))))

 (func $is-negative (export "is-negative")
   (param $x i32)
   (result i32)

   (local $type i32)

   (local $value i32)

   (if (i32.eq (%get-value-tag $x) _tag-small-integer)
       (then
        (return (i32.lt_s $x (i32.const 0)))))

   (set! $type (%get-number-type $x))
   (set! $value (%get-box-value $x))

   (if (i32.eq $type _number-type-f64)
       (then
        (return (f64.lt (f64.load $value) (f64.const 0.0)))))

   (if (i32.eq $type _number-type-i64)
       (then
        (return (i64.lt_s (i64.load $value) (i64.const 0)))))

   (if (i32.eq $type _number-type-rational)
       (then
        (return (i32.xor ($is-negative ($get-pair-car $value))
                         ($is-negative ($get-pair-cdr $value))))))

   (if (i32.eq $type _number-type-integer)
       (then
        (return (%is-negative-integer $x))))

   (unreachable))

 (func $pow-10-integer (debug (export "pow-10-integer"))
   (param $n i32)
   (result i32)

   (local $mask i32)
   (local $p i32)
   (local $result i32)

   ;; limit exponent range to unsigned 2^28.
   (if (i32.and $n (i32.const 0xf0000000))
       (then
        (unreachable)))

   (set! $result (if (result i32) (i32.and $n (i32.const 1))
                   (then ($make-integer (i64.const 10) (i32.const 1)))
                   (else ($make-integer (i64.const 1)  (i32.const 1)))))

   (if (i32.and $n (i32.const 2))
       (then
        ($multiply-integer-i32 $result (i32.const 100))))

   (if (i32.and $n (i32.const 4))
       (then
        ($multiply-integer-i32 $result _i32-1e4)))

   (if (i32.and $n (i32.const 8))
       (then
        ($multiply-integer-i32 $result _i32-1e8)))

   (if (i32.and $n (i32.const 0x10))
       (then
        (set! $result ($multiply-integer-digits/dealloc-1 $result _integer-1e16))))

   (if (i32.eqz (i32.and $n (i32.const 0x0fffffe0)))
       (then
        (return $result)))

   (if (i32.and $n (i32.const 0x20))
       (then
        (set! $result ($multiply-integer-digits/dealloc-1 $result _integer-1e32))))

   (if (i32.and $n (i32.const 0x40))
       (then
        (set! $result ($multiply-integer-digits/dealloc-1 $result _integer-1e64))))

   (if (i32.and $n (i32.const 0x80))
       (then
        (set! $result ($multiply-integer-digits/dealloc-1 $result _integer-1e128))))

   (if (i32.and $n (i32.const 0x100))
       (then
        (set! $result ($multiply-integer-digits/dealloc-1 $result _integer-1e256))))

   (set! $n (i32.and $n (i32.const 0x0ffffe00)))

   (if (i32.eqz $n)
       (then
        (return $result)))

   (set! $mask (i32.const 0x200))
   (set! $p _integer-1e256)

   (loop $again
     (if $n
         (then
          (set! $p ($square-integer/dealloc $p))
          (if (i32.and $n $mask)
              (then
               (set! $n (i32.xor $n $mask))
               (set! $result ($multiply-integer-digits/dealloc-1 $result $p))))

          (set! $mask (i32.shl $mask (i32.const 1)))
          (br $again))))

   (if (i32.ne $p _integer-1e256)
       (then
        ($dealloc-number $p)))

   $result)

 (func $pow-10-f64 (debug (export "pow-10-f64"))
   (param $n i32)
   (result f64)

   (local $is-negative i32)
   (local $result f64)

   (set! $is-negative (i32.lt_s $n (i32.const 0)))

   (if $is-negative
       (then (set! $n (i32.sub (i32.const 0) $n))))

   (if (i32.and $n (i32.const 0x0ffffe00))
       (then
        (set! $result (f64.const +inf)))

     (else

      (set! $result (if (result f64) (i32.and $n (i32.const 0x01))
                      (then (f64.const 10.0))
                      (else (f64.const 1.0))))

      ;; unrolled loop
      (if (i32.and $n (i32.const 0x02))
          (then
           (set! $result (f64.mul $result (f64.const 100.0)))))

      (if (i32.and $n (i32.const 0x04))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e4)))))

      (if (i32.and $n (i32.const 0x08))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e8)))))

      (if (i32.and $n (i32.const 0x10))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e16)))))

      (if (i32.and $n (i32.const 0x20))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e32)))))

      (if (i32.and $n (i32.const 0x40))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e64)))))

      (if (i32.and $n (i32.const 0x80))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e128)))))

      (if (i32.and $n (i32.const 0x100))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e256)))))))

   (if $is-negative
       (then
        (set! $result (f64.div (f64.const 1.0) $result))))

   $result)

 (func $negate-number (export "negate-number")
   (param $x i32)
   (result i32)

   (local $type i32)
   (local $value i32)

   (if (i32.eq (%get-value-tag $x) _tag-small-integer)
       (then
        (return (%negate-small-integer $x))))

   (set! $type (%get-number-type $x))
   (set! $value (%get-box-value $x))

   (if (i32.eq $type _number-type-f64)
       (then
        ($negate-f64 $x)
        (return $x)))

   (if (i32.eq $type _number-type-i64)
       (then
        ($negate-i64 $x)
        (return $x)))

   (if (i32.eq $type _number-type-complex)
       (then
        ;; re
        ($set-pair-car $value ($negate-number ($get-pair-car $value)))
        ;; im
        ($set-pair-cdr $value ($negate-number ($get-pair-cdr $value)))
        (return $x)))

   (if (i32.eq $type _number-type-rational)
       (then
        ;; numerator
        ($set-pair-car $value ($negate-number ($get-pair-car $value)))
        (return $x)))

   (if (i32.eq $type _number-type-integer)
       (then
        ($negate-integer $x)
        (return $x)))

   ($invalid-number-type)
   $x)

 (func $invalid-number-type (unreachable))
 (func $not-implemented (unreachable))

 (func $negate-f64 (export "negate-f64")
   (param $x i32)
   (local $addr i32)

   (set! $addr (%get-box-value $x))
   (f64.store $addr (f64.neg (f64.load $addr))))

 (func $negate-i64 (export "negate-i64")
   (param $x i32)
   (local $addr i32)

   (set! $addr (%get-box-value $x))
   (i64.store $addr (i64.sub (i64.const 0) (i64.load $addr))))

 (func $negate-integer (export "negate-integer")
   (param $int i32)
   (%set-box-type $int (i32.xor _integer-sign-flag (%get-box-type $int))))

 (func $negate-integer-digits (debug (export "negate-integer-digits"))
   (param $int i32)

   (local $addr i32)
   (local $c i64)
   (local $end-addr i32)
   (local $v i64)

   (set! $addr (%get-integer-addr $int))
   (set! $end-addr (i32.add $addr (%get-integer-byte-size $int)))

   (set! $c (i64.const 1))

   (loop $again
     (if (i32.lt_u $addr $end-addr)
         (then
          (set! $v (i64.add (i64.xor (i64.load $addr) (i64.const -1))
                            $c))

          (i64.store $addr $v)

          (if (i64.ne $v (i64.const 0))
              (then
               (set! $c (i64.const 0))))

          (%incr-n i32 $addr #i64-size)
          (br $again)))))

 (func $gcd (debug (export "gcd"))
   (param $a i32)
   (param $b i32)
   (result i32)

   (local $a-int i32)
   (local $a-is-small i32)
   (local $a-type i32)
   (local $a-value i32)
   (local $b-int i32)
   (local $b-is-small i32)
   (local $b-type i32)
   (local $b-value i32)

   (if (i32.eq (%get-value-tag $a) _tag-small-integer)
       (then
        (set! $a-is-small (i32.const 1)))
     (else
      (set! $a-type (%get-number-type $a))
      (set! $a-value (%get-box-value $a))))

   (if (i32.eq (%get-value-tag $b) _tag-small-integer)
       (then
        (set! $b-is-small (i32.const 1)))
     (else
      (set! $b-type (%get-number-type $b))
      (set! $b-value (%get-box-value $b))))

   (if (i32.and $a-is-small $b-is-small)
       (then
        (return ($gcd-small-integer $a $b))))

   (if $a-is-small
       (then
        (if (i32.eq $b-type _number-type-i64)
            (then
             (return ($gcd-i64 (i64.extend_i32_s (%get-small-integer-value $a))
                               (i64.load $b-value)))))

        (if (i32.eq $b-type _number-type-integer)
            (then
             (set! $a-int ($make-integer-i64 (i64.extend_i32_s (%get-small-integer-value $a))))
             (return ($gcd-integer $a-int $b)
                     ($dealloc-number $a-int))))

        (unreachable)))

   (if $b-is-small
       (then
        (if (i32.eq $a-type _number-type-i64)
            (then
             (return ($gcd-i64 (i64.extend_i32_s (%get-small-integer-value $b))
                               (i64.load $a-value)))))

        (if (i32.eq $a-type _number-type-integer)
            (then
             (set! $b-int ($make-integer-i64 (i64.extend_i32_s (%get-small-integer-value $b))))
             (return ($gcd-integer $a $b-int)
                     ($dealloc-number $b-int))))

        (unreachable)))

   (if (i32.and (i32.eq $a-type _number-type-i64)
                (i32.eq $b-type _number-type-i64))
       (then
        (return ($gcd-i64 (i64.load $a-value) (i64.load $b-value)))))

   (if (i32.and (i32.eq $a-type _number-type-i64)
                (i32.eq $b-type _number-type-integer))
       (then
        (set! $a-int ($make-integer-i64 (i64.load $a-value)))
        (return ($gcd-integer $a-int $b)
                ($dealloc-number $a-int))))

   (if (i32.and (i32.eq $b-type _number-type-i64)
                (i32.eq $a-type _number-type-integer))
       (then
        (set! $b-int ($make-integer-i64 (i64.load $b-value)))
        (return ($gcd-integer $a $b-int)
                ($dealloc-number $b-int))))

   (if (i32.or (i32.ne $a-type _number-type-integer)
               (i32.ne $b-type _number-type-integer))
       (then
        (unreachable)))

   ($gcd-integer $a $b))

 (macro %gcd
   (class Int)
   (label $a)
   (label $b)
   (label $t)

   (if (Int.lt_s $a (Int.const 0))
       (then
        (set! $a (Int.sub (Int.const 0) $a))))

   (if (Int.lt_s $b (Int.const 0))
       (then
        (set! $b (Int.sub (Int.const 0) $b))))

   (if (Int.lt_u $a $b)
       (then
        (set! $t $a)
        (set! $a $b)
        (set! $b $t)))

   (loop $again
     (if (Int.ne $b (Int.const 0))
         (then
          (set! $t $b)
          (set! $b (Int.rem_u $a $b))
          (set! $a $t)
          (br $again))))

   $a)

 (func $gcd-small-integer (debug (export "gcd-small-integer"))
   (param $a i32)
   (param $b i32)
   (result i32)

   (local $t i32)

   (set! $a (%get-small-integer-value $a))
   (set! $b (%get-small-integer-value $b))

   (%make-small-integer (%gcd i32 $a $b $t)))

 (func $gcd-i64 (debug (export "gcd-i64"))
   (param $a i64)
   (param $b i64)
   (result i32)

   (local $t i64)

   ($make-boxed-i64 (%gcd i64 $a $b $t)))

 (func $gcd-integer (debug (export "gcd-integer"))
   (param $a i32)
   (param $b i32)
   (result i32)

   (local $t i32)

   (set! $a ($copy-integer $a))
   (set! $b ($copy-integer $b))

   (if ($lt-integer $a $b)
       (then
        (set! $t $a)
        (set! $a $b)
        (set! $b $t)))

   (loop $again
     (if (i32.eqz ($is-zero-integer $b))
         (then
          (set! $t $b)
          (set! $b ($integer-remainder/dealloc-1 $a $b))
          (set! $a $t)
          ;; (if (i32.and (i32.eq (%get-integer-size $a) (i32.const 1))
          ;;              (i32.eq (%get-integer-size $b) (i32.const 1)))
          ;;     (then
          ;;      (return ($gcd-i64 (i64.load (%get-integer-addr $a))
          ;;                        (i64.load (%get-integer-addr $b)))
          ;;              ($dealloc-number $a)
          ;;              ($dealloc-number $b))))
          (br $again))))

   ($dealloc-number $b)
   $a)

 (func $copy-integer (export "copy-integer")
   (param $a i32)
   (result i32)

   (local $b i32)
   (local $size i32)

   (set! $size ($get-integer-digit-size $a))
   (set! $b ($alloc-integer $size))

   (memory.copy (%get-integer-addr $b)
                (%get-integer-addr $a)
                (i32.shl $size (i32.const 3)))

   $b)

 (func $is-zero-integer (debug (export "is-zero-integer"))
   (param $x i32)
   (result i32)
   (local $digit i64)
   (local $offset i32)

   (set! $digit
         (set! $offset ($find-integer-leading-digit $x)))

   (i32.and (i64.eqz $digit) (i32.eqz $offset)))

 (func $ge-integer (debug (export "ge-integer"))
   (param $a i32)
   (param $b i32)
   (result i32)

   (i32.eqz ($lt-integer $b $a)))

 (func $gt-integer (debug (export "gt-integer"))
   (param $a i32)
   (param $b i32)
   (result i32)

   (i32.eqz ($le-integer $b $a)))

 (func $le-integer (debug (export "le-integer"))
   (param $a i32)
   (param $b i32)
   (result i32)

   (local $a-digit i64)
   (local $a-offset i32)
   (local $b-digit i64)
   (local $b-offset i32)

   (if (%is-negative-integer $a)
       (then
        (if (%is-negative-integer $b)
            (then
             (return (i32.ne ($compare-integer-digits $a $b) (i32.const -1)))))

        (return (i32.const 1))))

   (if (%is-negative-integer $b)
       (then
        (return (i32.const 0))))

   (i32.ne ($compare-integer-digits $a $b) (i32.const 1)))

 (func $lt-integer (debug (export "lt-integer"))
   (param $a i32)
   (param $b i32)
   (result i32)

   (local $a-digit i64)
   (local $a-offset i32)
   (local $b-digit i64)
   (local $b-offset i32)

   (if (%is-negative-integer $a)
       (then
        (if (%is-negative-integer $b)
            (then
             (return (i32.eq ($compare-integer-digits $a $b) (i32.const 1)))))

        (return (i32.const 1))))

   (if (%is-negative-integer $b)
       (then
        (return (i32.const 0))))

   (i32.eq ($compare-integer-digits $a $b) (i32.const -1)))

 (func $compare-integer-digits (debug (export "compare-integer-digits"))
   (param $a i32)
   (param $b i32)
   (result i32)

   (local $a-addr i32)
   (local $a-base-addr i32)
   (local $a-digit i64)
   (local $a-offset i32)
   (local $a-value i64)
   (local $b-addr i32)
   (local $b-digit i64)
   (local $b-offset i32)
   (local $b-value i64)

   (set! $a-digit
         (set! $a-offset ($find-integer-leading-digit $a)))

   (set! $b-digit
         (set! $b-offset ($find-integer-leading-digit $b)))

   (if (i32.lt_u $a-offset $b-offset)
       (then
        (return (i32.const -1))))

   (if (i32.gt_u $a-offset $b-offset)
       (then
        (return (i32.const 1))))

   (if (i64.lt_u $a-digit $b-digit)
       (then
        (return (i32.const -1))))

   (if (i64.gt_u $a-digit $b-digit)
       (then
        (return (i32.const 1))))

   (if (i32.eqz $a-offset)
       (then
        (return (i32.const 0))))

   (set! $a-base-addr (%get-integer-addr $a))

   (set! $a-addr (i32.add $a-base-addr $a-offset))
   (set! $b-addr (i32.add (%get-integer-addr $b) $b-offset))

   (loop $again
     (if (i32.gt_u $a-addr $a-base-addr)
         (then
          (%decr-n i32 $a-addr 8)
          (%decr-n i32 $b-addr 8)

          (set! $a-value (i64.load $a-addr))
          (set! $b-value (i64.load $b-addr))

          (if (i64.eq $a-value $b-value)
              (then
               (br $again))))
       (else
        (return (i32.const 0)))))

   (if (i64.lt_u $a-value $b-value)
       (then
        (return (i32.const -1))))

   (i32.const 1))

 (func $get-integer-size (export "get-integer-size")
   (param $int i32)
   (result i32)
   (%get-integer-size $int))

 (func $get-integer-digit-i32 (export "get-integer-digit-i32")
   (param $int i32)
   (param $idx i32)
   (result i32)

   (i32.load (%get-i32-digit-addr $int $idx)))

 (func $get-integer-digit-i64 (export "get-integer-digit-i64")
   (param $int i32)
   (param $idx i32)
   (result i64)

   (i64.load (%get-i64-digit-addr $int $idx)))

 (func $set-integer-i32-digit (export "set-integer-i32-digit")
   (param $int i32)
   (param $idx i32)
   (param $digit i32)

   (i32.store (%get-i32-digit-addr $int $idx) $digit))

 (func $set-integer-i64-digit (export "set-integer-i64-digit")
   (param $int i32)
   (param $idx i32)
   (param $digit i64)

   (i64.store (%get-i64-digit-addr $int $idx) $digit))

 (func $to-inexact (export "to-inexact")
   (param $x i32)
   (result i32)

   (local $type i32)
   (local $value i32)

   (if (i32.eq (%get-value-tag $x) _tag-small-integer)
       (then
        (return ($make-boxed-f64 ($coerce-f64 $x)))))

   (set! $type (%get-number-type $x))
   (set! $value (%get-box-value $x))

   (if (result i32) (i32.eq $type _number-type-complex)
     (then
      ($set-real-part $x ($make-boxed-f64 ($coerce-f64 ($real-part $x))))
      ($set-imag-part $x ($make-boxed-f64 ($coerce-f64 ($imag-part $x))))
      $x)
     (else
      ($make-boxed-f64 ($coerce-f64 $x)))))

 (func $coerce-f64 (export "coerce-f64")
   (param $x i32)
   (result f64)

   (local $type i32)
   (local $value i32)

   (if (i32.eq (%get-value-tag $x) _tag-small-integer)
       (then
        (return (f64.convert_i32_s (%get-small-integer-value $x)))))

   (set! $type (%get-number-type $x))
   (set! $value (%get-box-value $x))

   (if (i32.eq $type _number-type-f64)
       (then
        (f64.load $value)
        ($dealloc-number $x)
        (return)))

   (if (i32.eq $type _number-type-i64)
       (then
        (f64.convert_i64_s (i64.load $value))
        ($dealloc-number $x)
        (return)))

   (if (i32.eq $type _number-type-rational)
       (then
        ($coerce-rational-f64 $x)
        (return)))

   (if (i32.eq $type _number-type-integer)
       (then
        ($coerce-integer-f64 $x)
        (return)))

   (if (i32.eq $type _number-type-complex)
       ;; technically possible when im=0, but the use case is in
       ;; parsing where this case is not possible due to the lexical
       ;; structure.
       (then (unreachable)))

   (unreachable)

   ;; needed for type check
   (f64.const 0))

 (func $coerce-rational-f64 (debug (export "coerce-rational-f64"))
   (param $x i32)
   (result f64)

   (local $d i32)
   (local $d-bits i32)
   (local $n i32)
   (local $n-bits i32)
   (local $mantissa-adj i32)

   (set! $n ($promote-to-integer ($numerator $x)))
   (set! $d ($promote-to-integer ($denominator $x)))

   ($dealloc-number $x)

   (set! $d-bits ($get-integer-bit-size $d))
   (set! $n-bits ($get-integer-bit-size $n))

   ;; ensure the quotient has at least 63 bits to allow a precise
   ;; conversion to f64. See $coerce-integer-f64 below.

   (set! $mantissa-adj (i32.sub (i32.add $d-bits (i32.const 63)) $n-bits))
   (if (i32.lt_s $mantissa-adj (i32.const 0))
       (then
        (set! $mantissa-adj (i32.const 0)))
     (else
      ($shift-integer $n $mantissa-adj)))

   ;; return value
   ($adjust-mantissa ($coerce-integer-f64 ($integer-quotient $n $d))
                     $mantissa-adj)

   ($dealloc-number $n)
   ($dealloc-number $d))

 (func $promote-to-integer (debug (export "promote-to-integer"))
   (param $x i32)
   (result i32)

   (local $type i32)
   (local $value i32)

   (if (i32.eq (%get-value-tag $x) _tag-small-integer)
       (then
        (return ($make-integer-i64 (i64.extend_i32_s (%get-small-integer-value $x))))))

   (set! $type (%get-number-type $x))
   (set! $value (%get-box-value $x))

   (if (i32.eq $type _number-type-f64)
       (then
        ($not-implemented)))

   (if (i32.eq $type _number-type-i64)
       (then
        (return
         ($make-integer-i64 (i64.load $value)))))

   (if (i32.eq $type _number-type-complex)
       (then
        ($not-implemented)))

   (if (i32.eq $type _number-type-rational)
       (then
        ($not-implemented)))

   (if (i32.eq $type _number-type-integer)
       (then
        (return ($copy-integer $x))))

   ($invalid-number-type)
   $x)

 (macro %get-f64-mantissa
   (expr ,x)
   (i64.and (i64.reinterpret_f64 ,x) (i64.const 0x7ff0000000000000)))

 (macro %get-f64-sign
   (expr ,x)
   (i64.and (i64.reinterpret_f64 ,x) (i64.const 0x8000000000000000)))

 (macro %get-f64-significand
   (expr ,x)
   (i64.and (i64.reinterpret_f64 ,x) (i64.const 0x000fffffffffffff)))

 (macro %build-f64
   (expr ,sign)
   (expr ,mantissa)
   (expr ,significand)
   (f64.reinterpret_i64 (i64.or (i64.or ,sign ,mantissa) ,significand)))

 (func $adjust-mantissa (debug (export "adjust-mantissa"))
   (param $x f64)
   (param $n i32)
   (result f64)

   (local $mantissa i64)
   (local $significand i64)

   (set! $mantissa (i64.sub (i64.shr_u (%get-f64-mantissa $x) (i64.const 52))
                            (i64.extend_i32_s $n)))

   (set! $significand (%get-f64-significand $x))

   ;; check for overflow
   (if (i64.ge_s $mantissa (i64.const 0x7ff))
       (then
        (set! $mantissa (i64.const 0x7ff))
        (set! $significand (i64.const 0)))
     (else
      ;; check for underflow
      (if (i64.le_s $mantissa (i64.const 0))
          (then
           (if (i64.le_s $mantissa (i64.const -53))
               (then
                (set! $significand (i64.const 0)))
             (else
              ;; attempt to express as a subnormal number
              (set! $significand (i64.shr_u (i64.or $significand (i64.const 0x0010000000000000))
                                            (i64.sub (i64.const 1) $mantissa)))))

           (set! $mantissa (i64.const 0))))))

   (%build-f64 (%get-f64-sign $x)
               (i64.shl $mantissa (i64.const 52))
               $significand))

 (func $coerce-integer-f64 (debug (export "coerce-integer-f64"))
   (param $x i32)
   (result f64)

   (local $bit-size i32)
   (local $mantissa i64)
   (local $mantissa-adj i32)
   (local $result f64)
   (local $result-i64 i64)

   (set! $bit-size ($get-integer-bit-size $x))

   (if (i32.eqz $bit-size)
       (then
        ($dealloc-number $x)
        (return (f64.const 0.0))))

   (set! $mantissa-adj (i32.sub (i32.const 63) $bit-size))

   ($shift-integer $x $mantissa-adj)

   (set! $result (f64.convert_i64_u (i64.load (%get-integer-addr $x))))

   (if $mantissa-adj
       (then
        (set! $result-i64 (i64.reinterpret_f64 $result))
        (set! $mantissa (i64.sub (i64.shr_u $result-i64 (i64.const 52))
                                 (i64.extend_i32_s $mantissa-adj)))
        (if (i64.ge_s $mantissa (i64.const 0x7ff))
            (then
             (set! $mantissa (i64.const 0x7ff))))
        (set! $result (f64.reinterpret_i64
                       (i64.or (i64.shl $mantissa (i64.const 52))
                               (i64.and $result-i64 (i64.const 0x000fffffffffffff)))))))

   (if (result f64) (%is-negative-integer $x)
     (then (f64.neg $result))
     (else $result))

   ($dealloc-number $x))

 (debug
  (func $f64-to-i64 (export "f64-to-i64")
    (param $x f64)
    (result i64)
    (i64.reinterpret_f64 $x)))

 (func $normalize-number (export "normalize-number")
   (param $x i32)
   (result i32)

   (local $type i32)
   (local $value i32)

   (if (i32.eq (%get-value-tag $x) _tag-small-integer)
       (then
        (return $x)))

   (set! $type (%get-number-type $x))
   (set! $value (%get-box-value $x))

   (if (i32.eq $type _number-type-f64)
       (then
        (return $x)))

   (if (i32.eq $type _number-type-i64)
       (then
        (return ($normalize-i64 $x))))

   (if (i32.eq $type _number-type-complex)
       (then
        (return ($normalize-complex $x))))

   (if (i32.eq $type _number-type-rational)
       (then
        (return ($normalize-rational $x))))

   (if (i32.eq $type _number-type-integer)
       (then
        (return ($normalize-integer $x))))

   ($invalid-number-type)
   $x)

 (func $normalize-i64 (export "normalize-i64")
   (param $x i32)
   (result i32)

   (local $high-bits i64)
   (local $value i64)
   (local $x64 i32)

   ;; mask out lower 29 bits. If the upper bits are all 1 or all 0,
   ;; then the number can be stored in a small integer.

   (set! $x64 (%get-box-value $x))
   (set! $value (i64.load $x64))

   (if (%is-small-value-i64 $value)
       (then
        ($dealloc-x64 $x64)
        (return (%make-small-integer (i32.wrap_i64 $value)))))

   $x)

 (func $normalize-rational (export "normalize-rational")
   (param $x i32)
   (result i32)

   (local $denom i32)
   (local $div i32)
   (local $num i32)
   (local $value i32)

   (set! $value (%get-box-value $x))

   (set! $num ($normalize-number ($get-pair-car $value)))
   (set! $denom ($normalize-number ($get-pair-cdr $value)))

   (if ($is-negative $denom)
       (then
        (set! $num ($negate-number $num))
        (set! $denom ($negate-number $denom))))

   (if (i32.eq $denom _small-integer-0)
       (then
        (unreachable)))

   (if (i32.ne $denom _small-integer-1)
       (then
        (set! $div ($normalize-number ($gcd $num $denom)))

        (if (i32.ne $div _small-integer-1)
            (then
             (set! $num ($quotient/dealloc-1 $num $div))
             (set! $denom ($quotient/dealloc-1 $denom $div))
             ($dealloc-number $div)))))

   (if (i32.eq $denom _small-integer-1)
       (then
        ($dealloc-pair $value)
        (%dealloc-box $x)
        (return $num)))

   ($set-pair-car $value $num)
   ($set-pair-cdr $value $denom)

   $x)

 (func $normalize-complex (export "normalize-complex")
   (param $x i32)
   (result i32)

   (local $im i32)
   (local $re i32)
   (local $value i32)

   (set! $value (%get-box-value $x))

   (set! $re ($normalize-number ($get-pair-car $value)))
   (set! $im ($normalize-number ($get-pair-cdr $value)))

   (if (i32.eq $im _small-integer-0)
       (then
        ($dealloc-pair $value)
        (%dealloc-box $x)
        (return $re)))

   ($set-pair-car $value $re)
   ($set-pair-cdr $value $im)

   $x)

 (func $normalize-integer (export "normalize-integer")
   (param $x i32)
   (result i32)

   (local $addr i32)
   (local $base-addr i32)
   (local $size i32)
   (local $value i64)

   (set! $base-addr (%get-integer-addr $x))
   (set! $size (%get-integer-byte-size $x))

   (set! $addr (i32.add $base-addr $size))

   (loop $again
     (%decr-n i32 $addr 8)
     (if (i32.gt_u $addr $base-addr)
         (then
          (if (i64.eqz (i64.load $addr))
              (then
               (br $again))))))

   (if (i32.eq $addr $base-addr)
       (then

        (set! $value (i64.load $addr))

        (if (i64.ge_s $value (i64.const 0))
            (then

             (if (%get-integer-sign-flag $x)
                 (then
                  (set! $value (i64.sub (i64.const 0) $value))))

             ($dealloc-number $x)

             (if (%is-small-value-i64 $value)
                 (then
                  (return (%make-small-integer (i32.wrap_i64 $value))))
               (else
                (return ($make-boxed-i64 $value))))))))

   $x)


 ;;-----------------------------------------------------------------------------
 ;;
 ;; Number properties
 ;;
 ;;-----------------------------------------------------------------------------

 (func $is-small-integer (debug (export "is-small-integer"))
   (param $n i32)
   (result i32)
   (i32.eq (%get-value-tag $n) _tag-small-integer))

 (func $is-complex (export "is-complex")
   (param $n i32)
   (result i32)

   (if (result i32) (i32.ne (%get-value-tag $n) _tag-box)
     (then
      (i32.const 0))

     (else
      (i32.eq (%get-number-type $n) _number-type-complex))))

 (func $is-boxed-i64 (debug (export "is-boxed-i64"))
   (param $n i32)
   (result i32)

   (if (result i32) (i32.ne (%get-value-tag $n) _tag-box)
     (then
      (i32.const 0))

     (else
      (i32.eq (%get-number-type $n) _number-type-i64))))

 (func $is-boxed-f64 (debug (export "is-boxed-f64"))
   (param $n i32)
   (result i32)

   (if (result i32) (i32.ne (%get-value-tag $n) _tag-box)
     (then
      (i32.const 0))

     (else
      (i32.eq (%get-number-type $n) _number-type-f64))))

 (func $real-part (export "real-part")
   (param $n i32)
   (result i32)

   ($get-pair-car (%get-box-value $n)))

 (func $imag-part (export "imag-part")
   (param $n i32)
   (result i32)

   ($get-pair-cdr (%get-box-value $n)))

 (func $set-real-part (export "set-real-part")
   (param $n i32)
   (param $re i32)

   ($set-pair-car (%get-box-value $n) $re))

 (func $set-imag-part (export "set-imag-part")
   (param $n i32)
   (param $im i32)

   ($set-pair-cdr (%get-box-value $n) $im))

 (func $is-inexact (export "is-inexact")
   (param $n i32)
   (result i32)

   (if (result i32) (i32.ne (%get-value-tag $n) _tag-box)
     (then
      (i32.const 0))

     (else
      (i32.eq (%get-number-type $n) _number-type-f64))))

 (func $get-boxed-f64 (export "get-boxed-f64")
   (param $n i32)
   (result f64)

   (f64.load (%get-box-value $n)))

 (func $get-boxed-i64 (export "get-boxed-i64")
   (param $n i32)
   (result i64)

   (i64.load (%get-box-value $n)))

 (func $is-rational (export "is-rational")
   (param $n i32)
   (result i32)

   (if (result i32) (i32.ne (%get-value-tag $n) _tag-box)
     (then
      (i32.const 0))

     (else
      (i32.eq (%get-number-type $n) _number-type-rational))))

 (func $denominator (export "denominator")
   (param $n i32)
   (result i32)

   ($get-pair-cdr (%get-box-value $n)))

 (func $numerator (export "numerator")
   (param $n i32)
   (result i32)

   ($get-pair-car (%get-box-value $n)))


 )

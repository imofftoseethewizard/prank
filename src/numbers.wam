;; number encoding
;;
;;   numbers block
;;     a block in which to store discrete i64s and f64s
;;     alloc number blocks as needed, of size immobile block size.
;;     never deallocated, tracked in a list for debugging
;;
;;   track used/unused
;;     use linked-list impl similar to pairs, alloc and dealloc will be very
;;     similar value of a free # is the address of the next free number in the
;;     list has value -1
;;
;;   number box types
;;                        BCRE
;;     i64              0x0001 xxxx xxxx xxxx xxxx xxxx xxx1 1111
;;     f64              0x0?00 xxxx xxxx xxxx xxxx xxxx xxx1 1111
;;     rational         0x0011 xxxx xxxx xxxx xxxx xxxx xxx1 1111
;;     complex          0x0101 xxxx xxxx xxxx xxxx xxxx xxx1 1111
;;     integer          0x1001 rrrr rrrr rrrr rrrr xxxx xxx1 1111
;;
;;     B = 1 means that the box value is stored in a block and consists
;;           of up to 2^16 64 bit digits
;;
;;     R = 1 means that the number is rational, the box value is a pair,
;;           the car of which is the numerator the cdr of which is the
;;           denominator
;;
;;     C = 1 means that the number is complex, the car of which is the
;;           real part, the cdr of which is the imaginary part
;;
;;     E = 1 means that the number is exact.
;;
;;     constraints
;;       B = 1 => C = 0, R = 0, E = 1
;;       R = 1 => B = 0, C = 0, E = 1
;;
;;     i64
;;       the box value is an address into a numbers block
;;
;;     f64
;;       box value is either (C=0) an address into a numbers block or
;;       (C=1) a pair, its car and cdr each containing an address into a
;;       numbers block
;;
;;     rational
;;       pair stored in box value, car is num, cdr is denom; num and denomm must
;;       be exact and must not be complex or rational
;;
;;     complex
;;       pair stored in box value, car is re, cdr is im; re and im must be exact
;;       and must not be complex
;;
;;     integer
;;       box value is a block ref containing up to 2^16 64-bit digits
;;
;;   a box type of block has a block ref as its box value. it must also be exact
;;     and not rational nor complex.
;;
;;   a box value which is not complex, rational, or block is an address into a
;;     numbers block if the box type is exact, it is i64, otherwise f64.
;;
;;   a box type which is either complex or rational must have a pair as its value
;;     the value of the pair may be
;;
;;     if the box is rational
;;        the car and cdr may independently be addresss into a numbers block or
;;        references to boxed numbers which are exact and not rational nor
;;        complex, ie a tagged 29-bit integer, an i64, or an integer
;;
;;     if the box is complex and exact
;;        the car and cdr may independently be addresss into a numbers block or
;;        references to boxed numbers which are exact and not complex, ie a
;;        tagged 29-bit integer, an i64, a rational, or an integer
;;
;;     if the box is complex and inexact
;;        the car and cdr must be addresss into a numbers block
;;
;; exhaustive list of number encodings
;;
;;   f64
;;   complex f64
;;   tagged 29-bit
;;   i64
;;   integer
;;   rational 29-bit  29-bit
;;   rational 29-bit  i64
;;   rational 29-bit  integer
;;   rational i64     29-bit
;;   rational i64     i64
;;   rational i64     integer
;;   rational integer 29-bit
;;   rational integer i64
;;   rational integer integer
;;   complex ... 144 binary combinations of { 29-bit i64 integer } + rationals
;;
;;   => 160 different possible encoding structures for a number
;;
;; Required support for parser:
;;   f64? should parser directly synthesize binary form?
;;   Multiply integer by 2 and add 1
;;   Multiply integer by 8 and add 1-7
;;   Multiply integer by 10 and add 1-9
;;   Multiply integer by 16 and add 1-15
;;   create rational
;;   create exact complex
;;   create inexact complex
;;
;; # of bits required to represent a decimal integer of n digits:
;;   log2 10 = 3.321928094887362
;;   256 * log2 10 = 850.4135922911647
;;   add 255 to get ceil with >> 8, and +1 for sign bit:
;;     b = ((n*851 + 255)>>8) + 1
;;   to get number of i64 digits (b + 63) >> 6
;;
;; multiply-add i64 by i32, i32 (n, k)
;;
;;   split i64 into i32 h, l and fill i64x2 with h, l
;;   fill i64x2 with n, n
;;   i64x2 mul -> n*h, n*l
;;   fill i64x2 with 0, k
;;   i64x2.add -> n*h, n*l + k -> a, b
;;   split a in into a_h, a_l
;;   result is a_l << 32 + b, with carry a_h >> 32

(module

 (import "block-mgr" "alloc-block"        (func $alloc-block        (param i32 i32) (result i32)))
 (import "block-mgr" "dealloc-block"      (func $dealloc-block      (param i32 i32)))
 (import "block-mgr" "get-block-ref-addr" (func $get-block-ref-addr (param i32)     (result i32)))
 (import "block-mgr" "get-block-ref-size" (func $get-block-ref-size (param i32)     (result i32)))
 (import "block-mgr" "init-blockset"      (func $init-blockset      (param i32 i32 i32)))
 (import "pairs" "make-pair"              (func $make-pair          (param i32 i32) (result i32)))
 (import "pairs" "make-pair-f32"          (func $make-pair-f32      (param i32 f32) (result i32)))
 (import "pairs" "dealloc-pair"           (func $dealloc-pair       (param i32)))
 (import "pairs" "get-pair-car"           (func $get-pair-car       (param i32)     (result i32)))
 (import "pairs" "get-pair-cdr"           (func $get-pair-cdr       (param i32)     (result i32)))

 (include "./block-mgr-memory-proxy-imports.wam")

 (include "./globals.wam")
 (include "./values.wam")
 (include "./boxes.wam")
 (include "./block-mgr-memory-proxies.wam")

 (memory $memory (debug (export "memory")) 1)

;;     i64              xxxx xxxx xxxx xxxx xxxx 0001 0000 0001
;;     f64              xxxx xxxx xxxx xxxx xxxx 0?00 0000 0001
;;     rational         xxxx xxxx xxxx xxxx xxxx 0011 0000 0001
;;     complex          xxxx xxxx xxxx xxxx xxxx 0101 0000 0001
;;     integer          rrrr rrrr rrrr rrrr rrrr 1001 0000 0001

 (global $number-block-size (debug (export "number-block-size") i32 (i32.const 0x4000)))

 (global $number-type-i64             (debug (export "number-type-i64")             i32 (i32.const 0x00000101)))
 (global $number-type-f64             (debug (export "number-type-f64")             i32 (i32.const 0x00000001)))
 (global $number-type-inexact-complex (debug (export "number-type-inexact-complex") i32 (i32.const 0x00000401)))
 (global $number-type-exact-complex   (debug (export "number-type-exact-complex")   i32 (i32.const 0x00000501)))
 (global $number-type-rational        (debug (export "number-type-rational")        i32 (i32.const 0x00000301)))
 (global $number-type-integer         (debug (export "number-type-integer")         i32 (i32.const 0x00000901)))
 (global $number-type-mask            (debug (export "number-type-mask")            i32 (i32.const 0x00000fff)))

 (global $x64-free-list (debug (export "x64-free-list")) (mut i32) (i32.const 0))
 (debug
  (global $number-block-list (debug (export "number-block-list")) (mut i32) (i32.const 0))
  (global $x64-count (debug (export "x64-count")) (mut i32) (i32.const 0)))

 (start $init-numbers)
 (func $init-numbers (debug (export "init-numbers"))

   (call $init-blockset
         (global.get $numbers-blockset-id)
         (i32.const 0x1000)
         (global.get $number-block-size))

   (call $init-blockset-memory-proxies (global.get $bytevectors-blockset-id))

   (global.set $x64-free-list (global.get $null))
   (debug
    (global.set $number-block-list (global.get $null))
    (global.set $x64-count (i32.const 0))))

 (macro %make-integer-number-type
   (expr ,digits)
   (i32.or (global.get $number-type-integer)
           (i32.shl ,digits (i32.const 12))))

 (macro %get-number-type
   (expr ,x)
   (i32.and (global.get $number-type-mask) ,x))

 (macro %get-integer-addr
   (expr ,int)
   (call $get-block-ref-addr (%get-box-value ,int)))

 (macro %get-integer-size
   (expr ,int)
   (i32.shr_u (i32.and (%get-box-value ,int)
                       (i32.xor (global.get $number-type-mask)
                                (i32.const -1)))
              (i32.const 12)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Allocation
 ;;

 (func $alloc-integer (export "alloc-integer")
   (param $i64-digits i32)
   (result i32)

   (local $addr i32)
   (local $block-ref i32)
   (local $size i32)

   (local.set $size (i32.shl (local.get $i64-digits) (i32.const 3)))

   (local.set $block-ref (call $alloc-block
                               (global.get $numbers-blockset-id)
                               (local.get $size)))

   (local.set $addr (call $get-block-ref-addr (local.get $block-ref)))

   (memory.fill (local.get $addr) (local.get $size) (i32.const 0))

   (%make-box (%make-integer-number-type (local.get $i64-digits))
              (local.get $block-ref)))

 (func $alloc-x64 (debug (export "alloc-x64"))
   (result i32)

   (if (i32.eq (global.get $x64-free-list) (global.get $null))
       (then
        (call $alloc-x64-block)))

   (debug
    (%global.incr i32 $x64-count))

   (global.get $x64-free-list)
   (global.set $x64-free-list (i32.load (global.get $x64-free-list))))

 (func $alloc-x64-block (debug (export "alloc-x64-block"))

   (local $addr i32)
   (local $block-ref i32)
   (local $end-addr i32)
   (local $last-addr i32)
   (local $next-x64 i32)
   (local $x64 i32)

   (local.set $block-ref (call $alloc-block
                               (global.get $numbers-blockset-id)
                               (global.get $number-block-size)))

   (debug
    (global.set $number-block-list
                (call $make-pair
                      (local.get $block-ref)
                      (global.get $number-block-list))))

   (local.set $addr (call $get-block-ref-addr (local.get $block-ref)))
   (local.set $end-addr (i32.add (local.get $addr)
                                 (global.get $number-block-size)))

   (local.set $last-addr (global.get $x64-free-list))
   (loop $again
     (if (i32.lt_u (local.get $addr) (local.get $end-addr))
         (then
          (i32.store (local.get $addr) (local.get $last-addr))
          (local.set $last-addr (local.get $addr))
          (%incr-n i32 $addr 8)
          (br $again))))

   (global.set $x64-free-list (local.get $last-addr)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Deallocation
 ;;

 (func $dealloc-number (export "dealloc-number")
   (param $x i32)

   (local $type i32)
   (local $value i32)

   (if (i32.eq (%get-value-tag (local.get $x)) (global.get $tag-small-integer))
       (then
        (return)))

   (local.set $type (%get-number-type (local.get $x)))
   (local.set $value (%get-box-value (local.get $x)))

   (if (i32.or (i32.eq (local.get $type) (global.get $number-type-f64))
               (i32.eq (local.get $type) (global.get $number-type-i64)))
       (then
        (call $dealloc-x64 (local.get $value))
        (%dealloc-box (local.get $x))
        (return)))

   (if (i32.or (i32.eq (local.get $type) (global.get $number-type-exact-complex))
               (i32.eq (local.get $type) (global.get $number-type-rational)))
       (then
        (call $dealloc-number (call $get-pair-car (local.get $value)))
        (call $dealloc-number (call $get-pair-cdr (local.get $value)))
        (%dealloc-box (local.get $x))
        (return)))

   (if (i32.eq (local.get $type) (global.get $number-type-inexact-complex))
       (then
        (call $dealloc-x64 (call $get-pair-car (local.get $value)))
        (call $dealloc-x64 (call $get-pair-cdr (local.get $value)))
        (%dealloc-box (local.get $x))
        (return)))

   (if (i32.eq (local.get $type) (global.get $number-type-integer))
       (then
        (call $dealloc-block (global.get $numbers-blockset-id) (%get-box-value (local.get $x)))
        (%dealloc-box (local.get $x))
        (return)))

   (unreachable))

 (func $dealloc-x64 (debug (export "dealloc-x64"))
   (param $x64 i32)

   (i32.store (local.get $x64) (global.get $x64-free-list))

   (debug
    (%global.decr i32 $x64-count))

   (global.set $x64-free-list (local.get $x64)))


 ;;-----------------------------------------------------------------------------
 ;;
 ;; Number Constructors
 ;;

  (func $make-small-integer (export "make-small-integer")
   (param $x i32)
   (result i32)
   (%make-value (i32.shl (local.get $x) (global.get $tag-size-bits))
                (global.get $tag-small-integer)))

 (func $make-boxed-i64 (export "make-boxed-i64")
   (param $x i64)
   (result i32)

   (local $x64 i32)
   (local.set $x64 (call $alloc-x64))
   (i64.store (local.get $x64) (local.get $x))

   (%make-box (global.get $number-type-i64) (local.get $x64)))

 (func $make-boxed-f64 (export "make-boxed-f64")
   (param $x f64)
   (result i32)

   (local $x64 i32)
   (local.set $x64 (call $alloc-x64))
   (f64.store (local.get $x64) (local.get $x))

   (%make-box (global.get $number-type-f64) (local.get $x64)))

 (func $make-rational (export "make-rational")
   (param $n i32)
   (param $d i32)
   (result i32)

   (%make-box (global.get $number-type-rational)
              (call $make-pair
                    (local.get $n)
                    (local.get $d))))

 (func $make-exact-complex (export "make-exact-complex")
   (param $re i32)
   (param $im i32)
   (result i32)

   (%make-box (global.get $number-type-exact-complex)
              (call $make-pair
                    (local.get $re)
                    (local.get $im))))

 (func $make-inexact-complex (export "make-inexact-complex")
   (param $re i32)
   (param $im i32)
   (result i32)

   (%make-box (global.get $number-type-inexact-complex)
              (call $make-pair
                    (local.get $re)
                    (local.get $im))))

 (func $make-integer (export "make-integer")
   (param $x i64)
   (param $size i32)
   (result i32)

   (local $int i32)
   (local.set $int (call $alloc-integer (local.get $size)))

   (i64.store (%get-integer-addr (local.get $int)) (local.get $x))
   (local.get $int))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Parsing support for integers
 ;;

 (func $multiply-add-integer-i32 (export "multiply-add-integer-i32")
   (param $int i32)
   (param $n i32)
   (param $k i32)

   (local $addr i32)
   (local $c i64)
   (local $end-addr i32)
   (local $m i64)
   (local $v i64)

   (local.set $m (i64.extend_i32_u (local.get $n)))
   (local.set $c (i64.extend_i32_u (local.get $k)))

   (local.set $addr (%get-integer-addr (local.get $int)))
   (local.set $end-addr (i32.add (local.get $addr) (%get-integer-size (local.get $int))))

   (loop $again
     (if (i32.lt_u (local.get $addr) (local.get $end-addr))
         (then
          (local.set $v (i64.add (i64.mul (i64.load32_u (local.get $addr))
                                          (local.get $m))
                                 (local.get $c)))
          (i32.store (local.get $addr) (i32.wrap_i64 (local.get $v)))
          (local.set $c (i64.shr_u (local.get $v) (i64.const 32)))
          (%incr-n i32 $addr 4)
          (br $again)))))

 (func $negate-integer (export "negate-integer")
   (param $int i32)

   (local $addr i32)
   (local $c i64)
   (local $end-addr i32)
   (local $v i64)

   (local.set $addr (%get-integer-addr (local.get $int)))
   (local.set $end-addr (i32.add (local.get $addr) (%get-integer-size (local.get $int))))

   (local.set $c (i64.const 1))

   (loop $again
     (if (i32.lt_u (local.get $addr) (local.get $end-addr))
         (then
          (local.set $v (i64.add (i64.xor (i64.load (local.get $addr))
                                          (i64.const -1))
                                 (local.get $c)))

          (i64.store (local.get $addr) (local.get $v))

          (if (i64.ne (local.get $v) (i64.const 0))
              (then
               (local.set $c (i64.const 0))))

          (%incr-n i32 $addr 8)
          (br $again)))))

 (func $set-integer-i64-digit (export "set-integer-i64-digit")
   (param $int i32)
   (param $i i32)
   (param $d i64)

   (i64.store (i32.add (%get-integer-addr (local.get $int))
                       (i32.shl (local.get $i)
                                (i32.const 3)))
              (local.get $d)))

 )

;; number encoding
;;
;;   numbers block
;;     a block in which to store discrete i64s and f64s
;;     alloc number blocks as needed, of size immobile block size.
;;     never deallocated, tracked in a list for debugging
;;
;;   track used/unused
;;     use linked-list impl similar to pairs, alloc and dealloc will be very
;;     similar value of a free # is the address of the next free number in the
;;     list has value -1
;;
;;   number box types
;;                        BCRE
;;     i64              0x0001 xxxx xxxx xxxx xxxx xxxx xxx1 1111
;;     f64              0x0?00 xxxx xxxx xxxx xxxx xxxx xxx1 1111
;;     rational         0x0011 xxxx xxxx xxxx xxxx xxxx xxx1 1111
;;     complex          0x0101 xxxx xxxx xxxx xxxx xxxx xxx1 1111
;;     integer          0x1001 rrrr rrrr rrrr rrrr xxxx xxx1 1111
;;
;;     B = 1 means that the box value is stored in a block and consists
;;           of up to 2^16 64 bit digits
;;
;;     R = 1 means that the number is rational, the box value is a pair,
;;           the car of which is the numerator the cdr of which is the
;;           denominator
;;
;;     C = 1 means that the number is complex, the car of which is the
;;           real part, the cdr of which is the imaginary part
;;
;;     E = 1 means that the number is exact.
;;
;;     constraints
;;       B = 1 => C = 0, R = 0, E = 1
;;       R = 1 => B = 0, C = 0, E = 1
;;
;;     i64
;;       the box value is an address into a numbers block
;;
;;     f64
;;       box value is either (C=0) an address into a numbers block or
;;       (C=1) a pair, its car and cdr each containing an address into a
;;       numbers block
;;
;;     rational
;;       pair stored in box value, car is num, cdr is denom; num and denomm must
;;       be exact and must not be complex or rational
;;
;;     complex
;;       pair stored in box value, car is re, cdr is im; re and im must be exact
;;       and must not be complex
;;
;;     integer
;;       box value is a block ref containing up to 2^16 64-bit digits
;;
;;   a box type of block has a block ref as its box value. it must also be exact
;;     and not rational nor complex.
;;
;;   a box value which is not complex, rational, or block is an address into a
;;     numbers block if the box type is exact, it is i64, otherwise f64.
;;
;;   a box type which is either complex or rational must have a pair as its value
;;     the value of the pair may be
;;
;;     if the box is rational
;;        the car and cdr may independently be addresss into a numbers block or
;;        references to boxed numbers which are exact and not rational nor
;;        complex, ie a tagged 29-bit integer, an i64, or an integer
;;
;;     if the box is complex and exact
;;        the car and cdr may independently be addresss into a numbers block or
;;        references to boxed numbers which are exact and not complex, ie a
;;        tagged 29-bit integer, an i64, a rational, or an integer
;;
;;     if the box is complex and inexact
;;        the car and cdr must be addresss into a numbers block
;;
;; exhaustive list of number encodings
;;
;;   f64
;;   complex f64
;;   tagged 29-bit
;;   i64
;;   integer
;;   rational 29-bit  29-bit
;;   rational 29-bit  i64
;;   rational 29-bit  integer
;;   rational i64     29-bit
;;   rational i64     i64
;;   rational i64     integer
;;   rational integer 29-bit
;;   rational integer i64
;;   rational integer integer
;;   complex ... 144 binary combinations of { 29-bit i64 integer } + rationals
;;
;;   => 160 different possible encoding structures for a number
;;
;; Required support for parser:
;;   f64? should parser directly synthesize binary form?
;;   Multiply integer by 2 and add 1
;;   Multiply integer by 8 and add 1-7
;;   Multiply integer by 10 and add 1-9
;;   Multiply integer by 16 and add 1-15
;;   create rational
;;   create exact complex
;;   create inexact complex
;;
;; # of bits required to represent a decimal integer of n digits:
;;   log2 10 = 3.321928094887362
;;   256 * log2 10 = 850.4135922911647
;;   add 255 to get ceil with >> 8, and +1 for sign bit:
;;     b = ((n*851 + 255)>>8) + 1
;;   to get number of i64 digits (b + 63) >> 6
;;
;; multiply-add i64 by i32, i32 (n, k)
;;
;;   split i64 into i32 h, l and fill i64x2 with h, l
;;   fill i64x2 with n, n
;;   i64x2 mul -> n*h, n*l
;;   fill i64x2 with 0, k
;;   i64x2.add -> n*h, n*l + k -> a, b
;;   split a in into a_h, a_l
;;   result is a_l << 32 + b, with carry a_h >> 32

(module

 (import "block-mgr" "alloc-block"    (func $alloc-block    (param i32 i32) (result i32)))
 (import "block-mgr" "dealloc-block"  (func $dealloc-block  (param i32 i32)))
 (import "block-mgr" "get-block-addr" (func $get-block-addr (param i32)     (result i32)))
 (import "block-mgr" "get-block-size" (func $get-block-size (param i32)     (result i32)))
 (import "block-mgr" "init-blockset"  (func $init-blockset  (param i32 i32)))
 (import "pairs" "make-pair"          (func $make-pair      (param i32 i32) (result i32)))
 (import "pairs" "dealloc-pair"       (func $dealloc-pair   (param i32)))
 (import "pairs" "get-pair-car"       (func $get-pair-car   (param i32)     (result i32)))
 (import "pairs" "get-pair-cdr"       (func $get-pair-cdr   (param i32)     (result i32)))
 (import "pairs" "set-pair-car"       (func $set-pair-car   (param i32 i32)))
 (import "pairs" "set-pair-cdr"       (func $set-pair-cdr   (param i32 i32)))

 (include "./block-mgr-memory-proxy-imports.wam")

 (include "./constants.wam")
 (include "./globals.wam")
 (include "./values.wam")
 (include "./boxes.wam")
 (include "./block-mgr-memory-proxies.wam")

 (memory $memory (debug (export "memory")) 1)

 (debug (global $debug (export "#debug") (mut i32) (i32.const 0)))

 ;;     i64              xxxx xxxx xxxx xxxx xxxx 0001 0000 0001
 ;;     f64              xxxx xxxx xxxx xxxx xxxx 0?00 0000 0001
 ;;     rational         xxxx xxxx xxxx xxxx xxxx 0011 0000 0001
 ;;     complex          xxxx xxxx xxxx xxxx xxxx 0101 0000 0001
 ;;     integer          rrrr rrrr rrrr rrrr rrrr 1001 0000 0001

 (define _number-block-size    (i32.const 0x400))

 (define _number-type-i64      (i32.const 0x00000101))
 (define _number-type-f64      (i32.const 0x00000001))
 (define _number-type-complex  (i32.const 0x00000401))
 (define _number-type-rational (i32.const 0x00000301))
 (define _number-type-integer  (i32.const 0x00000901))
 (define _number-type-mask     (i32.const 0x00000fff))

 (debug
  (global $number-block-size    (export "number-block-size")    i32 _number-block-size)

  (global $number-type-i64      (export "number-type-i64")      i32 _number-type-i64)
  (global $number-type-f64      (export "number-type-f64")      i32 _number-type-f64)
  (global $number-type-complex  (export "number-type-complex")  i32 _number-type-complex)
  (global $number-type-rational (export "number-type-rational") i32 _number-type-rational)
  (global $number-type-integer  (export "number-type-integer")  i32 _number-type-integer)
  (global $number-type-mask     (export "number-type-mask")     i32 _number-type-mask))

 (const #i32-size 4)
 (const #i64-size 8)

 (const #i32-size-bits 2)
 (const #i64-size-bits 3)

 (global $x64-free-list (debug (export "x64-free-list")) (mut i32) (i32.const 0))
 (debug
  (global $number-block-list (debug (export "number-block-list")) (mut i32) (i32.const 0))
  (global $x64-count (debug (export "x64-count")) (mut i32) (i32.const 0)))

 (start $init-numbers)
 (func $init-numbers (debug (export "init-numbers"))

   ($init-blockset _numbers-blockset _number-block-size)

   ($init-blockset-memory-proxies _numbers-blockset)

   (global.set $x64-free-list _null)
   (debug
    (global.set $number-block-list _null)
    (global.set $x64-count (i32.const 0))))

 (macro %make-integer-number-type
   (expr ,digits)
   (i32.or _number-type-integer
           (i32.shl ,digits (i32.const 12))))

 (macro %get-number-type
   (expr ,x)
   (i32.and _number-type-mask ,x))

 (macro %get-integer-addr
   (expr ,int)
   ($get-block-addr (%get-box-value ,int)))

 (macro %get-integer-size
   (expr ,int)
   (i32.shr_u (i32.and (%get-box-type ,int)
                       (i32.xor _number-type-mask (i32.const -1)))
              (i32.const 12)))

 (macro %get-i64-digit-addr
   (expr ,int)
   (expr ,idx)
   (i32.add (%get-integer-addr ,int) (i32.shl ,idx (i32.const #i64-size-bits))))

 (macro %get-i32-digit-addr
   (expr ,int)
   (expr ,idx)
   (i32.add (%get-integer-addr ,int) (i32.shl ,idx (i32.const #i32-size-bits))))

 (macro %negate-small-integer
   (expr ,x)
   (i32.sub (i32.const 0) ,x))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Allocation
 ;;

 (func $alloc-integer (export "alloc-integer")
   (param $i64-digits i32)
   (result i32)

   (local $addr i32)
   (local $block i32)
   (local $size i32)

   (set! $size (i32.shl $i64-digits (i32.const #i64-size-bits)))

   (set! $block ($alloc-block _numbers-blockset $size))

   (set! $addr ($get-block-addr $block))

   (memory.fill $addr (i32.const 0) $size)

   (%make-box (%make-integer-number-type $i64-digits)
              $block))

 (func $alloc-x64 (debug (export "alloc-x64"))
   (result i32)

   (if (i32.eq (global.get $x64-free-list) _null)
       (then
        ($alloc-x64-block)))

   (debug
    (%global.incr i32 $x64-count))

   (global.get $x64-free-list)
   (global.set $x64-free-list (i32.load (global.get $x64-free-list))))

 (func $alloc-x64-block (debug (export "alloc-x64-block"))

   (local $addr i32)
   (local $block i32)
   (local $end-addr i32)
   (local $last-addr i32)
   (local $next-x64 i32)
   (local $x64 i32)

   (set! $block ($alloc-block _numbers-blockset _number-block-size))

   (debug
    (global.set $number-block-list ($make-pair $block (global.get $number-block-list))))

   (set! $addr ($get-block-addr $block))
   (set! $end-addr (i32.add $addr _number-block-size))

   (set! $last-addr (global.get $x64-free-list))
   (loop $again
     (if (i32.lt_u $addr $end-addr)
         (then
          (i32.store $addr $last-addr)
          (set! $last-addr $addr)
          (%incr-n i32 $addr #i64-size)
          (br $again))))

   (global.set $x64-free-list $last-addr))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Deallocation
 ;;

 (func $dealloc-number (export "dealloc-number")
   (param $x i32)

   (local $type i32)
   (local $value i32)

   (if (i32.eq (%get-value-tag $x) _tag-small-integer)
       (then
        (return)))

   (set! $type (%get-number-type $x))
   (set! $value (%get-box-value $x))

   (if (i32.or (i32.eq $type _number-type-f64)
               (i32.eq $type _number-type-i64))
       (then
        ($dealloc-x64 $value)
        (%dealloc-box $x)
        (return)))

   (if (i32.or (i32.eq $type _number-type-complex)
               (i32.eq $type _number-type-rational))
       (then
        ($dealloc-number ($get-pair-car $value))
        ($dealloc-number ($get-pair-cdr $value))
        ($dealloc-pair $value)
        (%dealloc-box $x)
        (return)))

   (if (i32.eq $type _number-type-integer)
       (then
        ($dealloc-block _numbers-blockset $value)
        (%dealloc-box $x)
        (return)))

   (unreachable))

 (func $dealloc-x64 (debug (export "dealloc-x64"))
   (param $x64 i32)

   (i32.store $x64 (global.get $x64-free-list))

   (debug
    (%global.decr i32 $x64-count))

   (global.set $x64-free-list $x64))


 ;;-----------------------------------------------------------------------------
 ;;
 ;; Number Constructors
 ;;

 (func $make-small-integer (export "make-small-integer")
   (param $x i32)
   (result i32)
   (%make-value (i32.shl $x _tag-size-bits)
                _tag-small-integer))

 (func $make-boxed-i64 (export "make-boxed-i64")
   (param $x i64)
   (result i32)

   (local $x64 i32)
   (set! $x64 ($alloc-x64))
   (i64.store $x64 $x)

   (%make-box _number-type-i64 $x64))

 (func $make-boxed-f64 (export "make-boxed-f64")
   (param $x f64)
   (result i32)

   (local $x64 i32)
   (set! $x64 ($alloc-x64))
   (f64.store $x64 $x)

   (%make-box _number-type-f64 $x64))

 (func $make-rational (export "make-rational")
   (param $n i32)
   (param $d i32)
   (result i32)

   (%make-box _number-type-rational ($make-pair $n $d)))

 (func $make-complex (export "make-complex")
   (param $re i32)
   (param $im i32)
   (result i32)

   (%make-box _number-type-complex ($make-pair $re $im)))

 (func $make-integer (export "make-integer")
   (param $x i64)
   (param $size i32)
   (result i32)

   (local $int i32)
   (set! $int ($alloc-integer $size))

   (i64.store (%get-integer-addr $int) $x)

   $int)

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Parsing and display support for integers
 ;;

 (func $multiply-add-integer-i32 (export "multiply-add-integer-i32")
   (param $int i32)
   (param $n i32)
   (param $k i32)

   (local $addr i32)
   (local $c i64)
   (local $end-addr i32)
   (local $m i64)
   (local $v i64)

   (set! $m (i64.extend_i32_u $n))
   (set! $c (i64.extend_i32_u $k))

   (set! $addr (%get-integer-addr $int))
   (set! $end-addr (i32.add $addr
                            (i32.shl (%get-integer-size $int)
                                     (i32.const #i64-size-bits))))

   (loop $again
     (if (i32.lt_u $addr $end-addr)
         (then
          (set! $v (i64.add (i64.mul (i64.load32_u $addr) $m) $c))
          (i32.store $addr (i32.wrap_i64 $v))
          (set! $c (i64.shr_u $v (i64.const 32)))
          (%incr-n i32 $addr #i32-size)
          (br $again)))))

 (func $negate-number (export "negate-number")
   (param $x i32)
   (result i32)

   (local $type i32)
   (local $value i32)

   (if (i32.eq (%get-value-tag $x) _tag-small-integer)
       (then
        (return (%negate-small-integer $x))))

   (set! $type (%get-number-type $x))
   (set! $value (%get-box-value $x))

   (if (i32.eq $type _number-type-f64)
       (then
        ($negate-f64 $x)
        (return $x)))

   (if (i32.eq $type _number-type-i64)
       (then
        ($negate-i64 $x)
        (return $x)))

   (if (i32.eq $type _number-type-complex)
       (then
        ;; re
        ($set-pair-car $x ($negate-number ($get-pair-car $value)))
        ;; im
        ($set-pair-cdr $x ($negate-number ($get-pair-cdr $value)))
        (return $x)))

   (if (i32.eq $type _number-type-rational)
       (then
        ;; numerator
        ($set-pair-car $x ($negate-number ($get-pair-car $value)))
        (return $x)))

   (if (i32.eq $type _number-type-integer)
       (then
        ($negate-integer $x)
        (return $x)))

   (unreachable))

 (func $negate-f64 (export "negate-f64")
   (param $x i32)
   (local $addr i32)

   (set! $addr (%get-box-value $x))
   (f64.store $addr (f64.neg (f64.load $addr))))

 (func $negate-i64 (export "negate-i64")
   (param $x i32)
   (local $addr i32)

   (set! $addr (%get-box-value $x))
   (i64.store $addr (i64.sub (i64.const 0) (i64.load $addr))))

 (func $negate-integer (export "negate-integer")
   (param $int i32)

   (local $addr i32)
   (local $c i64)
   (local $end-addr i32)
   (local $v i64)

   (set! $addr (%get-integer-addr $int))
   (set! $end-addr (i32.add $addr (%get-integer-size $int)))

   (set! $c (i64.const 1))

   (loop $again
     (if (i32.lt_u $addr $end-addr)
         (then
          (set! $v (i64.add (i64.xor (i64.load $addr) (i64.const -1))
                            $c))

          (i64.store $addr $v)

          (if (i64.ne $v (i64.const 0))
              (then
               (set! $c (i64.const 0))))

          (%incr-n i32 $addr #i64-size)
          (br $again)))))

 (func $get-integer-size (export "get-integer-size")
   (param $int i32)
   (result i32)
   (%get-integer-size $int))

 (func $get-integer-digit-i32 (export "get-integer-digit-i32")
   (param $int i32)
   (param $idx i32)
   (result i32)

   (i32.load (%get-i32-digit-addr $int $idx)))

 (func $get-integer-digit-i64 (export "get-integer-digit-i64")
   (param $int i32)
   (param $idx i32)
   (result i64)

   (i64.load (%get-i64-digit-addr $int $idx)))

 (func $set-integer-i32-digit (export "set-integer-i32-digit")
   (param $int i32)
   (param $idx i32)
   (param $digit i32)

   (i32.store (%get-i32-digit-addr $int $idx) $digit))

 (func $set-integer-i64-digit (export "set-integer-i64-digit")
   (param $int i32)
   (param $idx i32)
   (param $digit i64)

   (i64.store (%get-i64-digit-addr $int $idx) $digit))

 (func $coerce-f64 (export "coerce-f64")
   (param $x i32)
   (result f64)

   (local $type i32)
   (local $value i32)

   (if (i32.eq (%get-value-tag $x) _tag-small-integer)
       (then
        (return (f64.convert_i32_s (i32.shr_s $x _tag-size-bits)))))

   (set! $type (%get-number-type $x))
   (set! $value (%get-box-value $x))

   (if (i32.eq $type _number-type-f64)
       (then
        (f64.load $value)
        ($dealloc-number $x)
        (return)))

   (if (i32.eq $type _number-type-i64)
       (then
        (f64.convert_i64_s (i64.load $value))
        ($dealloc-number $x)
        (return)))

   (if (i32.eq $type _number-type-rational)
       (then
        ;; Where the rational contains an integer of sufficient size,
        ;; this may produce an inf or 0 where it might otherwise have
        ;; a finite non-zero value.  Once extended integer division is
        ;; implemented, this can be addressed more simply. todo
        (f64.div ($coerce-f64 ($get-pair-car $value))
                 ($coerce-f64 ($get-pair-cdr $value)))
        ($dealloc-pair $value)
        ($dealloc-pair $x)
        (return)))

   (if (i32.eq $type _number-type-integer)
       (then
        ($coerce-integer-f64 $x)
        ($dealloc-number $x)
        (return)))

   (if (i32.eq $type _number-type-complex)
       ;; technically possible when im=0, but the use case is in
       ;; parsing where this case is not possible due to the lexical
       ;; structure.
       (then (unreachable)))

   (unreachable)

   ;; needed for type check
   (f64.const 0))

 (func $coerce-integer-f64 (debug (export "coerce-integer-f64"))
   (param $int i32)
   (result f64)

   (local $abs-result f64)
   (local $addr i32)
   (local $digit i64)
   (local $end-addr i32)
   (local $is-negative i32)
   (local $precision i32)
   (local $sign i32)
   (local $size i32)

   (set! $size (%get-integer-size $int))

   ;; size is the number of 64 bit digits so multiply by 64.
   (set! $precision (i32.shl $size (i32.const 6)))

   (set! $end-addr (%get-integer-addr $int))
   (set! $addr (i32.add $end-addr
                        (i32.shl (i32.sub $size (i32.const 1))
                                 (i32.const #i64-size-bits))))

   (set! $is-negative (i64.lt_s (i64.load $addr) (i64.const 0)))

   (if $is-negative
       (then ($negate-integer $int)))

   (loop $again
     (set! $digit (i64.load $addr))

     (if (i32.and (i64.eqz $digit)
                  (i32.ne $addr $end-addr))
         (then
          (%decr-n i32 $addr 8)
          (br $again))))

   (set! $precision (if (result i32) (i64.eqz $digit)
                      (then
                       (i32.const 0))
                      (else
                       (i32.add (i32.sub (i32.const 64 (i32.wrap_i64 (i64.clz $digit))))
                                (i32.shl (i32.sub $addr $end-addr)
                                         (i32.const 3))))))

   (set! $abs-result (if (result f64) (i32.lt_u $precision (i32.const 64))
                       (then
                        (f64.convert_i64_u $digit))
                       (else
                        (if (result f64) (i32.le_u $precision (i32.const 1024))
                          (then
                           ($build-f64 $digit
                                       (i64.load (i32.sub $addr (i32.const 8)))
                                       $precision))
                          (else
                           (f64.const +inf))))))

   (if (result f64) $is-negative
     (then (f64.neg $abs-result))
     (else $abs-result)))

 (func $build-f64 (debug (export "build-f64"))
   (param $leading-digit i64)
   (param $next-digit i64)
   (param $precision i32)
   (result f64)

   (local $abcissa i64)
   (local $mantissa i64)
   (local $prec-rem i32)
   (local $shift i64)

   (set! $abcissa (i64.shl (i64.extend_i32_u (i32.add (i32.sub $precision (i32.const 1))
                                                      (i32.const 1023)))
                           (i64.const 53)))

   ;; remainder of $precision when divided by 64
   (set! $prec-rem (i32.and $precision (i32.const 0x1f)))

   (set! $mantissa (i64.and
                    (i64.const 0x001fffffffffffff) ;; trim to 53 bits
                    ;; collect the most significant 54 bits of the integer
                    (if (result i64) (i32.ge_u $prec-rem (i32.const 54))
                      (then
                       (i64.shr_u $leading-digit
                                  (i64.sub (i64.extend_i32_u $prec-rem)
                                           (i64.const 54))))
                      (else
                       (set! $shift (i64.sub (i64.const 54) (i64.extend_i32_u $prec-rem)))
                       (i64.or (i64.shl $leading-digit $shift)
                               (i64.shr_u $next-digit (i64.sub (i64.const 64) $shift)))))))

   (f64.reinterpret_i64 (i64.or $abcissa $mantissa)))



)

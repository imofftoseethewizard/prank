;; number encoding
;;
;;   numbers block
;;     a block in which to store discrete i64s and f64s
;;     alloc number blocks as needed, of size immobile block size.
;;     never deallocated, tracked in a list for debugging
;;
;;   track used/unused
;;     use linked-list impl similar to pairs, alloc and dealloc will be very
;;     similar value of a free # is the address of the next free number in the
;;     list has value -1
;;
;;   number box types
;;                        BCRE
;;     i64              0x0001 xxxx xxxx xxxx xxxx xxxx xxx1 1111
;;     f64              0x0?00 xxxx xxxx xxxx xxxx xxxx xxx1 1111
;;     rational         0x0011 xxxx xxxx xxxx xxxx xxxx xxx1 1111
;;     complex          0x0101 xxxx xxxx xxxx xxxx xxxx xxx1 1111
;;     integer          0x1001 rrrr rrrr rrrr rrrr xxxx xxx1 1111
;;
;;     B = 1 means that the box value is stored in a block and consists
;;           of up to 2^16 64 bit digits
;;
;;     R = 1 means that the number is rational, the box value is a pair,
;;           the car of which is the numerator the cdr of which is the
;;           denominator
;;
;;     C = 1 means that the number is complex, the car of which is the
;;           real part, the cdr of which is the imaginary part
;;
;;     E = 1 means that the number is exact.
;;
;;     constraints
;;       B = 1 => C = 0, R = 0, E = 1
;;       R = 1 => B = 0, C = 0, E = 1
;;
;;     i64
;;       the box value is an address into a numbers block
;;
;;     f64
;;       box value is either (C=0) an address into a numbers block or
;;       (C=1) a pair, its car and cdr each containing an address into a
;;       numbers block
;;
;;     rational
;;       pair stored in box value, car is num, cdr is denom; num and denomm must
;;       be exact and must not be complex or rational
;;
;;     complex
;;       pair stored in box value, car is re, cdr is im; re and im must be exact
;;       and must not be complex
;;
;;     integer
;;       box value is a block ref containing up to 2^16 64-bit digits
;;
;;   a box type of block has a block ref as its box value. it must also be exact
;;     and not rational nor complex.
;;
;;   a box value which is not complex, rational, or block is an address into a
;;     numbers block if the box type is exact, it is i64, otherwise f64.
;;
;;   a box type which is either complex or rational must have a pair as its value
;;     the value of the pair may be
;;
;;     if the box is rational
;;        the car and cdr may independently be addresss into a numbers block or
;;        references to boxed numbers which are exact and not rational nor
;;        complex, ie a tagged 29-bit integer, an i64, or an integer
;;
;;     if the box is complex and exact
;;        the car and cdr may independently be addresss into a numbers block or
;;        references to boxed numbers which are exact and not complex, ie a
;;        tagged 29-bit integer, an i64, a rational, or an integer
;;
;;     if the box is complex and inexact
;;        the car and cdr must be addresss into a numbers block
;;
;; exhaustive list of number encodings
;;
;;   f64
;;   complex f64
;;   tagged 29-bit
;;   i64
;;   integer
;;   rational 29-bit  29-bit
;;   rational 29-bit  i64
;;   rational 29-bit  integer
;;   rational i64     29-bit
;;   rational i64     i64
;;   rational i64     integer
;;   rational integer 29-bit
;;   rational integer i64
;;   rational integer integer
;;   complex ... 144 binary combinations of { 29-bit i64 integer } + rationals
;;
;;   => 160 different possible encoding structures for a number
;;
;; Required support for parser:
;;   f64? should parser directly synthesize binary form?
;;   Multiply simple integer types (29-bit, i64, integer) by 2 and add 1
;;   Multiply simple integer types (29-bit, i64, integer) by 8 and add 1-7
;;   Multiply simple integer types (29-bit, i64, integer) by 10 and add 1-9
;;   Multiply simple integer types (29-bit, i64, integer) by 16 and add 1-15
;;   auto promote 29-bit to i64 and i64 to integer prior to overflow
;;   create rational
;;   create exact complex
;;   create inexact complex
;;

(module

 (import "block-mgr" "alloc-block"        (func $alloc-block        (param i32 i32) (result i32)))
 (import "block-mgr" "dealloc-block"      (func $dealloc-block      (param i32 i32)))
 (import "block-mgr" "get-block-ref-addr" (func $get-block-ref-addr (param i32)     (result i32)))
 (import "block-mgr" "get-block-ref-size" (func $get-block-ref-size (param i32)     (result i32)))
 (import "block-mgr" "init-blockset"      (func $init-blockset      (param i32 i32 i32)))
 (import "pairs" "make-pair"              (func $make-pair          (param i32 i32) (result i32)))
 (import "pairs" "make-pair-f32"          (func $make-pair-f32      (param i32 f32) (result i32)))
 (import "pairs" "dealloc-pair"           (func $dealloc-pair       (param i32)))
 (import "pairs" "get-pair-car"           (func $get-pair-car       (param i32)     (result i32)))
 (import "pairs" "get-pair-cdr"           (func $get-pair-cdr       (param i32)     (result i32)))

 (include "./block-mgr-memory-proxy-imports.wam")

 (include "./globals.wam")
 (include "./values.wam")
 (include "./boxes.wam")
 (include "./block-mgr-memory-proxies.wam")

 (memory $memory (debug (export "memory")) 1)

 (global $box-flag-block-number           (debug (export "box-flag-block-number")           i32 (i32.const 0x80000000)))
 (global $box-flag-rational-number        (debug (export "box-flag-rational-number")        i32 (i32.const 0x40000000)))
 (global $box-flag-complex-number         (debug (export "box-flag-complex-number")         i32 (i32.const 0x20000000)))
 (global $box-flag-exact-number           (debug (export "box-flag-exact-number")           i32 (i32.const 0x10000000)))

 (global $box-type-number-i32             (debug (export "box-type-number-i32")             i32 (i32.const 0x1000001f)))
 (global $box-type-number-f64             (debug (export "box-type-number-f64")             i32 (i32.const 0x0000001f)))
 (global $box-type-number-f64-complex     (debug (export "box-type-number-f64-complex")     i32 (i32.const 0x2000001f)))
 (global $box-type-rational         (debug (export "box-type-block-rational")         i32 (i32.const 0x6000001f)))
 (global $box-type-complex          (debug (export "box-type-block-complex")          i32 (i32.const 0x5000001f)))
 (global $box-type-integer (debug (export "box-type-block-complex-rational") i32 (i32.const 0x7000001f)))

 (start $init-numbers)
 (func $init-numbers (debug (export "init-numbers"))

   (call $init-blockset
         (global.get $numbers-blockset-id)
         (i32.const 0x1000)
         (i32.const 0x8000))

   (call $init-blockset-memory-proxies (global.get $bytevectors-blockset-id)))

 (func $make-small-integer (export "make-small-integer")
   (param $x i32)
   (result i32)
   (%make-value (i32.shl (local.get $x) (global.get $tag-size-bits))
                (global.get $tag-small-integer)))

 (func $make-boxed-i32 (export "make-boxed-i32")
   (param $x i32)
   (result i32)
   (%make-box (global.get $box-type-number-i32) (local.get $x)))

 (func $make-boxed-f32 (export "make-boxed-f32")
   (param $x f32)
   (result i32)
   (%make-box-f32 (global.get $box-type-number-f32) (local.get $x)))

 (func $make-block-f64 (export "make-block-f64")
   (param $x f64)
   (result i32)

   (local $block-ref i32)

   (local.set $block-ref (call $alloc-block
                               (global.get $numbers-blockset-id)
                               (i32.const 8)))

   (f64.store (call $get-block-ref-addr (local.get $block-ref))
              (local.get $x))

   (%make-box (global.get $box-type-number-f64) (local.get $block-ref)))

 (func $make-block-f64-complex (export "make-block-complex-f64")
   (param $re f64)
   (param $im f64)
   (result i32)

   (local $block-ref i32)

   (local.set $block-ref (call $alloc-block
                               (global.get $numbers-blockset-id)
                               (i32.const 16)))

   (f64.store (call $get-block-ref-addr (local.get $block-ref))
              (local.get $re))

   (f64.store (i32.add (call $get-block-ref-addr (local.get $block-ref))
                       (i32.const 8))
              (local.get $im))

   (%make-box (global.get $box-type-number-f64-complex) (local.get $block-ref)))

 (func $make-block-integer-i32 (export "make-block-integer-i32")
   (param $x i32)
   (result i32)

   (call $make-small-block-number
         (local.get $x)
         (i32.const 1)
         (i32.const 0)
         (i32.const 1)))

 (func $make-block-rational (export "make-block-rational")
   (param $n i32)
   (param $d i32)
   (result i32)

   (call $make-small-block-number
         (local.get $n)
         (local.get $d)
         (i32.const 0)
         (i32.const 1)))

 (func $make-block-complex-integer (export "make-block-complex-integer")
   (param $re i32)
   (param $im i32)
   (result i32)

   (call $make-small-block-number
         (local.get $re)
         (local.get 1)
         (i32.const $im)
         (i32.const 1)))

 (func $make-small-block-number (export "make-small-block-number")
   (param $re-n i32)
   (param $re-d i32)
   (param $im-n i32)
   (param $im-d i32)
   (result i32)

   (local $block-ref i32)
   (local $block-addr i32)

   (local $re-size i32)
   (local $im-size i32)

   (local $re-byte-size i32)
   (local $im-byte-size i32)

   (local.set $re-size (call $get-rational-size (local.get $re)))
   (local.set $im-size (call $get-rational-size (local.get $im)))

   (local.set $re-byte-size (i32.shl (local.get $re-size) (i32.const 2)))
   (local.set $im-byte-size (i32.shl (local.get $im-size) (i32.const 2)))

   (local.set $block-ref (call $alloc-block
                               (global.get $numbers-blockset-id)
                               (i32.add (local.get $im-byte-size)
                                        (local.get $re-byte-size))))

   (local.set $block-addr (call $get-block-ref-addr (local.get $block-ref)))

   (memory.copy (local.get $block-addr)
                (call $get-integer-addr (local.get $re))
                (local.get $re-byte-size))

   (memory.copy (i32.add (local.get $block-addr)
                         (local.get $re-byte-size))
                (call $get-integer-addr (local.get $im))
                (local.get $im-byte-size))

   (%make-box (%make-complex-rational-box-type
               (call $get-rational-n-size (local.get $re))
               (call $get-rational-d-size (local.get $re))
               (call $get-rational-n-size (local.get $im))
               (call $get-rational-d-size (local.get $im)))
              (local.get $block-ref))))

(module

 (include "./lex-r7rs-rule-ids.wam")

 (func $make-parse-context (debug (export "make-parse-context"))
   (result i32)

   (local $ctx i32)

   (%set! $ctx ($alloc-vector _parse-context-size))
   (%set-ctx-flags $ctx (i32.const 0))
   (%set-ctx-value $ctx ($make-pair _null _null))

   (%get $ctx))

 (func $nest (debug (export "nest"))

   (local $ctx i32)

   (%set-ctx-stack ($make-pair ($make-parse-context) (%get-ctx-stack))))

 (func $unnest (debug (export "unnest"))

   (local $ctx i32)
   (local $head i32)
   (local $value i32)

   (%set! $head (%get-ctx-stack))

   (if (i32.eq (%get $head) _null)
       (then
        ;; fail unmatched close paren
        (return)
        ))

   (%set! $ctx ($get-pair-car (%get $head)))
   (%set-ctx-stack ($get-pair-cdr (%get $head)))

   ($dealloc-pair (%get $head))
   (%set! $value (%get-ctx-value (%get $ctx)))

   (if (%is-bytevector-ctx (%get $ctx))
       (then
        ($append-value ($make-bytevector (%get $value)))
        ($dealloc-list (%get $value)))
     (else
      (if (%is-vector-ctx (%get $ctx))
          (then
           ($append-value ($make-vector (%get $value)))
           ($dealloc-list (%get $value)))
        (else
         ($append-value (%get $value))))))

   ($dealloc-parse-context (%get $ctx)))

 (func $append-value (debug (export "append-value"))
   (param $v i32)

   (if (%is-bytevector-ctx (%get-current-ctx))
       (then
        (if (i32.eqz (%is-small-integer (%get $v)))
            (then
             ;; bytevector type error
             )
          (else
           (%set! $v (%get-small-integer-value (%get $v)))
           (if (i32.gt_u (%get $v) (i32.const 0xff))
               (then
                ;; bytevector type error
                ))))))

   (if (%is-finalized-ctx (%get-current-ctx))
       (then
        ;; more than one value appears after a dot at the end of a list
        ;; missing close paren
        )
     (else
      (if (%is-finalizing-ctx (%get-current-ctx))
          (then
           (%set-finalized-ctx (%get-current-ctx))
           (%set-current-tail (%get $v) (%get-current-tail)))
        (else
         (%set-current-tail ($make-pair (%get $v) (%get-current-tail)))))))

   ;; quote, quasiquote, splice, unquote, and unquote-splicing all
   ;; generate auto-unnest contexts.

   (if (%is-auto-unnest (%get-current-ctx))
       (then
        ($unnest))))

 (func $parse (export "parse")
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-delimiter i32)
   (local $end-match i32)
   (local $rule-id i32)

   (loop $again

     ;; Atmosphere matches whitespace, comments, and directives.

     (%set! $rule-id
            (%set! $end-match ($lex-match-atmosphere (%get $text) (%get $end))))

     (if (i32.ne (%get $end-match) _null)
         (then

          ;; Directives must be followed by a delimiter, or the end of the input.

          (if (i32.eq (%get $rule-id) _lex-rule-directive)
              (then
               (if (i32.lt_u (%get $text) (%get $end))
                   (then
                    (drop ;; rule-id
                     (%set! $end-delimiter
                            ($lex-match-delimiter (%get $end-match) (%get $end))))

                    (if (i32.eq (%get $end-delimiter) _null)
                        (then
                         (%set-parse-location (%get $text))
                         (return _error-delimiter-must-follow-directive)))))

               ;; set parser state for fold-case/no-fold-case

               ($process-directive (%get $text) (%get $match-end))))

          (%set! $text (%get $end-match))
          (br $again)))

     ;; Delimited tokens are strings, vertical bar-delimited identifiers, and
     ;; the open and close paren characters.

     (%set! $rule-id
            (%set! $end-match
                   ($lex-match-delimited-token (%get $text) (%get $end))))

     (if (i32.ne (%get $end-match) _null)
         (then
          ($parse-delimited-token (%get $rule-id) (%get $text) (%get $end-match))

          ;; If the text processed so far makes a complete value, then stop and
          ;; return that to the caller.

          (if (%is-parse-complete)
              (then
               (%set-parse-location (%get $end-match))
               (return (%get-parse-result))))

          (br $again)))

     ;; Undelimited token are everything else that isn't whitespace, a comment,
     ;; or a directive.

     (%set! $rule-id
            (%set! $end-match
                   ($lex-match-undelimited-token (%get $text) (%get $end))))

     (if (i32.ne (%get $end-match) _null)
         (then
          (if (i32.lt_u (%get $end-match) (%get $end))
              (then

               ;; A delimiter must follow an undelimited token, where a
               ;; delimiter is one of whitespace, double quote, vertical bar,
               ;; semicolon, open paren, or close paren.

               (drop ;; rule-id
                (%set! $end-delimiter
                       ($lex-match-delimiter (%get $end-match) (%get $end))))

               (if (i32.eq (%get $end-delimiter) _null)
                   (then
                    (%set-parse-location (%get $text))
                    (return _error-unrecognized-token)))))

          ($parse-undelimited-token (%get $rule-id) (%get $text) (%get $end-match))

          ;; If the text processed so far makes a complete value or
          ;; has resulted in an error, then stop and return that to
          ;; the caller.

          (if (%is-parse-finished)
              (then
               (%set-parse-location (%get $end-match))
               (return (%get-parse-result))))

          (br $again))))

   ;; todo: separate unterminated value (ie. missing closing paren) from
   ;; unrecognized token.

   (%set-parse-location (%get $text))
   (if (i32.eq (%get $text) (%get $end))
       (then
        (%incomplete-input))
     (else
      _error-unrecognized-token)))

 (func $parse-delimited-token (export "parse-delimited-token")
   (param $rule-id i32)
   (param $text i32)
   (param $end i32)

   (if (i32.eq (%get $rule-id) _lex-rule-paren-char)
       (then
        (if (i32.eq ($get-string-addr-char (%get $text))
                    _char-open-paren)
            (then
             ($nest))
          (else
           (if (i32.eq (%get-ctx-stack) _null)
               (then
                (%set-parse-error _error-unmatched-close-parenthesis))
             (else
              ($unnest)))))
        (return)))

   (if (i32.eq (%get $rule-id) _lex-rule-string)
       (then
        ($append-value ($parse-string (%get $text) (%get $end)))
        (return)))

   (if (i32.eq (%get $rule-id) _lex-rule-delimited-token-string)
       (then
        (if (i32.eq ($lex-match-static-string (%get $text)
                                              (%get $end)
                                              _string-begin-vector)
                    (%get $end))
            (then
             ($nest)
             (%set-vector-ctx (%get-current-ctx)))
          (else
           ($nest)
           (%set-bytevector-ctx (%get-current-ctx))))
        (return)))

   (if (i32.eq (%get $rule-id) _lex-rule-vertical-line-quoted-symbol)
       (then
        ($append-value
         ($parse-vertical-line-quoted-symbol (%get $text) (%get $end)))
        (return)))

   (unreachable))

 (func $parse-undelimited-token (export "parse-undelimited-token")
   (param $rule-id i32)
   (param $text i32)
   (param $end i32)

   (if (i32.eq (%get $rule-id) _lex-rule-token-char)
       (then
        ;; $lex-rule-token-char  '`,.
        ($parse-token-char (%get $text) (%get $end))
        (return)))

   (if (i32.eq (%get $rule-id) _lex-rule-ordinary-identifier)
       (then
        ($parse-ordinary-identifier (%get $text) (%get $end-token))
        (return)))

   (if (i32.eq (%get $rule-id) _lex-rule-boolean)
       (then
        ($parse-boolean (%get $text) (%get $end-token))
        (return)))

   (if (i32.eq (%get $rule-id) _lex-rule-character)
       (then
        ($parse-character (%get $text) (%get $end-token))
        (return)))

   (if (i32.eq (%get $rule-id) _lex-rule-num-10)
       (then
        ($parse-num-10 (%get $text) (%get $end-token))
        (return)))

   (if (i32.eq (%get $rule-id) _lex-rule-num-16)
       (then
        ($parse-num-16 (%get $text) (%get $end-token))
        (return)))

   (if (i32.eq (%get $rule-id) _lex-rule-num-2)
       (then
        ($parse-num-2 (%get $text) (%get $end-token))
        (return)))

   (if (i32.eq (%get $rule-id) _lex-rule-num-8)
       (then
        ($parse-num-8 (%get $text) (%get $end-token))
        (return)))

   (if (i32.eq (%get $rule-id) _lex-rule-unquote-splicing)
       (then
        ($parse-unquote-splicing (%get $text) (%get $end))
        (return)))

   (if (i32.eq (%get $rule-id) _lex-rule-peculiar-identifier)
       (then
        ($parse-peculiar-identifier (%get $text) (%get $end-token))
        (return)))

   (unreachable))

 (func $parse-token-char (debug (export "parse-token-char"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $char i32)
   (local $symbol i32)

   (%set! $char ($load-char (%get $text)))

   (if (i32.eq (%get $char) _char-dot)
       (then
        (%set-finalizing-ctx (%get-current-ctx))
        (return)))

   ($nest)

   (if (i32.eq (%get $char) _char-quote)
       (then
        (%set! $symbol (%quote-symbol)))
     (else
      (if (i32.eq (%get $char) _char-backtick)
          (then
           (%set! $symbol (%quasiquote-symbol)))
        (else
         (if (i32.eq (%get $char) _char-comma)
             (then
              (%set! $symbol (%unquote-symbol)))
           (else
            (unreachable)))))))

   ($append-value (%get $symbol))
   (%set-auto-unnest-ctx (%get-current-ctx)))

 (func $parse-unquote-splicing (debug (export "parse-unquote-splicing"))
   (param $text i32)
   (param $end i32)
   (result i32)

   ($nest)
   ($append-value (%symbol-unquote-splicing))
   (%set-auto-unnest-ctx (%get-current-ctx)))

 (func $parse-num-2 (debug (export "parse-num-2"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $rule-id i32)

   (drop ;; rule-id
    (%set! $end ($lex-match-prefix-2 (%get $text) (%get $end))))

   (%set! $rule-id
          (drop ;; end
           ($lex-match-complex-2 (%get $text) (%get $end))))

   ;; $lex-rule-signed-real-2
   ;; $lex-rule-full-complex-2
   ;; $lex-rule-complex-polar-2
   ;; $lex-rule-complex-unit-im-2
   ;; $lex-rule-complex-im-only-2
   ;; $lex-rule-complex-infnan-im-2
   ;; $lex-rule-unit-im
   ;; $lex-rule-infnan
   ;; $lex-rule-infnan-im

   (if (i32.eq (%get $rule-id) _lex-rule-signed-real-2)
       (then
        (return ($parse-signed-real-2 (%get $text) (%get $end)))))

   (if (i32.eq (%get $rule-id) _lex-rule-full-complex-2)
       (then
        (return ($parse-full-complex-2 (%get $text) (%get $end)))))

   )

 (func $parse-signed-real-2 (debug (export "parse-signed-real-2"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $start i32)
   (local $rule-id i32)
   (local $value i32)

   (%set! $start (%get $text))

   (drop ;; rule-id
    (%set! $text ($lex-match-prefix-2 (%get $text) (%get $end))))


   (%set! $rule-id
          (drop ;; end
           ($lex-match-ureal-2 (%get $text) (%get $end))))

   ;; $lex-rule-uinteger-2
   ;; $lex-rule-urational-2

   (%set! $value
          (if (result i32) (i32.eq (%get $rule-id) _lex-rule-uinteger-2)
            (then
             ($parse-uinteger-2 (%get $text) (%get $end)))
            (else
             ($parse-urational-2 (%get $text) (%get $end))))) ;; todo

   (if (i32.ne (%get $start) (%get $text))
       (then
        (%set! $value ($negate-number (%get $value))))) ;; todo

   (%get $value))

 (func $parse-uinteger-2 (debug (export "parse-uinteger-2"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $length i32)
   (%set! $length (i32.sub (%get $end) (%get $text)))

   (if (i32.lt_u (%get $length) (i32.const 29))
       (then
        ;; 1-28 bits will fit in a 29-bit (signed) tagged small integer
        (return ($parse-small-uinteger-2) (%get $text) (%get $end))))

   (if (i32.lt_u (%get $length) (i32.const 64))
       (then
        ;; 29-63 bits will fit in an i64
        (return ($parse-i64-uinteger-2) (%get $text) (%get $end))))

   ;; >= 64 bits
   ($parse-integer-uintger-2 (%get $text) (%get $end)))

 (func $parse-small-uinteger-2 (debug (export "parse-small-uinteger-2"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $value i32)

   (%set! $value (i32.const 0))

   (loop $again
     (if (i32.ne (%get $text) (%get $end))
         (then
          (%set! $char ($load-char (%get $text)))
          (%set! $value (i32.add (i32.shl (%get $value) (i32.const 1))
                                 (i32.eq (%get $char) _char-1)))

          (%incr i32 $text)
          (br $again))))

   ($make-small-integer (%get $value)))

 (func $parse-i64-uinteger-2 (debug (export "parse-i64-uinteger-2"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $value i64)

   (%set! $value (i64.const 0))

   (loop $again
     (if (i32.ne (%get $text) (%get $end))
         (then
          (%set! $char ($load-char (%get $text)))
          (%set! $value (i64.add (i64.shl (%get $value) (i64.const 1))
                                 (i64.extend_i32_u
                                  (i32.eq (%get $char) _char-1))))

          (%incr i32 $text)
          (br $again))))

   ($make-boxed-i64 (%get $value)))

 (func $parse-integer-uintger-2 (debug (export "parse-integer-uinteger-2"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $accum i64)
   (local $bit-length i32)
   (local $value i32)

   (%set! $bit-length (i32.sub (%get $end) (%get $text)))

   ;; normally, we'd have (x + 63) >> 6, but here we need to allow for a sign
   ;; bit as well, so it becomes (x + 64) >> 6 = (x >> 6) + 1.
   (%set! $value ($alloc-integer
                  (i32.add (i32.shr_u (%get $bit-length)
                                      (i32.const 6))
                           (i32.const 1))))

   (%set! $accum (i64.const 0))

   (loop $again
     (if (i32.ne (%get $text) (%get $end))
         (then
          (%set! $char ($load-char (%get $text)))
          (%set! $accum (i64.add (i64.shl (%get $accum) (i64.const 1))
                                 (i64.extend_i32_u
                                  (i32.eq (%get $char) _char-1))))

          (if (i32.eqz (i32.and (%get $bit-length) (0x3f)))
              (then
               ($set-integer-digit-i64 (%get $value)
                                       (i32.shr_u (%get $bit-length) (i32.const 6))
                                       (%get $accum))
               (%set! $accum (i64.const 0))))

          (%incr i32 $text)
          (%decr i32 $bit-length)
          (br $again))))

   (%get $value))

 (func $parse-unit-im (debug (export "parse-unit-im"))
   (param $text i32)
   (param $end i32)
   (result i32)

   ;; explicit-sign
   ;; complex-i
   ))

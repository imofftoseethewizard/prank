(module

 (import "bytevectors" "alloc-bytevector"                  (func $alloc-bytevector                     (param i32)         (result i32)))
 (import "bytevectors" "build-bytevector"                  (func $build-bytevector                     (param i32)         (result i32)))
 (import "bytevectors" "dealloc-bytevector"                (func $dealloc-bytevector                   (param i32)))
 (import "bytevectors" "get-bytevector-i32"                (func $get-bytevector-i32                   (param i32 i32)     (result i32)))
 (import "bytevectors" "set-bytevector-i32"                (func $set-bytevector-i32                   (param i32 i32 i32)))
 (import "chars" "ascii-lower"                             (func $ascii-lower                          (param i32)         (result i32)))
 (import "chars" "calc-char-width"                         (func $calc-char-width                      (param i32)         (result i32)))
 (import "chars" "encode-code-point"                       (func $encode-code-point                    (param i32)         (result i32)))
 (import "lex-r7rs" "lex-match-atmosphere"                 (func $lex-match-atmosphere                 (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-complex-2"                  (func $lex-match-complex-2                  (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-complex-infnan-im-2"        (func $lex-match-complex-infnan-im-2        (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-complex-8"                  (func $lex-match-complex-8                  (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-complex-infnan-im-8"        (func $lex-match-complex-infnan-im-8        (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-complex-10"                 (func $lex-match-complex-10                 (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-complex-infnan-im-10"       (func $lex-match-complex-infnan-im-10       (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-complex-16"                 (func $lex-match-complex-16                 (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-complex-infnan-im-16"       (func $lex-match-complex-infnan-im-16       (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-datum-comment"              (func $lex-match-datum-comment              (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-significand-forms"          (func $lex-match-significand-forms          (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-delimited-token"            (func $lex-match-delimited-token            (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-delimiter"                  (func $lex-match-delimiter                  (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-prefix-2"                   (func $lex-match-prefix-2                   (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-real-2"                     (func $lex-match-real-2                     (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-prefix-8"                   (func $lex-match-prefix-8                   (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-real-8"                     (func $lex-match-real-8                     (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-prefix-10"                  (func $lex-match-prefix-10                  (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-real-10"                    (func $lex-match-real-10                    (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-prefix-16"                  (func $lex-match-prefix-16                  (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-real-16"                    (func $lex-match-real-16                    (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-sign"                       (func $lex-match-sign                       (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-string-element"             (func $lex-match-string-element             (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-symbol-element"             (func $lex-match-symbol-element             (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-uinteger-2"                 (func $lex-match-uinteger-2                 (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-uinteger-8"                 (func $lex-match-uinteger-8                 (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-uinteger-10"                (func $lex-match-uinteger-10                (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-uinteger-16"                (func $lex-match-uinteger-16                (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-undelimited-token"          (func $lex-match-undelimited-token          (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-undelimited-token/ascii-ci" (func $lex-match-undelimited-token/ascii-ci (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-ureal-2"                    (func $lex-match-ureal-2                    (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-ureal-8"                    (func $lex-match-ureal-8                    (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-ureal-10"                   (func $lex-match-ureal-10                   (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-ureal-16"                   (func $lex-match-ureal-16                   (param i32 i32)     (result i32 i32)))
 (import "lists" "dealloc-list"                            (func $dealloc-list                         (param i32)))
 (import "math" "cos"                                      (func $cos                                  (param f64)         (result f64)))
 (import "math" "sin"                                      (func $sin                                  (param f64)         (result f64)))
 (import "numbers" "get-integer-digit-i32"                 (func $get-integer-digit-i32                (param i32 i32)         (result i32)))
 (import "numbers" "is-inexact"                            (func $is-inexact                           (param i32)         (result i32)))
 (import "numbers" "is-negative"                           (func $is-negative                          (param i32)         (result i32)))
 (import "numbers" "alloc-integer"                         (func $alloc-integer                        (param i32)         (result i32)))
 (import "numbers" "coerce-f64"                            (func $coerce-f64                           (param i32)         (result f64)))
 (import "numbers" "dealloc-number"                        (func $dealloc-number                       (param i32)))
 (import "numbers" "make-boxed-f64"                        (func $make-boxed-f64                       (param f64)         (result i32)))
 (import "numbers" "make-boxed-i64"                        (func $make-boxed-i64                       (param i64)         (result i32)))
 (import "numbers" "make-complex"                          (func $make-complex                         (param i32 i32)     (result i32)))
 (import "numbers" "make-rational"                         (func $make-rational                        (param i32 i32)     (result i32)))
 (import "numbers" "make-small-integer"                    (func $make-small-integer                   (param i32)         (result i32)))
 (import "numbers" "multiply-add-integer-i32"              (func $multiply-add-integer-i32             (param i32 i32 i32)))
 (import "numbers" "multiply-integer-digits/dealloc"       (func $multiply-integer-digits/dealloc      (param i32 i32)     (result i32)))
 (import "numbers" "normalize-number"                      (func $normalize-number                     (param i32)         (result i32)))
 (import "numbers" "normalize-rational"                    (func $normalize-rational                   (param i32)         (result i32)))
 (import "numbers" "pow-10-integer"                        (func $pow-10-integer                       (param i32)         (result i32)))
 (import "numbers" "negate-number"                         (func $negate-number                        (param i32)         (result i32)))
 (import "numbers" "set-integer-i64-digit"                 (func $set-integer-i64-digit                (param i32 i32 i64)))
 (import "numbers" "to-inexact"                            (func $to-inexact                           (param i32)         (result i32)))
 (import "pairs" "dealloc-pair"                            (func $dealloc-pair                         (param i32)))
 (import "pairs" "get-car"                                 (func $get-car                              (param i32)         (result i32)))
 (import "pairs" "get-cdr"                                 (func $get-cdr                              (param i32)         (result i32)))
 (import "pairs" "get-cdar"                                (func $get-cdar                             (param i32)         (result i32)))
 (import "pairs" "get-pair-car"                            (func $get-pair-car                         (param i32)         (result i32)))
 (import "pairs" "get-pair-cdr"                            (func $get-pair-cdr                         (param i32)         (result i32)))
 (import "pairs" "make-pair"                               (func $make-pair                            (param i32 i32)     (result i32)))
 (import "pairs" "set-pair-car"                            (func $set-pair-car                         (param i32 i32)))
 (import "pairs" "set-pair-cdr"                            (func $set-pair-cdr                         (param i32 i32)))
 (import "strings" "alloc-string"                          (func $alloc-string                         (param i32 i32)     (result i32)))
 (import "strings" "build-string"                          (func $build-string                         (param i32)         (result i32)))
 (import "strings" "dealloc-string"                        (func $dealloc-string                       (param i32)))
 (import "strings" "get-string-addr"                       (func $get-string-addr                      (param i32)         (result i32)))
 (import "strings" "get-string-char"                       (func $get-string-char                      (param i32)         (result i32)))
 (import "strings" "match-string"                          (func $match-string                         (param i32 i32 i32) (result i32)))
 (import "strings" "match-string/ascii-ci"                 (func $match-string/ascii-ci                (param i32 i32 i32) (result i32)))
 (import "strings" "set-string-bytes"                      (func $set-string-bytes                     (param i32 i32 i32)))
 (import "strings" "slice-string-addr"                     (func $slice-string-addr                    (param i32 i32)     (result i32)))
 (import "strings" "string-foldcase/ascii"                 (func $string-foldcase/ascii                (param i32)))
 (import "symbols" "make-symbol"                           (func $make-symbol                          (param i32)         (result i32)))
 (import "vectors" "build-vector"                          (func $build-vector                         (param i32)         (result i32)))
 (import "vectors" "dealloc-vector"                        (func $dealloc-vector                       (param i32)))
 (import "vectors" "get-vector-element"                    (func $get-vector-element                   (param i32 i32)     (result i32)))
 (import "vectors" "get-vector-length"                     (func $get-vector-length                    (param i32)         (result i32)))

 (import "lex-r7rs" "string-alarm"            (global $string-alarm            (mut i32)))
 (import "lex-r7rs" "string-begin-bytevector" (global $string-begin-bytevector (mut i32)))
 (import "lex-r7rs" "string-begin-vector"     (global $string-begin-vector     (mut i32)))
 (import "lex-r7rs" "string-delete"           (global $string-delete           (mut i32)))
 (import "lex-r7rs" "string-escape"           (global $string-escape           (mut i32)))
 (import "lex-r7rs" "string-exact-prefix"     (global $string-exact-prefix     (mut i32)))
 (import "lex-r7rs" "string-inexact-prefix"   (global $string-inexact-prefix   (mut i32)))

 (string _string-quasiquote-symbol       (export "string-quasiquote-symbol")       "quasiquote")
 (string _string-quote-symbol            (export "string-quote-symbol")            "quote")
 (string _string-unquote-splicing-symbol (export "string-unquote-splicing-symbol") "unquote-splicing")
 (string _string-unquote-symbol          (export "string-unquote-symbol")          "unquote")

 (macro %string-alarm
   (global.get $string-alarm))

 (macro %string-begin-bytevector
   (global.get $string-begin-bytevector))

 (macro %string-begin-vector
   (global.get $string-begin-vector))

 (macro %string-delete
   (global.get $string-delete))

 (macro %string-escape
   (global.get $string-escape))

 (macro %string-exact-prefix
   (global.get $string-exact-prefix))

 (macro %string-inexact-prefix
   (global.get $string-inexact-prefix))

 (include "./constants.wam")
 (include "./globals.wam")
 (include "./ascii.wam")
 (include "./values.wam")
 (include "./boxes.wam")
 (include "./lex-r7rs-rule-ids.wam")
 (include "./string-loader.wam")

 (memory (debug (export "memory")) 1)

 (debug
  (global $debug (export "#debug") (mut i32) (i32.const 0))
  (global $p1 (export "p1") (mut i32) (i32.const 0))
  (global $p2 (export "p2") (mut i32) (i32.const 0))
  (global $p3 (export "p3") (mut i32) (i32.const 0))
  (global $p4 (export "p4") (mut i32) (i32.const 0)))

 (define _powers-of-10-i32     (i32.const 0x100)) ;; reserve space for strings: "quasiquote", etc
 (define _end-powers-of-10-i32 (i32.const 0x128)) ;; 10^9 fits in an i32, so reserve 10 i32s

 ;; todo: belongs elsewhere
 (define _small-integer-1 (i32.const 8))

 ;; todo: belongs elsewhere
 (macro %get-small-integer-value
   (expr ,v)
   (i32.shr_s ,v _tag-size-bits))

 ;; todo: belongs elsewhere
 (macro %is-small-integer
   (expr ,v)
   (i32.eq (%get-value-tag ,v) _tag-small-integer))

 ;; results from parse-exactness-value
 (define _no-exactness (i32.const 0))
 (define _exact        (i32.const 1))
 (define _inexact      (i32.const 2))

 ;; Define the parse context structure
 (define _ctx-flags-offset        (+offset 0 4))
 (define _ctx-ignore-count-offset (+offset))
 (define _ctx-location-offset     (+offset))
 (define _ctx-tail-offset         (+offset))
 (define _ctx-value-offset        (+offset))
 (define _ctx-size                (+offset))

 (debug
  (global $ctx-flags-offset        (export "ctx-flags-offset")        i32 _ctx-flags-offset)
  (global $ctx-ignore-count-offset (export "ctx-ignore-count-offset") i32 _ctx-ignore-count-offset)
  (global $ctx-location-offset     (export "ctx-location-offset")     i32 _ctx-location-offset)
  (global $ctx-tail-offset         (export "ctx-tail-offset")         i32 _ctx-tail-offset)
  (global $ctx-value-offset        (export "ctx-value-offset")        i32 _ctx-value-offset)
  (global $ctx-size                (export "ctx-size")                i32 _ctx-size))

 ;; Flags
 (define _ctx-auto-unnest       (i32.const 0x01))
 (define _ctx-finalized         (i32.const 0x02))
 (define _ctx-finalizing        (i32.const 0x04))
 (define _ctx-type-bytevector   (i32.const 0x08))
 (define _ctx-type-vector       (i32.const 0x10))
 (define _ctx-type-mask         (i32.const 0x18))
 (define _ctx-type-mask-inverse (i32.const 0xffffffe7))

 (debug
  (global $ctx-auto-unnest       (export "ctx-auto-unnest")       i32 _ctx-auto-unnest)
  (global $ctx-finalized         (export "ctx-finalized")         i32 _ctx-finalized)
  (global $ctx-finalizing        (export "ctx-finalizing")        i32 _ctx-finalizing)
  (global $ctx-type-bytevector   (export "ctx-type-bytevector")   i32 _ctx-type-bytevector)
  (global $ctx-type-vector       (export "ctx-type-vector")       i32 _ctx-type-vector)
  (global $ctx-type-mask         (export "ctx-type-mask")         i32 _ctx-type-mask)
  (global $ctx-type-mask-inverse (export "ctx-type-mask-inverse") i32 _ctx-type-mask-inverse))

 ;; used by directives #!fold-case #!no-fold-case

 (global $fold-case (debug (export "fold-case")) (mut i32) (i32.const 0))

 (macro %get-fold-case
   (global.get $fold-case))

 (macro %set-fold-case
   (expr ,v)
   (global.set $fold-case ,v))

 ;; The stack is implemented as a list of bytevectors.
 (global $ctx-stack (debug (export "ctx-stack")) (mut i32) _null)

 (macro %get-ctx-stack
   (global.get $ctx-stack))

 (macro %set-ctx-stack
   (expr ,v)
   (global.set $ctx-stack ,v))

 (macro %push-ctx
   (expr ,v)
   (%set-ctx-stack ($make-pair ,v (global.get $ctx-stack))))

 (macro %get-current-ctx
   ($get-pair-car (%get-ctx-stack)))

 (macro %get-ctx-flags
   (expr ,ctx)
   ($get-bytevector-i32 ,ctx _ctx-flags-offset))

 (macro %get-ctx-ignore-count
   (expr ,ctx)
   ($get-bytevector-i32 ,ctx _ctx-ignore-count-offset))

 (macro %get-ctx-location
   (expr ,ctx)
   ($get-bytevector-i32 ,ctx _ctx-location-offset))

 (macro %get-ctx-tail
   (expr ,ctx)
   ($get-bytevector-i32 ,ctx _ctx-tail-offset))

 (macro %get-ctx-type
   (expr ,ctx)
   (i32.and _ctx-type-mask (%get-ctx-flags ,ctx)))

 (macro %get-ctx-value
   (expr ,ctx)
   ($get-bytevector-i32 ,ctx _ctx-value-offset))

 (macro %set-ctx-flags
   (expr ,ctx)
   (expr ,flags)
   ($set-bytevector-i32 ,ctx _ctx-flags-offset ,flags))

 (macro %set-ctx-ignore-count
   (expr ,ctx)
   (expr ,ignore-count)
   ($set-bytevector-i32 ,ctx _ctx-ignore-count-offset ,ignore-count))

 (macro %set-ctx-location
   (expr ,ctx)
   (expr ,location)
   ($set-bytevector-i32 ,ctx _ctx-location-offset ,location))

 (macro %set-ctx-tail
   (expr ,ctx)
   (expr ,tail)
   ($set-bytevector-i32 ,ctx _ctx-tail-offset ,tail))

 (macro %set-ctx-value
   (expr ,ctx)
   (expr ,value)
   ($set-bytevector-i32 ,ctx _ctx-value-offset ,value))

 (macro %get-current-ctx-flags
   (%get-ctx-flags (%get-current-ctx)))

 (macro %get-current-ctx-value
   (%get-ctx-value (%get-current-ctx)))

 (macro %is-auto-unnest-ctx
   (expr ,ctx)
   (i32.and (%get-ctx-flags ,ctx) _ctx-auto-unnest))

 (macro %is-bytevector-ctx
   (expr ,ctx)
   (i32.and (%get-ctx-flags ,ctx) _ctx-type-bytevector))

 (macro %is-finalized-ctx
   (expr ,ctx)
   (i32.and (%get-ctx-flags ,ctx) _ctx-finalized))

 (macro %is-finalizing-ctx
   (expr ,ctx)
   (i32.and (%get-ctx-flags ,ctx) _ctx-finalizing))

 (macro %is-list-ctx
   (expr ,ctx)
   (i32.eqz (i32.and (%get-ctx-flags ,ctx) _ctx-type-mask)))

 (macro %is-vector-ctx
   (expr ,ctx)
   (i32.eq _ctx-type-vector
           (i32.and (%get-ctx-flags ,ctx) _ctx-type-mask)))

 (macro %set-auto-unnest-ctx
   (label $ctx)
   (%set-ctx-flags $ctx (i32.or (%get-ctx-flags $ctx) _ctx-auto-unnest)))

 (macro %set-bytevector-ctx
   (label $ctx)
   (%set-ctx-flags $ctx (i32.or (i32.and (%get-ctx-flags $ctx) _ctx-type-mask-inverse)
                                _ctx-type-bytevector)))

 (macro %set-finalized-ctx
   (label $ctx)
   (%set-ctx-flags $ctx (i32.or (%get-ctx-flags $ctx) _ctx-finalized)))

 (macro %set-finalizing-ctx
   (label $ctx)
   (%set-ctx-flags $ctx (i32.or (%get-ctx-flags $ctx) _ctx-finalizing)))

 (macro %set-vector-ctx
   (label $ctx)
   (%set-ctx-flags $ctx (i32.or (i32.and (%get-ctx-flags $ctx) _ctx-type-mask-inverse)
                                _ctx-type-vector)))

 (global $parse-error (debug (export "parse-error")) (mut i32) _null)

 (macro %get-parse-error
   (global.get $parse-error))

 (macro %set-parse-error
   (expr ,v)
   (global.set $parse-error ,v))

 (macro %get-parse-result
   (if (result i32) (i32.eq (%get-parse-error) _null)
     (then ($get-cdar (%get-current-ctx-value)))
     (else (%get-parse-error))))

 (macro %is-parse-finished
   (i32.or (i32.ne (%get-parse-error) _null)
           (i32.eq ($get-pair-cdr (%get-ctx-stack)) _null)))

 (global $parse-location (debug (export "parse-location")) (mut i32) _null)

 (func $get-parse-location (export "get-parse-location")
   (result i32)
   (global.get $parse-location))

 (macro %set-parse-location
   (expr ,v)
   (global.set $parse-location ,v))

 (global $quasiquote-symbol       (debug (export "quasiquote-symbol"))       (mut i32) _null)
 (global $quote-symbol            (debug (export "quote-symbol"))            (mut i32) _null)
 (global $unquote-splicing-symbol (debug (export "unquote-splicing-symbol")) (mut i32) _null)
 (global $unquote-symbol          (debug (export "unquote-symbol"))          (mut i32) _null)

 (macro %quasiquote-symbol
   (global.get $quasiquote-symbol))

 (macro %quote-symbol
   (global.get $quote-symbol))

 (macro %unquote-splicing-symbol
   (global.get $unquote-splicing-symbol))

 (macro %unquote-symbol
   (global.get $unquote-symbol))

 (macro %load-symbol
   (expr ,data)
   ($make-symbol ($load-string ,data)))

 (start $init-parse)
 (func $init-parse (debug (export "init-parse"))
   (local $addr i32)
   (local $x i32)

   (global.set $quasiquote-symbol       (%load-symbol _string-quasiquote-symbol))
   (global.set $quote-symbol            (%load-symbol _string-quote-symbol))
   (global.set $unquote-splicing-symbol (%load-symbol _string-unquote-splicing-symbol))
   (global.set $unquote-symbol          (%load-symbol _string-unquote-symbol))

   (set! $x (i32.const 1))
   (set! $addr _powers-of-10-i32)
   (loop $again
     (i32.store $addr $x)
     (set! $x (i32.mul $x (i32.const 10)))
     (%incr-n i32 $addr 4)
     (if (i32.lt_u $addr _end-powers-of-10-i32)
         (br $again)))

   (%set-ctx-stack _null))

 (func $make-parse-context (debug (export "make-parse-context"))
   (param $text i32)
   (result i32)

   (local $ctx i32)
   (local $value i32)

   (set! $ctx ($alloc-bytevector _ctx-size))

   (%set-ctx-flags $ctx (i32.const 0))
   (%set-ctx-ignore-count $ctx (i32.const 0))
   (%set-ctx-location $ctx $text)

   (set! $value ($make-pair _null _null))
   (%set-ctx-value $ctx $value)
   (%set-ctx-tail $ctx $value)

   $ctx)

 (func $dealloc-parse-context (debug (export "dealloc-parse-context"))
   (param $ctx i32)
   ($dealloc-pair (%get-ctx-value $ctx))
   ($dealloc-bytevector $ctx))

 (func $nest (debug (export "nest"))
   (param $text i32)
   (%push-ctx ($make-parse-context $text)))

 (func $unnest (debug (export "unnest"))

   (local $ctx i32)
   (local $head i32)
   (local $value i32)

   (set! $head (%get-ctx-stack))

   (if (i32.eq ($get-pair-cdr $head) _null)
       (then
        (%set-parse-error _error-unmatched-close-parenthesis)
        (return)))

   (set! $ctx ($get-pair-car $head))

   (if (%get-ctx-ignore-count $ctx)
       (then
        (%set-parse-error _error-datum-expected)
        (return)))

   (%set-ctx-stack ($get-pair-cdr $head))

   ($dealloc-pair $head)
   (set! $value ($get-pair-cdr (%get-ctx-value $ctx)))

   ($append-value (if (result i32) (%is-list-ctx $ctx)
                       (then $value)
                       (else
                        (if (result i32) (%is-vector-ctx $ctx)
                          (then ($build-vector $value))
                          (else ($build-bytevector $value)))
                        ($dealloc-list $value))))

   ($dealloc-parse-context $ctx))

 (func $append-value (debug (export "append-value"))
   (param $v i32)

   (local $ctx i32)
   (local $ignore-count i32)
   (local $new-tail i32)

   (set! $ctx (%get-current-ctx))
   (set! $ignore-count (%get-ctx-ignore-count $ctx))

   (if $ignore-count
       (then
        ($dealloc-value $v)
        (%set-ctx-ignore-count $ctx (i32.sub $ignore-count (i32.const 1)))
        (return)))

   (if (%is-bytevector-ctx $ctx)
       (then
        (if (i32.eqz (%is-small-integer $v))
            (then
             (%set-parse-error _error-illegal-bytevector-element)
             (%set-parse-location (%get-ctx-location (%get-current-ctx))))
          (else
           (set! $v (%get-small-integer-value $v))
           (if (i32.gt_u $v (i32.const 0xff))
               (then
                (%set-parse-error _error-illegal-bytevector-element)
                (%set-parse-location (%get-ctx-location (%get-current-ctx)))))))))

   (if (%is-finalized-ctx $ctx)
       (then
        (%set-parse-error _error-close-parenthesis-expected))
     (else
      (if (%is-finalizing-ctx $ctx)
          (then
           (%set-finalized-ctx $ctx)
           ($set-pair-cdr (%get-ctx-tail $ctx) $v))
        (else
         (set! $new-tail ($make-pair $v _null))
         ($set-pair-cdr (%get-ctx-tail $ctx) (%make-value _tag-pair $new-tail))
         (%set-ctx-tail $ctx $new-tail)))))

   ;; datum comment, quote, quasiquote, splice, unquote, and
   ;; unquote-splicing all generate auto-unnest contexts.

   (if (%is-auto-unnest-ctx $ctx)
       (then
        ($unnest))))

 (func $unwind-parse-stack (debug (export "unwind-parse-stack"))
   (loop $again
     (if (i32.ne ($get-pair-cdr (%get-ctx-stack)) _null)
         (then
          ($unnest)
          (br $again)))))

 ;; todo: this belongs elsewhere
 (func $dealloc-value (export "dealloc-value")
   (param $value i32)

   (local $idx i32)
   (local $tag i32)
   (local $type i32)

   (set! $tag (%get-value-tag $value))

   (if (i32.eq $tag _tag-pair)
       (then
        ($dealloc-value ($get-car $value))
        ($dealloc-value ($get-cdr $value))
        ($dealloc-pair $value)
        (return)))

   (if (i32.eq $tag _tag-box)
       (then
        (set! $type (%get-box-type $value))

        (if (i32.eq $tag _type-bytevector)
            (then
             ($dealloc-bytevector $value)
             (return)))

        (if (i32.eq $tag _type-number)
            (then
             ($dealloc-number $value)
             (return)))

        (if (i32.eq $tag _type-string)
            (then
             ($dealloc-string $value)
             (return)))

        (if (i32.eq $tag _type-vector)
            (then
             (set! $idx ($get-vector-length $value))
             (loop $again
               (if $idx
                   (then
                    (%decr i32 $idx)
                    ($dealloc-value ($get-vector-element $value $idx))
                    (br $again))))
             ($dealloc-vector $value)
             (return))))))

 (func $init-parser (debug (export "init-parser"))

   (local $ctx i32)
   (local $value i32)

   (if (i32.eq (%get-ctx-stack) _null)
       (then ($nest _null)))

   (if (i32.ne (%get-parse-error) _null)
       (then
        ($unwind-parse-stack)
        ($dealloc-value (%get-current-ctx-value))

        (%set-parse-error _null)))

   (set! $ctx (%get-current-ctx))
   (set! $value (%get-ctx-value $ctx))

   ($set-pair-car $value _null)
   ($set-pair-cdr $value _null)

   (%set-ctx-tail $ctx $value)
   (%set-ctx-flags $ctx (i32.const 0)))

 (func $parse (export "parse")
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-delimiter i32)
   (local $end-match i32)
   (local $rule-id i32)

   ;; (global.set $p1 $text)

   ($init-parser)

   (loop $again
     (%set-parse-location $text)
     (%set-ctx-location (%get-current-ctx) $text)

     ;; Atmosphere matches whitespace, comments, and directives.

     (set! $rule-id
           (set! $end-match ($lex-match-atmosphere $text $end)))

     (if (i32.ne $end-match _null)
         (then

          ;; Directives must be followed by a delimiter, or the end of the input.

          (if (i32.eq $rule-id _lex-rule-directive)
              (then
               (if (i32.lt_u $text $end)
                   (then
                    (drop ;; rule-id
                     (set! $end-delimiter ($lex-match-delimiter $end-match $end)))

                    (if (i32.eq $end-delimiter _null)
                        (then
                         (return _error-delimiter-must-follow-directive)))))

               ;; set parser state for fold-case/no-fold-case

               ($process-directive $text $end-match)))

          (set! $text $end-match)
          (br $again)))

     ;; Delimited tokens are strings, vertical bar-delimited identifiers, a
     ;; small set of individual characters -- tick, backtick, comma and the open
     ;; and close paren characters -- and short tokens -- begin vector, begin
     ;; bytevector, and unquote-splicing.

     (set! $rule-id
           (set! $end-match
                 ($lex-match-delimited-token $text $end)))

     (if (i32.ne $end-match _null)
         (then
          ($parse-delimited-token $rule-id $text $end-match)

          ;; If the text processed so far makes a complete value, then stop and
          ;; return that to the caller.

          (if (%is-parse-finished)
              (then
               (if (i32.eq (%get-parse-error) _null)
                   (then
                    (%set-parse-location $end-match)))
               (return (%get-parse-result))))

          (set! $text $end-match)
          (br $again)))

     ;; An undelimited token is anything else that isn't whitespace, a comment,
     ;; or a directive.  If the parser is in the case-folding state, then
     ;; booleans and character names may are parsed case-insensitively.

     (set! $rule-id
           (set! $end-match
                 (if (result i32 i32) (%get-fold-case)
                   (then ($lex-match-undelimited-token/ascii-ci $text $end))
                   (else ($lex-match-undelimited-token $text $end)))))

     (if (i32.ne $end-match _null)
         (then
          (if (i32.lt_u $end-match $end)
              (then

               ;; A delimiter must follow an undelimited token, where a
               ;; delimiter is one of whitespace, double quote, vertical bar,
               ;; semicolon, open paren, or close paren.

               (drop ;; rule-id
                (set! $end-delimiter ($lex-match-delimiter $end-match $end)))

               (if (i32.eq $end-delimiter _null)
                   (then
                    (return _error-unrecognized-token)))))

          ($parse-undelimited-token $rule-id $text $end-match)

          ;; If the text processed so far makes a complete value or
          ;; has resulted in an error, then stop and return that to
          ;; the caller.

          (if (%is-parse-finished)
              (then
               (if (i32.eq (%get-parse-error) _null)
                   (then
                    (%set-parse-location $end-match)))
               (return (%get-parse-result))))

          (set! $text $end-match)
          (br $again)))

     ;; Datum comments are similar to quotes. Where ' indicates that
     ;; the following datum should be appended to the parsed value in
     ;; a list beginning with the symbol "quote", datum comments
     ;; indicate that the following datum should be dropped and not
     ;; added to the parsed value.

     (set! $rule-id
           (set! $end-match
                 ($lex-match-datum-comment $text $end)))

     (if (i32.ne $end-match _null)
         (then
          ($parse-datum-comment $rule-id $text $end-match)

          ;; If the text processed so far makes a complete value, then stop and
          ;; return that to the caller.

          (if (%is-parse-finished)
              (then
               (if (i32.eq (%get-parse-error) _null)
                   (then
                    (%set-parse-location $end-match)))
               (return (%get-parse-result))))

          (set! $text $end-match)
          (br $again))))

   (if (result i32) (i32.eq $text $end)
     (then _error-incomplete-input)
     (else _error-unrecognized-token)))

 (func $process-directive (debug (export "process-directive"))
   (param $text i32)
   (param $end i32)
   (%set-fold-case (i32.eq ($get-string-char (i32.add $text (i32.const 2))) _char-f)))

 (func $parse-delimited-token (export "parse-delimited-token")
   (param $rule-id i32)
   (param $text i32)
   (param $end i32)

   (if (i32.eq $rule-id _lex-rule-token-char)
       (then
        ;; $lex-rule-token-char  ()'`,
        ($parse-token-char $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-quoted-string)
       (then
        ($parse-string $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-delimited-token-string)
       (then
        (if (i32.eq ($match-string (%string-begin-vector) $text $end)
                    $end)
            (then
             ($nest $text)
             (%set-vector-ctx (%get-current-ctx)))
          (else
           (if (i32.eq ($match-string (%string-begin-bytevector) $text $end)
                       $end)
               (then
                ($nest $text)
                (%set-bytevector-ctx (%get-current-ctx)))
             (else
              ($parse-unquote-splicing $text $end)))))
        (return)))

   (if (i32.eq $rule-id _lex-rule-vertical-line-quoted-symbol)
       (then
        ($parse-vertical-line-quoted-symbol $text $end)
        (return)))

   (unreachable))

 (func $parse-undelimited-token (export "parse-undelimited-token")
   (param $rule-id i32)
   (param $text i32)
   (param $end i32)

   (if (i32.or (i32.eq $rule-id _lex-rule-ordinary-identifier)
               (i32.eq $rule-id _lex-rule-peculiar-identifier))
       (then
        ($parse-identifier $text $end)
        (return)))

   (if (i32.or (i32.eq $rule-id _lex-rule-boolean)
               (i32.eq $rule-id _lex-rule-boolean/ascii-ci))
       (then
        ($parse-boolean $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-dot)
       (then
        ($parse-dot $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-escaped-character)
       (then
        ($parse-escaped-character $text $end)
        (return)))

   (if (i32.or (i32.eq $rule-id _lex-rule-named-character)
               (i32.eq $rule-id _lex-rule-named-character/ascii-ci))
       (then
        ($parse-named-character $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-escaped-character-hex)
       (then
        ($parse-escaped-character-hex $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-num-10)
       (then
        ($parse-num-10 $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-num-16)
       (then
        ($parse-num-16 $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-num-2)
       (then
        ($parse-num-2 $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-num-8)
       (then
        ($parse-num-8 $text $end)
        (return)))

   (unreachable))

 (func $parse-unquote-splicing (debug (export "parse-unquote-splicing"))
   (param $text i32)
   (param $end i32)

   ($nest $text)
   ($append-value (%unquote-splicing-symbol))
   (%set-auto-unnest-ctx (%get-current-ctx)))

 (func $parse-token-char (debug (export "parse-token-char"))
   (param $text i32)
   (param $end i32)

   (local $char i32)
   (local $symbol i32)

   (set! $char ($get-string-char $text))

   (if (i32.eq $char _char-dot)
       (then
        (%set-finalizing-ctx (%get-current-ctx))
        (return)))

   (if (i32.eq $char _char-open-paren)
       (then
        ($nest $text)
        (return)))

   (if (i32.eq $char _char-close-paren)
       (then
        ($unnest)
        (return)))

   ($nest $text)

   (if (i32.eq $char _char-quote)
       (then
        (set! $symbol (%quote-symbol)))
     (else
      (if (i32.eq $char _char-backtick)
          (then
           (set! $symbol (%quasiquote-symbol)))
        (else
         (if (i32.eq $char _char-comma)
             (then
              (set! $symbol (%unquote-symbol)))
           (else
            (unreachable)))))))

   ($append-value $symbol)
   (%set-auto-unnest-ctx (%get-current-ctx)))

 (func $parse-datum-comment (debug (export "parse-datum-comment"))
   (param $text i32)
   (param $end i32)

   (local $ctx i32)

   (set! $ctx (%get-current-ctx))
   (%set-ctx-ignore-count $ctx (i32.add (%get-ctx-ignore-count $ctx) (i32.const 1))))

 (func $parse-identifier (debug (export "parse-identifier"))
   (param $text i32)
   (param $end i32)

   (local $s i32)

   (set! $s ($slice-string-addr $text $end))

   (if (%get-fold-case)
       (then ($string-foldcase/ascii $s))) ;; todo unicode

   ($append-value ($make-symbol $s)))

 (func $parse-boolean (debug (export "parse-boolean"))
   (param $text i32)
   (param $end i32)

   (local $char i32)

   (set! $char ($get-string-char (i32.add $text (i32.const 1))))

   ($append-value (if (result i32) (i32.or (i32.eq $char _char-T) (i32.eq $char _char-t))
                    (then _true)
                    (else _false))))

 (func $parse-dot (debug (export "parse-dot"))
   (param $text i32)
   (param $end i32)

   (local $ctx i32)

   (set! $ctx (%get-current-ctx))

   (if (i32.or (%is-finalized-ctx $ctx) (%is-finalizing-ctx $ctx))
       (then
        (%set-parse-error _error-close-parenthesis-expected))
     (else
      (if (i32.or (%is-bytevector-ctx $ctx) (%is-vector-ctx $ctx))
          (then
           (%set-parse-error _error-illegal-use-of-dot))
        (else
         (%set-finalizing-ctx $ctx))))))

 (func $parse-escaped-character (debug (export "parse-escaped-character"))
   (param $text i32)
   (param $end i32)

   ($append-value (%make-value _tag-char
                               (i32.shl ($get-string-char (i32.add $text (i32.const 2)))
                                        _tag-size-bits))))

 (func $parse-named-character (debug (export "parse-named-character"))
   (param $text i32)
   (param $end i32)

   (local $char i32)
   (local $length i32)

   (set! $text (i32.add $text (i32.const 2)))
   (set! $length (i32.sub $end $text))

   (set! $char
         (if (result i32) (i32.eq $length (i32.const 5))
           (then
            (if (result i32) (i32.eq ($match-string/ascii-ci (%string-alarm) $text $end) $end)
              (then _char-bell)
              (else _char-space)))
           (else
            (if (result i32) (i32.eq $length (i32.const 6))
              (then
               (if (result i32) (i32.eq ($match-string/ascii-ci (%string-delete) $text $end) $end)
                 (then _char-delete)
                 (else
                  (if (result i32) (i32.eq ($match-string/ascii-ci (%string-escape) $text $end) $end)
                    (then _char-escape)
                    (else _char-carriage-return))))) ;; return
              (else
               (if (result i32) (i32.eq $length (i32.const 3)) ;; tab
                 (then _char-tab)
                 (else
                  (if (result i32) (i32.eq $length (i32.const 4)) ;; null
                    (then _char-null)
                    (else
                     (if (result i32) (i32.eq $length (i32.const 7)) ;; newline
                       (then _char-line-feed)
                       (else
                        (debug
                         (if (result i32) (i32.eq $length (i32.const 9)) ;; backspace
                           (then _char-backspace)
                           (else (unreachable) _null))))))))))))))

   ($append-value (%make-value _tag-char (i32.shl $char _tag-size-bits))))

 (func $parse-escaped-character-hex (debug (export "parse-escaped-character-hex"))
   (param $text i32)
   (param $end i32)

   ;; add 1 to skip over the #
   ($append-value (%make-value _tag-char
                               (i32.shl ($parse-hex-escape (i32.add $text (i32.const 1)) $end)
                                        _tag-size-bits))))

 (func $parse-vertical-line-quoted-symbol (debug (export "parse-vertical-line-quoted-symbol"))
   (param $text i32)
   (param $end i32)

   (local $char i32)
   (local $char-list i32)
   (local $end-match i32)
   (local $next i32)
   (local $rule-id i32)
   (local $tail i32)

   (set! $char-list ($make-pair _null _null))
   (set! $tail $char-list)

   ;; account for vertical line delimiters
   (set! $text (i32.add $text (i32.const 1)))
   (set! $end (i32.sub $end (i32.const 1)))

   (loop $again

     (if (i32.lt_u $text $end)
         (then

          (set! $rule-id
                (set! $end-match ($lex-match-symbol-element $text $end)))

          (set! $char
                (if (result i32) (i32.eq $rule-id _lex-rule-symbol-element/character)
                  (then
                   ($get-string-char $text))
                  (else
                   (if (result i32) (i32.eq $rule-id _lex-rule-escaped-vertical-line)
                     (then
                      ;; add 1 to skip over backslash
                      ($get-string-char (i32.add $text (i32.const 1))))
                     (else
                      (if (result i32) (i32.eq $rule-id _lex-rule-mnemonic-escape)
                        (then
                         ;; add 1 to skip over backslash
                         ($parse-mnemonic-char (i32.add $text (i32.const 1))))
                        (else
                         (debug
                          (if (i32.ne $rule-id _lex-rule-inline-hex-escape)
                              (then
                               (unreachable))))

                         ($encode-code-point ($parse-hex-escape $text $end-match)))))))))

          (set! $next ($make-pair $char _null))
          ($set-pair-cdr $tail $next)
          (set! $tail $next)

          (set! $text $end-match)
          (br $again))))

   ($append-value ($make-symbol ($build-string ($get-pair-cdr $char-list))))
   ($dealloc-list $char-list))

 (func $parse-string (debug (export "parse-string"))
   (param $text i32)
   (param $end i32)

   (local $char i32)
   (local $char-list i32)
   (local $end-match i32)
   (local $next i32)
   (local $rule-id i32)
   (local $tail i32)

   (set! $char-list ($make-pair _null _null))
   (set! $tail $char-list)

   ;; initial double quote
   (set! $text (i32.add $text (i32.const 1)))

   ;; final double quote
   (set! $end (i32.sub $end (i32.const 1)))

   (loop $again

     (if (i32.lt_u $text $end)
         (then

          (set! $rule-id
                (set! $end-match ($lex-match-string-element $text $end)))

          (if (i32.ne $rule-id _lex-rule-escaped-line-ending)
              (then
               (set! $char
                     (if (result i32) (i32.eq $rule-id _lex-rule-string-element/character)
                       (then
                        ($get-string-char $text))
                       (else
                        (if (result i32) (i32.or (i32.eq $rule-id _lex-rule-escaped-double-quote)
                                                 (i32.eq $rule-id _lex-rule-escaped-backslash))
                          (then
                           ;; add 1 to skip over backslash
                           ($get-string-char (i32.add $text (i32.const 1))))
                          (else
                           (if (result i32) (i32.eq $rule-id _lex-rule-mnemonic-escape)
                             (then
                              ;; add 1 to skip over backslash
                              ($parse-mnemonic-char (i32.add $text (i32.const 1))))
                             (else
                              (debug
                               (if (i32.ne $rule-id _lex-rule-inline-hex-escape)
                                   (then
                                    (unreachable))))

                              ($encode-code-point ($parse-hex-escape $text $end-match)))))))))

               (set! $next ($make-pair $char _null))
               ($set-pair-cdr $tail $next)
               (set! $tail $next)))

          (set! $text $end-match)
          (br $again))))

   ($append-value ($build-string ($get-pair-cdr $char-list)))
   ($dealloc-list $char-list))

 (func $parse-mnemonic-char (debug (export "parse-mnemonic-char"))
   (param $text i32)
   (result i32)

   (local $char i32)

   (set! $char ($get-string-char $text))

   (if (result i32) (i32.eq $char _char-a)
     (then _char-bell)
     (else
      (if (result i32) (i32.eq $char _char-b)
        (then _char-backspace)
        (else
         (if (result i32) (i32.eq $char _char-t)
           (then _char-tab)
           (else
            (if (result i32) (i32.eq $char _char-n)
              (then _char-line-feed)
              (else
               (if (result i32) (i32.eq $char _char-r)
                 (then _char-carriage-return)
                 (else (unreachable) _null)))))))))))

 (func $parse-hex-escape (debug (export "parse-hex-escape"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $code-point i32)
   (local $start i32)

   (set! $start $text)

   ;; move text forward 2 to skip over \x
   (set! $text (i32.add $text (i32.const 2)))

   ;; move end back 1 to account for final semicolon
   (set! $end (i32.sub $end (i32.const 1)))

   (set! $code-point (i32.const 0))
   (loop $again

     (if (i32.and $code-point (i32.const 0xf0000000))
         (then
          (%set-parse-error _error-inline-hex-overflow)
          (%set-parse-location $start)
          (return _char-null)))

     (set! $code-point (i32.or (i32.shl $code-point (i32.const 4))
                               ($hex-digit-value ($get-string-char $text))))

     (set! $text (i32.add $text (i32.const 1)))

     (if (i32.lt_u $text $end)
         (then
          (br $again))))

   (if (i32.eq ($calc-char-width $code-point) (i32.const -1))
       (then
        (%set-parse-error _error-invalid-code-point)
        (%set-parse-location $start)
        (return _char-null)))

   $code-point)

 (func $parse-num-2 (debug (export "parse-num-2"))
   (param $text i32)
   (param $end i32)

   (local $number-start i32)
   (local $rule-id i32)
   (local $value i32)

   (drop ;; rule-id
    (set! $number-start ($lex-match-prefix-2 $text $end)))

   (set! $value ($parse-num-2-value $number-start $end))

   ($append-value (if (result i32) (i32.ne ($parse-exactness-value $text $number-start)
                                           _inexact)
                    (then ($normalize-number $value))
                    (else ($to-inexact $value)))))

 (func $parse-num-2-value (debug (export "parse-num-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $rule-id i32)

   (set! $rule-id
         (drop ;; end
          ($lex-match-complex-2 $text $end)))

   (if (i32.eq $rule-id _lex-rule-signed-real-2)
       (then
        (return ($parse-signed-real-2-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-full-complex-2)
       (then
        (return ($parse-full-complex-2-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-polar-2)
       (then
        (return ($parse-complex-polar-2-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-unit-im-2)
       (then
        (return ($parse-complex-unit-im-2-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-im-only-2)
       (then
        (return ($parse-complex-im-only-2-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-infnan-im-2)
       (then
        (return ($parse-complex-infnan-im-2-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-unit-im)
       (then
        (return ($parse-unit-im-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-infnan)
       (then
        (return ($parse-infnan-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-infnan-im)
       (then
        (return ($parse-infnan-im-value $text $end))))

   (unreachable))

 (func $parse-full-complex-2-value (debug (export "parse-full-complex-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)
   (local $im i32)
   (local $is-negative-im i32)
   (local $re i32)
   (local $rule-id i32)

   (set! $rule-id
         (set! $end-match
               ($lex-match-real-2 $text $end)))

   (set! $re
         (if (result i32) (i32.eq $rule-id _lex-rule-infnan)
           (then ($parse-infnan-value $text $end-match))
           (else ($parse-real-2-value $text $end-match))))

   (set! $is-negative-im (i32.eq ($get-string-char $end-match) _char-minus))

   (set! $text (i32.add $end-match (i32.const 1)))

   (set! $rule-id
         (set! $end-match
               ($lex-match-ureal-2 $text $end)))

   (set! $im
         (if (result i32) (i32.eq $rule-id _lex-rule-uinteger-2)
           (then ($parse-uinteger-2-value $text $end-match))
           (else ($parse-urational-2-value $text $end-match))))

   (if $is-negative-im
       (then
        (set! $im ($negate-number $im))))

   ($make-complex $re $im))

 (func $parse-complex-polar-2-value (debug (export "parse-complex-polar-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $magnitude f64)
   (local $end-match i32)
   (local $arg f64)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-2 $text $end)))

   (set! $magnitude ($coerce-f64 ($parse-real-2-value $text $end-match)))

   (set! $arg ($coerce-f64 ($parse-real-2-value (i32.add $end-match (i32.const 1)) $end)))

   (set! $re ($make-boxed-f64 (f64.mul $magnitude ($cos $arg))))

   ($make-complex
    $re
    ($make-boxed-f64 (f64.mul $magnitude ($sin $arg)))))

 (func $parse-complex-unit-im-2-value (debug (export "parse-complex-unit-im-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-2 $text $end)))

   (set! $re ($parse-real-2-value $text $end-match))

   ($make-complex $re
                  ($make-small-integer
                   (if (result i32) (i32.eq ($get-string-char $end-match) _char-plus)
                     (then (i32.const 1))
                     (else (i32.const -1))))))

 (func $parse-complex-im-only-2-value (debug (export "parse-complex-im-only-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   ($make-complex ($make-small-integer (i32.const 0))
                  ($parse-signed-real-2-value $text
                                              (i32.sub $end (i32.const 1)))))

 (func $parse-complex-infnan-im-2-value (debug (export "parse-complex-infnan-im-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-2 $text $end)))

   (set! $re ($parse-real-2-value $text $end-match))

   ($make-complex $re ($parse-infnan-value $end-match $end)))

 (func $parse-real-2-value (debug (export "parse-real-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $rule-id i32)

   (set! $rule-id
         (drop ;; end
          ($lex-match-real-2 $text $end)))

   (if (result i32) (i32.eq $rule-id _lex-rule-signed-real-2)
     (then
      ($parse-signed-real-2-value $text $end))
     (else
      ($parse-infnan-value $text $end))))

 (func $parse-signed-real-2-value (debug (export "parse-signed-real-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $start i32)
   (local $rule-id i32)
   (local $value i32)

   (set! $start $text)

   (drop ;; rule-id
    (set! $text ($lex-match-sign $text $end)))

   (set! $rule-id
         (drop ;; end
          ($lex-match-ureal-2 $text $end)))

   (set! $value
         (if (result i32) (i32.eq $rule-id _lex-rule-uinteger-2)
           (then
            ($parse-uinteger-2-value $text $end))
           (else
            ($parse-urational-2-value $text $end))))

   (if (i32.eq ($get-string-char $start) _char-minus)
       (then
        (set! $value ($negate-number $value))))

   $value)

 (func $parse-urational-2-value (debug (export "parse-urational-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)

   (drop ;; rule-id
    (set! $end-match
          ($lex-match-uinteger-2 $text $end)))

   ($make-rational ($parse-uinteger-2-value $text $end-match)
                   ($parse-uinteger-2-value (i32.add $end-match (i32.const 1)) $end)))

 (func $parse-uinteger-2-value (debug (export "parse-uinteger-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $length i32)
   (set! $length (i32.sub $end $text))

   (if (i32.lt_u $length (i32.const 29))
       (then
        ;; 1-28 bits will fit in a 29-bit (signed) tagged small integer
        (return ($parse-small-uinteger-2-value $text $end))))

   (if (i32.lt_u $length (i32.const 64))
       (then
        ;; 29-63 bits will fit in an i64
        (return ($parse-i64-uinteger-2-value $text $end))))

   ;; >= 64 bits
   ($parse-integer-uinteger-2-value $text $end))

 (func $parse-small-uinteger-2-value (debug (export "parse-small-uinteger-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $char i32)
   (local $value i32)

   (set! $value (i32.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $value (i32.add (i32.shl $value (i32.const 1)) (i32.eq $char _char-1)))

          (%incr i32 $text)
          (br $again))))

   ($make-small-integer $value))

 (func $parse-i64-uinteger-2-value (debug (export "parse-i64-uinteger-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $char i32)
   (local $value i64)

   (set! $value (i64.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $value (i64.add (i64.shl $value (i64.const 1))
                                (i64.extend_i32_u (i32.eq $char _char-1))))

          (%incr i32 $text)
          (br $again))))

   ($make-boxed-i64 $value))

 (func $parse-integer-uinteger-2-value (debug (export "parse-integer-uinteger-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $accum i64)
   (local $bit-length i32)
   (local $char i32)
   (local $value i32)

   (set! $bit-length (i32.sub $end $text))

   (set! $value ($alloc-integer (i32.shr_u (i32.add $bit-length (i32.const 0x3f))
                                           (i32.const 6))))

   (set! $accum (i64.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $accum (i64.add (i64.shl $accum (i64.const 1))
                                (i64.extend_i32_u (i32.eq $char _char-1))))

          (%decr i32 $bit-length)

          (if (i32.eqz (i32.and $bit-length (i32.const 0x3f)))
              (then
               ($set-integer-i64-digit $value (i32.shr_u $bit-length (i32.const 6)) $accum)
               (set! $accum (i64.const 0))))

          (%incr i32 $text)
          (br $again))))

   $value)

 (func $parse-num-8 (debug (export "parse-num-8"))
   (param $text i32)
   (param $end i32)

   (local $number-start i32)
   (local $rule-id i32)
   (local $value i32)

   (drop ;; rule-id
    (set! $number-start ($lex-match-prefix-8 $text $end)))

   (set! $value ($parse-num-8-value $number-start $end))

   ($append-value (if (result i32) (i32.ne ($parse-exactness-value $text $number-start)
                                           _inexact)
                    (then ($normalize-number $value))
                    (else ($to-inexact $value)))))

 (func $parse-num-8-value (debug (export "parse-num-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $rule-id i32)

   (set! $rule-id
         (drop ;; end
          ($lex-match-complex-8 $text $end)))

   (if (i32.eq $rule-id _lex-rule-signed-real-8)
       (then
        (return ($parse-signed-real-8-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-full-complex-8)
       (then
        (return ($parse-full-complex-8-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-polar-8)
       (then
        (return ($parse-complex-polar-8-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-unit-im-8)
       (then
        (return ($parse-complex-unit-im-8-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-im-only-8)
       (then
        (return ($parse-complex-im-only-8-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-infnan-im-8)
       (then
        (return ($parse-complex-infnan-im-8-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-unit-im)
       (then
        (return ($parse-unit-im-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-infnan)
       (then
        (return ($parse-infnan-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-infnan-im)
       (then
        (return ($parse-infnan-im-value $text $end))))

   (unreachable))

 (func $parse-full-complex-8-value (debug (export "parse-full-complex-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)
   (local $im i32)
   (local $is-negative-im i32)
   (local $re i32)
   (local $rule-id i32)

   (set! $rule-id
         (set! $end-match
               ($lex-match-real-8 $text $end)))

   (set! $re
         (if (result i32) (i32.eq $rule-id _lex-rule-infnan)
           (then ($parse-infnan-value $text $end-match))
           (else ($parse-real-8-value $text $end-match))))

   (set! $is-negative-im (i32.eq ($get-string-char $end-match) _char-minus))

   (set! $text (i32.add $end-match (i32.const 1)))

   (set! $rule-id
         (set! $end-match
               ($lex-match-ureal-8 $text $end)))

   (set! $im
         (if (result i32) (i32.eq $rule-id _lex-rule-uinteger-8)
           (then ($parse-uinteger-8-value $text $end-match))
           (else ($parse-urational-8-value $text $end-match))))

   (if $is-negative-im
       (then
        (set! $im ($negate-number $im))))

   ($make-complex $re $im))

 (func $parse-complex-polar-8-value (debug (export "parse-complex-polar-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $magnitude f64)
   (local $end-match i32)
   (local $arg f64)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-8 $text $end)))

   (set! $magnitude ($coerce-f64 ($parse-real-8-value $text $end-match)))

   (set! $arg ($coerce-f64 ($parse-real-8-value (i32.add $end-match (i32.const 1)) $end)))

   (set! $re ($make-boxed-f64 (f64.mul $magnitude ($cos $arg))))

   ($make-complex
    $re
    ($make-boxed-f64 (f64.mul $magnitude ($sin $arg)))))

 (func $parse-complex-unit-im-8-value (debug (export "parse-complex-unit-im-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-8 $text $end)))

   (set! $re ($parse-real-8-value $text $end-match))

   ($make-complex $re
                  ($make-small-integer
                   (if (result i32) (i32.eq ($get-string-char $end-match) _char-plus)
                     (then (i32.const 1))
                     (else (i32.const -1))))))

 (func $parse-complex-im-only-8-value (debug (export "parse-complex-im-only-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   ($make-complex ($make-small-integer (i32.const 0))
                  ($parse-signed-real-8-value $text
                                              (i32.sub $end (i32.const 1)))))

 (func $parse-complex-infnan-im-8-value (debug (export "parse-complex-infnan-im-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-8 $text $end)))

   (set! $re ($parse-real-8-value $text $end-match))

   ($make-complex $re ($parse-infnan-value $end-match $end)))

 (func $parse-real-8-value (debug (export "parse-real-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $rule-id i32)

   (set! $rule-id
         (drop ;; end
          ($lex-match-real-8 $text $end)))

   (if (result i32) (i32.eq $rule-id _lex-rule-signed-real-8)
     (then
      ($parse-signed-real-8-value $text $end))
     (else
      ($parse-infnan-value $text $end))))

 (func $parse-signed-real-8-value (debug (export "parse-signed-real-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $start i32)
   (local $rule-id i32)
   (local $value i32)

   (set! $start $text)

   (drop ;; rule-id
    (set! $text ($lex-match-sign $text $end)))

   (set! $rule-id
         (drop ;; end
          ($lex-match-ureal-8 $text $end)))

   (set! $value
         (if (result i32) (i32.eq $rule-id _lex-rule-uinteger-8)
           (then
            ($parse-uinteger-8-value $text $end))
           (else
            ($parse-urational-8-value $text $end))))

   (if (i32.eq ($get-string-char $start) _char-minus)
       (then
        (set! $value ($negate-number $value))))

   $value)

 (func $parse-urational-8-value (debug (export "parse-urational-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)

   (drop ;; rule-id
    (set! $end-match
          ($lex-match-uinteger-8 $text $end)))

   ($make-rational ($parse-uinteger-8-value $text $end-match)
                   ($parse-uinteger-8-value (i32.add $end-match (i32.const 1)) $end)))

 (func $parse-uinteger-8-value (debug (export "parse-uinteger-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $length i32)
   (set! $length (i32.sub $end $text))

   ;; 1-28 bits will fit in a 29-bit (signed) tagged small integer
   ;; 9 octal digits is 27 bits
   (if (i32.le_u $length (i32.const 9))
       (then
        (return ($parse-small-uinteger-8-value $text $end))))

   ;; 29-63 bits will fit in an i64
   ;; 21 octal digits is 63 bits
   (if (i32.le_u $length (i32.const 21))
       (then
        (return ($parse-i64-uinteger-8-value $text $end))))

   ;; >= 64 bits
   ($parse-integer-uinteger-8-value $text $end))

 (func $parse-small-uinteger-8-value (debug (export "parse-small-uinteger-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $char i32)
   (local $value i32)

   (set! $value (i32.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $value (i32.add (i32.shl $value (i32.const 3)) (i32.sub $char _char-0)))

          (%incr i32 $text)
          (br $again))))

   ($make-small-integer $value))

 (func $parse-i64-uinteger-8-value (debug (export "parse-i64-uinteger-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $char i32)
   (local $value i64)

   (set! $value (i64.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $value (i64.add (i64.shl $value (i64.const 3))
                                (i64.extend_i32_u (i32.sub $char _char-0))))

          (%incr i32 $text)
          (br $again))))

   ($make-boxed-i64 $value))

 (func $parse-integer-uinteger-8-value (debug (export "parse-integer-uinteger-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $accum i64)
   (local $bit-length i32)
   (local $carry-bits i64)
   (local $char-value i64)
   (local $digit-bits i64)
   (local $digit-idx i32)
   (local $size i32)
   (local $value i32)

   (set! $bit-length (i32.mul (i32.sub $end $text) (i32.const 3)))
   (set! $size (i32.shr_u (i32.add $bit-length (i32.const 0x3f))
                          (i32.const 6)))

   (set! $value ($alloc-integer $size))
   (set! $digit-idx (i32.sub $size (i32.const 1)))

   (set! $accum (i64.const 0))
   (set! $carry-bits (i64.const 0))
   (set! $digit-bits (i64.and (i64.sub (i64.const 0) (i64.extend_i32_u $bit-length))
                              (i64.const 0x3f)))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char-value (i64.extend_i32_u (i32.sub ($get-string-char $text) _char-0)))

          (%incr-n i64 $digit-bits 3)
          (if (i64.le_u $digit-bits (i64.const 0x40))
              (then
               (set! $accum (i64.or (i64.shl $accum (i64.const 3))
                                    $char-value)))
            (else
             (set! $carry-bits (i64.sub $digit-bits (i64.const 0x40)))
             (set! $accum (i64.or (i64.shl $accum (i64.sub (i64.const 3) $carry-bits))
             	                  (i64.shr_u $char-value $carry-bits)))
             (set! $digit-bits (i64.const 0x40))))

          (if (i64.eq $digit-bits (i64.const 0x40))
              (then
               ($set-integer-i64-digit $value $digit-idx $accum)
               (%decr i32 $digit-idx)

               (set! $accum (i64.and $char-value
                                     (i64.sub (i64.shl (i64.const 1) $carry-bits)
                                              (i64.const 1))))
               (set! $digit-bits $carry-bits)
               (set! $carry-bits (i64.const 0))))

          (%incr i32 $text)
          (br $again))))

   $value)

 (func $parse-num-10 (debug (export "parse-num-10"))
   (param $text i32)
   (param $end i32)

   (local $exactness i32)
   (local $number-start i32)
   (local $rule-id i32)
   (local $value i32)

   (drop ;; rule-id
    (set! $number-start ($lex-match-prefix-10 $text $end)))

   (set! $exactness ($parse-exactness-value $text $number-start))

   (set! $value ($parse-num-10-value $number-start $end $exactness))

   ($append-value (if (result i32) (i32.ne $exactness _inexact)
                    (then ($normalize-number $value))
                    (else ($to-inexact $value)))))

 (func $parse-num-10-value (debug (export "parse-num-10-value"))
   (param $text i32)
   (param $end i32)
   (param $exactness i32)
   (result i32)

   (local $rule-id i32)

   (set! $rule-id
         (drop ;; end
          ($lex-match-complex-10 $text $end)))

   (if (i32.eq $rule-id _lex-rule-signed-real-10)
       (then
        (return ($parse-signed-real-10-value $text $end $exactness))))

   (if (i32.eq $rule-id _lex-rule-full-complex-10)
       (then
        (return ($parse-full-complex-10-value $text $end $exactness))))

   (if (i32.eq $rule-id _lex-rule-complex-polar-10)
       (then
        (return ($parse-complex-polar-10-value $text $end $exactness))))

   (if (i32.eq $rule-id _lex-rule-complex-unit-im-10)
       (then
        (return ($parse-complex-unit-im-10-value $text $end $exactness))))

   (if (i32.eq $rule-id _lex-rule-complex-im-only-10)
       (then
        (return ($parse-complex-im-only-10-value $text $end $exactness))))

   (if (i32.eq $rule-id _lex-rule-complex-infnan-im-10)
       (then
        (return ($parse-complex-infnan-im-10-value $text $end $exactness))))

   (if (i32.eq $rule-id _lex-rule-unit-im)
       (then
        (return ($parse-unit-im-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-infnan)
       (then
        (return ($parse-infnan-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-infnan-im)
       (then
        (return ($parse-infnan-im-value $text $end))))

   (unreachable))

 (func $parse-full-complex-10-value (debug (export "parse-full-complex-10-value"))
   (param $text i32)
   (param $end i32)
   (param $exactness i32)
   (result i32)

   (local $end-match i32)
   (local $im i32)
   (local $is-negative-im i32)
   (local $re i32)
   (local $rule-id i32)

   (set! $rule-id
         (set! $end-match
               ($lex-match-real-10 $text $end)))

   (set! $re
         (if (result i32) (i32.eq $rule-id _lex-rule-infnan)
           (then ($parse-infnan-value $text $end-match))
           (else ($parse-real-10-value $text $end-match $exactness))))

   (set! $is-negative-im (i32.eq ($get-string-char $end-match) _char-minus))

   (set! $text (i32.add $end-match (i32.const 1)))

   (set! $rule-id
         (set! $end-match
               ($lex-match-ureal-10 $text $end)))

   (set! $im
         (if (result i32) (i32.eq $rule-id _lex-rule-uinteger-10)
           (then ($parse-uinteger-10-value $text $end-match))
           (else ($parse-urational-10-value $text $end-match))))

   (if $is-negative-im
       (then
        (set! $im ($negate-number $im))))

   ($make-complex $re $im))

 (func $parse-complex-polar-10-value (debug (export "parse-complex-polar-10-value"))
   (param $text i32)
   (param $end i32)
   (param $exactness i32)
   (result i32)

   (local $magnitude f64)
   (local $end-match i32)
   (local $arg f64)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-10 $text $end)))

   (set! $magnitude ($coerce-f64 ($parse-real-10-value $text $end-match $exactness)))

   (set! $arg ($coerce-f64 ($parse-real-10-value (i32.add $end-match (i32.const 1))
                                                 $end
                                                 $exactness)))

   (set! $re ($make-boxed-f64 (f64.mul $magnitude ($cos $arg))))

   ($make-complex $re ($make-boxed-f64 (f64.mul $magnitude ($sin $arg)))))

 (func $parse-complex-unit-im-10-value (debug (export "parse-complex-unit-im-10-value"))
   (param $text i32)
   (param $end i32)
   (param $exactness i32)
   (result i32)

   (local $end-match i32)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-10 $text $end)))

   (set! $re ($parse-real-10-value $text $end-match $exactness))

   ($make-complex $re
                  ($make-small-integer
                   (if (result i32) (i32.eq ($get-string-char $end-match) _char-plus)
                     (then (i32.const 1))
                     (else (i32.const -1))))))

 (func $parse-complex-im-only-10-value (debug (export "parse-complex-im-only-10-value"))
   (param $text i32)
   (param $end i32)
   (param $exactness i32)
   (result i32)

   ($make-complex ($make-small-integer (i32.const 0))
                  ($parse-signed-real-10-value $text
                                               (i32.sub $end (i32.const 1))
                                               $exactness)))

 (func $parse-complex-infnan-im-10-value (debug (export "parse-complex-infnan-im-10-value"))
   (param $text i32)
   (param $end i32)
   (param $exactness i32)
   (result i32)

   (local $end-match i32)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-10 $text $end)))

   (set! $re ($parse-real-10-value $text $end-match $exactness))

   ($make-complex $re ($parse-infnan-value $end-match $end)))

 (func $parse-real-10-value (debug (export "parse-real-10-value"))
   (param $text i32)
   (param $end i32)
   (param $exactness i32)
   (result i32)

   (local $rule-id i32)

   (set! $rule-id
         (drop ;; end
          ($lex-match-real-10 $text $end)))

   (if (result i32) (i32.eq $rule-id _lex-rule-signed-real-10)
     (then
      ($parse-signed-real-10-value $text $end $exactness))
     (else
      ($parse-infnan-value $text $end))))

 (func $parse-signed-real-10-value (debug (export "parse-signed-real-10-value"))
   (param $text i32)
   (param $end i32)
   (param $exactness i32)
   (result i32)

   (local $start i32)
   (local $rule-id i32)
   (local $value i32)

   (set! $start $text)

   (drop ;; rule-id
    (set! $text ($lex-match-sign $text $end)))

   (set! $rule-id
         (drop ;; end
          ($lex-match-ureal-10 $text $end)))

   (set! $value
         (if (result i32) (i32.eq $rule-id _lex-rule-uinteger-10)
           (then
            ($parse-uinteger-10-value $text $end))
           (else
            (if (result i32) (i32.eq $rule-id _lex-rule-urational-10)
              (then
               ($parse-urational-10-value $text $end))
              (else
               ($parse-decimal-value $text $end $exactness))))))

   (if (i32.eq ($get-string-char $start) _char-minus)
       (then
        (set! $value ($negate-number $value))))

   $value)

 (func $parse-urational-10-value (debug (export "parse-urational-10-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)

   (drop ;; rule-id
    (set! $end-match
          ($lex-match-uinteger-10 $text $end)))

   ($make-rational ($parse-uinteger-10-value $text $end-match)
                   ($parse-uinteger-10-value (i32.add $end-match (i32.const 1)) $end)))

 (func $parse-decimal-value (debug (export "parse-decimal-value"))
   (param $text i32)
   (param $end i32)
   (param $exactness i32)
   (result i32)

   (local $value i32)

   (set! $value ($parse-exact-decimal-value $text $end))

   (if (result i32) (i32.eq $exactness _exact)
     (then ($normalize-rational $value))
     (else ($make-boxed-f64 ($coerce-f64 $value)))))

 (func $parse-exact-decimal-value (debug (export "parse-exact-decimal-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $decimal-point i32)
   (local $denominator i32)
   (local $end-match i32)
   (local $end-significand i32)
   (local $exp i32)
   (local $exp-digits i32)
   (local $exp-start i32)
   (local $exp-value i32)
   (local $frac-start i32)
   (local $fractional-digits i32)
   (local $numerator i32)
   (local $rule-id i32)
   (local $scan i32)

   (set! $rule-id
         (set! $end-significand
               ($lex-match-significand-forms $text $end)))

   (set! $numerator ($alloc-integer
                     ($estimate-i64-digits-10
                      (if (result i32) (i32.eq $rule-id _lex-rule-uinteger-10)
                        (then (i32.sub $end-significand $text))
                        (else (i32.sub (i32.sub $end-significand $text) (i32.const 1)))))))

   (drop ;; rule-id
    (set! $end-match
          ($lex-match-uinteger-10 $text $end-significand)))

   (if (i32.eq $end-match _null)
       (then
        (set! $decimal-point $text))
     (else
      ($accumulate-integer-10 $numerator $text $end-match)
      (set! $decimal-point $end-match)))

   (if (i32.eq $decimal-point $end-significand)
       (then
        (set! $fractional-digits (i32.const 0)))

       (else
        (set! $fractional-digits (i32.sub (i32.sub $end-significand $decimal-point)
                                          (i32.const 1)))

        (set! $frac-start (i32.add $decimal-point (i32.const 1)))

        (drop ;; rule-id
         (set! $end-match
               ($lex-match-uinteger-10 $frac-start $end)))

        (if (i32.ne $end-match _null)
            (then
             ($accumulate-integer-10 $numerator $frac-start $end-match)))))

   (if (i32.eq $end $end-significand)
       (then
        (set! $denominator ($pow-10-integer $fractional-digits)))

     (else
      ;; parse suffix: e+25, for example

      (set! $exp-start (i32.add $end-match (i32.const 1)))

      (drop ;; rule-id
       (set! $exp-digits
             ($lex-match-sign $exp-start $end)))

      (set! $exp-value ($parse-uinteger-10-value $exp-digits $end))

      (if (i32.and (i32.gt_u $exp-digits $exp-start)
                   (i32.eq ($get-string-char $exp-start) _char-minus))
          (then
           (set! $exp-value ($negate-number $exp-value))))

      (if (%is-small-integer $exp-value)
          (then
           (set! $exp (i32.sub (%get-small-integer-value $exp-value) $fractional-digits))

           (if (i32.lt_s $exp (i32.const 0))
             (then
              (set! $denominator ($pow-10-integer (i32.sub (i32.const 0) $exp))))
             (else
              (set! $denominator _small-integer-1)
              (if (i32.gt_s $exp (i32.const 0))
                  (then
                   (set! $numerator ($multiply-integer-digits/dealloc $numerator
                                                                      ($pow-10-integer $exp))))))))
        (else
         ($dealloc-number $numerator)
         (if ($is-negative $exp)
             (then
              ;; 0
              (set! $numerator ($make-small-integer (i32.const 0)))
              (set! $denominator ($make-small-integer (i32.const 1))))
           (else
            ;; inf
            (set! $numerator ($make-small-integer (i32.const 1)))
            (set! $denominator ($make-small-integer (i32.const 0)))))
         ($dealloc-number $exp)))))

   ($make-rational $numerator $denominator))

 (func $pow-10-f64 (debug (export "pow-10-f64"))
   (param $n i32)
   (result f64)

   (local $is-negative i32)
   (local $result f64)

   (set! $is-negative (i32.lt_s $n (i32.const 0)))

   (if $is-negative
       (then (set! $n (i32.sub (i32.const 0) $n))))

   (if (i32.and $n (i32.const 0x0ffffe00))
       (then
        (set! $result (f64.const +inf)))

     (else

      (set! $result (if (result f64) (i32.and $n (i32.const 0x01))
                      (then (f64.const 10.0))
                      (else (f64.const 1.0))))

      ;; unrolled loop
      (if (i32.and $n (i32.const 0x02))
          (then
           (set! $result (f64.mul $result (f64.const 100.0)))))

      (if (i32.and $n (i32.const 0x04))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e4)))))

      (if (i32.and $n (i32.const 0x08))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e8)))))

      (if (i32.and $n (i32.const 0x10))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e16)))))

      (if (i32.and $n (i32.const 0x20))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e32)))))

      (if (i32.and $n (i32.const 0x40))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e64)))))

      (if (i32.and $n (i32.const 0x80))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e128)))))

      (if (i32.and $n (i32.const 0x100))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e256)))))))

   (if $is-negative
       (then
        (set! $result (f64.div (f64.const 1.0) $result))))

   $result)

 (func $parse-uinteger-10-value (debug (export "parse-uinteger-10-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $length i32)
   (set! $length (i32.sub $end $text))

   ;; 28/log2(10) ~= 8.428839878591473
   (if (i32.lt_u $length (i32.const 9))
       (then
        ;; 1-28 bits will fit in a 29-bit (signed) tagged small integer
        (return ($parse-small-uinteger-10-value $text $end))))

   ;; 63/log2(10) ~= 18.964889726830815
   (if (i32.lt_u $length (i32.const 19))
       (then
        ;; 29-63 bits will fit in an i64
        (return ($parse-i64-uinteger-10-value $text $end))))

   ;; >= 64 bits
   ($parse-integer-uinteger-10-value $text $end))

 (func $parse-small-uinteger-10-value (debug (export "parse-small-uinteger-10-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $char i32)
   (local $value i32)

   (set! $value (i32.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $value (i32.add (i32.add (i32.shl $value (i32.const 3))
                                         (i32.shl $value (i32.const 1)))
                                (i32.sub $char _char-0)))

          (%incr i32 $text)
          (br $again))))

   ($make-small-integer $value))

 (func $parse-i64-uinteger-10-value (debug (export "parse-i64-uinteger-10-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $char i32)
   (local $value i64)

   (set! $value (i64.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $value (i64.add (i64.add (i64.shl $value (i64.const 3))
                                         (i64.shl $value (i64.const 1)))
                                (i64.extend_i32_u (i32.sub $char _char-0))))

          (%incr i32 $text)
          (br $again))))

   ($make-boxed-i64 $value))

 (func $parse-integer-uinteger-10-value (debug (export "parse-integer-uinteger-10-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $value i32)

   (set! $value ($alloc-integer ($estimate-i64-digits-10 (i32.sub $end $text))))

   ($accumulate-integer-10 $value $text $end)

   $value)

 (func $estimate-i64-digits-10 (debug (export "estimate-i64-digits-10"))
   (param $digit-count i32)
   (result i32)

   ;; log2(10) ~= 3.321928094887362 < 10/3 ~= 3.3333
   ;; normally, we'd have (x + 63) >> 6, but here we need to allow for a sign
   ;; bit as well, so it becomes (x + 64) >> 6 = (x >> 6) + 1.

   (i32.add (i32.shr_u (i32.div_u (i32.mul $digit-count (i32.const 10))
                                  (i32.const 3))
                       (i32.const 6))
            (i32.const 1)))

 (func $accumulate-integer-10 (debug (export "accumulate-integer-10"))
   (param $value i32)
   (param $text i32)
   (param $end i32)

   (local $accum i32)
   (local $char i32)
   (local $digits i32)
   (local $place-count i32)

   (set! $accum (i32.const 0))
   (set! $digits (i32.sub $end $text))
   (set! $place-count (i32.const 0))

   (loop $again
     (if (i32.lt_u $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $accum (i32.add (i32.mul $accum (i32.const 10))
                                (i32.sub $char _char-0)))

          (%incr i32 $text)
          (%decr i32 $digits)
          (%incr i32 $place-count)

          ;; log2(10) ~= 3.321928094887362, so 32/log2(10) ~= 9.632959861247398
          (if (i32.eqz (i32.rem_u $digits (i32.const 9)))
              (then
               ($multiply-add-integer-i32 $value ($pow-10-i32 $place-count) $accum)
               (set! $accum (i32.const 0))
               (set! $place-count (i32.const 0))))

          (br $again))))

   (if $place-count
       (then
        ($multiply-add-integer-i32 $value ($pow-10-i32 $place-count) $accum))))

 (func $pow-10-i32 (debug (export "pow-10-i32"))
   (param $n i32)
   (result i32)

   (if (i32.gt_u $n (i32.const 9))
       (then (unreachable)))

   (i32.load (i32.add _powers-of-10-i32 (i32.shl $n (i32.const 2)))))

 (func $parse-num-16 (debug (export "parse-num-16"))
   (param $text i32)
   (param $end i32)

   (local $number-start i32)
   (local $rule-id i32)
   (local $value i32)

   (drop ;; rule-id
    (set! $number-start ($lex-match-prefix-16 $text $end)))

   (set! $value ($parse-num-16-value $number-start $end))

   ($append-value (if (result i32) (i32.ne ($parse-exactness-value $text $number-start)
                                           _inexact)
                    (then ($normalize-number $value))
                    (else ($to-inexact $value)))))

 (func $parse-num-16-value (debug (export "parse-num-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $rule-id i32)

   (set! $rule-id
         (drop ;; end
          ($lex-match-complex-16 $text $end)))

   (if (i32.eq $rule-id _lex-rule-signed-real-16)
       (then
        (return ($parse-signed-real-16-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-full-complex-16)
       (then
        (return ($parse-full-complex-16-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-polar-16)
       (then
        (return ($parse-complex-polar-16-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-unit-im-16)
       (then
        (return ($parse-complex-unit-im-16-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-im-only-16)
       (then
        (return ($parse-complex-im-only-16-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-infnan-im-16)
       (then
        (return ($parse-complex-infnan-im-16-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-unit-im)
       (then
        (return ($parse-unit-im-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-infnan)
       (then
        (return ($parse-infnan-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-infnan-im)
       (then
        (return ($parse-infnan-im-value $text $end))))

   (unreachable))

 (func $parse-full-complex-16-value (debug (export "parse-full-complex-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)
   (local $im i32)
   (local $is-negative-im i32)
   (local $re i32)
   (local $rule-id i32)

   (set! $rule-id
         (set! $end-match
               ($lex-match-real-16 $text $end)))

   (set! $re
         (if (result i32) (i32.eq $rule-id _lex-rule-infnan)
           (then ($parse-infnan-value $text $end-match))
           (else ($parse-real-16-value $text $end-match))))

   (set! $is-negative-im (i32.eq ($get-string-char $end-match) _char-minus))

   (set! $text (i32.add $end-match (i32.const 1)))

   (set! $rule-id
         (set! $end-match
               ($lex-match-ureal-16 $text $end)))

   (set! $im
         (if (result i32) (i32.eq $rule-id _lex-rule-uinteger-16)
           (then ($parse-uinteger-16-value $text $end-match))
           (else ($parse-urational-16-value $text $end-match))))

   (if $is-negative-im
       (then
        (set! $im ($negate-number $im))))

   ($make-complex $re $im))

 (func $parse-complex-polar-16-value (debug (export "parse-complex-polar-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $magnitude f64)
   (local $end-match i32)
   (local $arg f64)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-16 $text $end)))

   (set! $magnitude ($coerce-f64 ($parse-real-16-value $text $end-match)))

   (set! $arg ($coerce-f64 ($parse-real-16-value (i32.add $end-match (i32.const 1)) $end)))

   (set! $re ($make-boxed-f64 (f64.mul $magnitude ($cos $arg))))

   ($make-complex $re ($make-boxed-f64 (f64.mul $magnitude ($sin $arg)))))

 (func $parse-complex-unit-im-16-value (debug (export "parse-complex-unit-im-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-16 $text $end)))

   (set! $re ($parse-real-16-value $text $end-match))

   ($make-complex $re
                  ($make-small-integer
                   (if (result i32) (i32.eq ($get-string-char $end-match) _char-plus)
                     (then (i32.const 1))
                     (else (i32.const -1))))))

 (func $parse-complex-im-only-16-value (debug (export "parse-complex-im-only-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   ($make-complex ($make-small-integer (i32.const 0))
                  ($parse-signed-real-16-value $text
                                               (i32.sub $end (i32.const 1)))))

 (func $parse-complex-infnan-im-16-value (debug (export "parse-complex-infnan-im-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-16 $text $end)))

   (set! $re ($parse-real-16-value $text $end-match))

   ($make-complex $re ($parse-infnan-value $end-match $end)))

 (func $parse-real-16-value (debug (export "parse-real-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $rule-id i32)

   (set! $rule-id
         (drop ;; end
          ($lex-match-real-16 $text $end)))

   (if (result i32) (i32.eq $rule-id _lex-rule-signed-real-16)
     (then
      ($parse-signed-real-16-value $text $end))
     (else
      ($parse-infnan-value $text $end))))

 (func $parse-signed-real-16-value (debug (export "parse-signed-real-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $start i32)
   (local $rule-id i32)
   (local $value i32)

   (set! $start $text)

   (drop ;; rule-id
    (set! $text ($lex-match-sign $text $end)))

   (set! $rule-id
         (drop ;; end
          ($lex-match-ureal-16 $text $end)))

   (set! $value
         (if (result i32) (i32.eq $rule-id _lex-rule-uinteger-16)
           (then
            ($parse-uinteger-16-value $text $end))
           (else
            ($parse-urational-16-value $text $end))))

   (if (i32.eq ($get-string-char $start) _char-minus)
       (then
        (set! $value ($negate-number $value))))

   $value)

 (func $parse-urational-16-value (debug (export "parse-urational-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)

   (drop ;; rule-id
    (set! $end-match
          ($lex-match-uinteger-16 $text $end)))

   ($make-rational ($parse-uinteger-16-value $text $end-match)
                   ($parse-uinteger-16-value (i32.add $end-match (i32.const 1)) $end)))

 (func $parse-uinteger-16-value (debug (export "parse-uinteger-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $length i32)
   (set! $length (i32.sub $end $text))

   (if (i32.lt_u $length (i32.const 8))
       (then
        ;; 1-28 bits will fit in a 29-bit (signed) tagged small integer
        (return ($parse-small-uinteger-16-value $text $end))))

   (if (i32.lt_u $length (i32.const 16))
       (then
        ;; 29-63 bits will fit in an i64
        (return ($parse-i64-uinteger-16-value $text $end))))

   ;; >= 64 bits
   ($parse-integer-uinteger-16-value $text $end))

 (func $parse-small-uinteger-16-value (debug (export "parse-small-uinteger-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $char i32)
   (local $value i32)

   (set! $value (i32.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $value (i32.add (i32.shl $value (i32.const 4)) ($hex-digit-value $char)))

          (%incr i32 $text)
          (br $again))))

   ($make-small-integer $value))

 (func $parse-i64-uinteger-16-value (debug (export "parse-i64-uinteger-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $char i32)
   (local $value i64)

   (set! $value (i64.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $value (i64.add (i64.shl $value (i64.const 4))
                                (i64.extend_i32_u ($hex-digit-value $char))))

          (%incr i32 $text)
          (br $again))))

   ($make-boxed-i64 $value))

 (func $parse-integer-uinteger-16-value (debug (export "parse-integer-uinteger-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $accum i64)
   (local $bit-length i32)
   (local $char i32)
   (local $value i32)

   (set! $bit-length (i32.shl (i32.sub $end $text) (i32.const 2)))

   (set! $value ($alloc-integer (i32.shr_u (i32.add $bit-length (i32.const 0x3f))
                                           (i32.const 6))))

   (set! $accum (i64.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $accum (i64.or (i64.shl $accum (i64.const 4))
                               (i64.extend_i32_u ($hex-digit-value $char))))

          (%decr-n i32 $bit-length 4)

          (if (i32.eqz (i32.and $bit-length (i32.const 0x3f)))
              (then
               ($set-integer-i64-digit $value (i32.shr_u $bit-length (i32.const 6)) $accum)
               (set! $accum (i64.const 0))))

          (%incr i32 $text)
          (br $again))))

   $value)

 (func $hex-digit-value (debug (export "hex-digit-value"))
   (param $char i32)
   (result i32)

   (if (result i32) (i32.le_u $char _char-9)
     (then (i32.sub $char _char-0))
     (else
      (i32.add (i32.const 10)
               (if (result i32) (i32.le_u $char _char-F)
                 (then (i32.sub $char _char-A))
                 (else (i32.sub $char _char-a)))))))

 (func $parse-exactness-value (debug (export "parse-exactness-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $length i32)

   (set! $length (i32.sub $end $text))

   (if (i32.or (i32.and $length (i32.const 1))
               (i32.gt_u $length (i32.const 4)))
       (then
        (unreachable)))

   (loop $again
     (if (i32.eq $text $end)
         (then
          (return _no-exactness)))

     (if ($match-exact-prefix $text $end)
         (then (return _exact)))

     (if ($match-inexact-prefix $text $end)
         (then (return _inexact)))

     (%incr-n i32 $text 2)
     (br $again))

   (unreachable))

 (func $match-exact-prefix (debug (export "match-exact-prefix"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (i32.ne _null ($match-string/ascii-ci (%string-exact-prefix) $text $end)))

 (func $match-inexact-prefix (debug (export "match-inexact-prefix"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (i32.ne _null ($match-string/ascii-ci (%string-inexact-prefix) $text $end)))

 (func $parse-infnan-im-value (debug (export "parse-infnan-im-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   ($make-complex ($make-small-integer (i32.const 0))
                  ($parse-infnan-value $text $end)))

 (func $parse-infnan-value (debug (export "parse-infnan-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $initial i32)

   (set! $initial ($ascii-lower ($get-string-char (i32.add $text (i32.const 1)))))

   ($make-boxed-f64 (if (result f64) (i32.eq ($get-string-char $text) _char-plus)
                      (then
                       (if (result f64) (i32.eq $initial _char-i)
                         (then (f64.const +inf))
                         (else (f64.const +nan))))
                      (else
                       (if (result f64) (i32.eq $initial _char-i)
                         (then (f64.const -inf))
                         (else (f64.const -nan)))))))

 (func $parse-unit-im-value (debug (export "parse-unit-im-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   ($make-complex ($make-small-integer (i32.const 0))
                  ($make-small-integer
                   (if (result i32) (i32.eq ($get-string-char $text) _char-plus)
                     (then (i32.const 1))
                     (else (i32.const -1)))))))

(module

 (import "bytevectors" "alloc-bytevector"            (func $alloc-bytevector               (param i32)         (result i32)))
 (import "bytevectors" "build-bytevector"            (func $build-bytevector               (param i32)         (result i32)))
 (import "bytevectors" "dealloc-bytevector"          (func $dealloc-bytevector             (param i32)))
 (import "bytevectors" "get-bytevector-i32"          (func $get-bytevector-i32             (param i32 i32)     (result i32)))
 (import "bytevectors" "set-bytevector-i32"          (func $set-bytevector-i32             (param i32 i32 i32)))
 (import "chars" "ascii-lower"                       (func $ascii-lower                    (param i32)         (result i32)))
 (import "chars" "calc-encoded-length"               (func $calc-encoded-length            (param i32)         (result i32)))
 (import "lex-r7rs" "lex-match-atmosphere"           (func $lex-match-atmosphere           (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-complex-2"            (func $lex-match-complex-2            (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-complex-infnan-im-2"  (func $lex-match-complex-infnan-im-2  (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-complex-8"            (func $lex-match-complex-8            (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-complex-infnan-im-8"  (func $lex-match-complex-infnan-im-8  (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-complex-10"           (func $lex-match-complex-10           (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-complex-infnan-im-10" (func $lex-match-complex-infnan-im-10 (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-complex-16"           (func $lex-match-complex-16           (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-complex-infnan-im-16" (func $lex-match-complex-infnan-im-16 (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-datum-comment"        (func $lex-match-datum-comment        (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-decimal-10-forms"     (func $lex-match-decimal-10-forms     (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-delimited-token"      (func $lex-match-delimited-token      (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-delimiter"            (func $lex-match-delimiter            (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-prefix-2"             (func $lex-match-prefix-2             (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-real-2"               (func $lex-match-real-2               (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-prefix-8"             (func $lex-match-prefix-8             (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-real-8"               (func $lex-match-real-8               (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-prefix-10"            (func $lex-match-prefix-10            (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-real-10"              (func $lex-match-real-10              (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-prefix-16"            (func $lex-match-prefix-16            (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-real-16"              (func $lex-match-real-16              (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-sign"                 (func $lex-match-sign                 (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-string-element"       (func $lex-match-string-element       (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-symbol-element"       (func $lex-match-symbol-element       (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-uinteger-2"           (func $lex-match-uinteger-2           (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-uinteger-8"           (func $lex-match-uinteger-8           (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-uinteger-10"          (func $lex-match-uinteger-10          (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-uinteger-16"          (func $lex-match-uinteger-16          (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-undelimited-token"    (func $lex-match-undelimited-token    (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-ureal-2"              (func $lex-match-ureal-2              (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-ureal-8"              (func $lex-match-ureal-8              (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-ureal-10"             (func $lex-match-ureal-10             (param i32 i32)     (result i32 i32)))
 (import "lex-r7rs" "lex-match-ureal-16"             (func $lex-match-ureal-16             (param i32 i32)     (result i32 i32)))
 (import "lists" "dealloc-list"                      (func $dealloc-list                   (param i32)))
 (import "math" "cos"                                (func $cos                            (param f64)         (result f64)))
 (import "math" "sin"                                (func $sin                            (param f64)         (result f64)))
 (import "numbers" "is-inexact"                      (func $is-inexact                     (param i32)         (result i32)))
 (import "numbers" "alloc-integer"                   (func $alloc-integer                  (param i32)         (result i32)))
 (import "numbers" "coerce-f64"                      (func $coerce-f64                     (param i32)         (result f64)))
 (import "numbers" "dealloc-number"                  (func $dealloc-number                 (param i32)))
 (import "numbers" "make-boxed-f64"                  (func $make-boxed-f64                 (param f64)         (result i32)))
 (import "numbers" "make-boxed-i64"                  (func $make-boxed-i64                 (param i64)         (result i32)))
 (import "numbers" "make-complex"                    (func $make-complex                   (param i32 i32)     (result i32)))
 (import "numbers" "make-rational"                   (func $make-rational                  (param i32 i32)     (result i32)))
 (import "numbers" "make-small-integer"              (func $make-small-integer             (param i32)         (result i32)))
 (import "numbers" "negate-number"                   (func $negate-number                  (param i32)         (result i32)))
 (import "numbers" "set-integer-i64-digit"           (func $set-integer-i64-digit          (param i32 i32 i64)))
 (import "numbers" "to-inexact"                      (func $to-inexact                     (param i32)         (result i32)))
 (import "pairs" "dealloc-pair"                      (func $dealloc-pair                   (param i32)))
 (import "pairs" "get-pair-car"                      (func $get-pair-car                   (param i32)         (result i32)))
 (import "pairs" "get-pair-cdr"                      (func $get-pair-cdr                   (param i32)         (result i32)))
 (import "pairs" "make-pair"                         (func $make-pair                      (param i32 i32)     (result i32)))
 (import "pairs" "set-pair-car"                      (func $set-pair-car                   (param i32 i32)))
 (import "pairs" "set-pair-cdr"                      (func $set-pair-cdr                   (param i32 i32)))
 (import "strings" "alloc-string"                    (func $alloc-string                   (param i32 i32)     (result i32)))
 (import "strings" "build-string"                    (func $build-string                   (param i32)         (result i32)))
 (import "strings" "dealloc-string"                  (func $dealloc-string                 (param i32)))
 (import "strings" "get-string-addr"                 (func $get-string-addr                (param i32)         (result i32)))
 (import "strings" "get-string-char"                 (func $get-string-char                (param i32)         (result i32)))
 (import "strings" "match-string"                    (func $match-string                   (param i32 i32 i32) (result i32)))
 (import "strings" "match-string/ascii-ci"           (func $match-string/ascii-ci          (param i32 i32 i32) (result i32)))
 (import "strings" "set-string-bytes"                (func $set-string-bytes               (param i32 i32 i32)))
 (import "strings" "slice-string-addr"               (func $slice-string-addr              (param i32 i32)     (result i32)))
 (import "symbols" "make-symbol"                     (func $make-symbol                    (param i32)         (result i32)))
 (import "vectors" "build-vector"                    (func $build-vector                   (param i32)         (result i32)))
 (import "vectors" "dealloc-vector"                  (func $dealloc-vector                 (param i32)))
 (import "vectors" "get-vector-element"              (func $get-vector-element             (param i32 i32)     (result i32)))
 (import "vectors" "get-vector-length"               (func $get-vector-length              (param i32)         (result i32)))

 (import "lex-r7rs" "string-alarm"          (global $string-alarm          (mut i32)))
 (import "lex-r7rs" "string-begin-vector"   (global $string-begin-vector   (mut i32)))
 (import "lex-r7rs" "string-delete"         (global $string-delete         (mut i32)))
 (import "lex-r7rs" "string-escape"         (global $string-escape         (mut i32)))
 (import "lex-r7rs" "string-exact-prefix"   (global $string-exact-prefix   (mut i32)))
 (import "lex-r7rs" "string-inexact-prefix" (global $string-inexact-prefix (mut i32)))

 (global $string-quasiquote-symbol       (export "string-quasiquote-symbol")       (mut i32) (i32.const 0))
 (global $string-quote-symbol            (export "string-quote-symbol")            (mut i32) (i32.const 0))
 (global $string-unquote-splicing-symbol (export "string-unquote-splicing-symbol") (mut i32) (i32.const 0))
 (global $string-unquote-symbol          (export "string-unquote-symbol")          (mut i32) (i32.const 0))

 (string _string-quasiquote-symbol-data       (export "string-quasiquote-symbol-data")       "quasiquote-symbol")
 (string _string-quote-symbol-data            (export "string-quote-symbol-data")            "quote-symbol")
 (string _string-unquote-splicing-symbol-data (export "string-unquote-splicing-symbol-data") "unquote-splicing-symbol")
 (string _string-unquote-symbol-data          (export "string-unquote-symbol-data")          "unquote-symbol")

 (macro %string-alarm
   (global.get $string-alarm))

 (macro %string-begin-vector
   (global.get $string-begin-vector))

 (macro %string-delete
   (global.get $string-delete))

 (macro %string-escape
   (global.get $string-escape))

 (macro %string-exact-prefix
   (global.get $string-exact-prefix))

 (macro %string-inexact-prefix
   (global.get $string-inexact-prefix))

 (macro %string-quasiquote-symbol
   (global.get $string-quasiquote-symbol))

 (macro %string-quote-symbol
   (global.get $string-quote-symbol))

 (macro %string-unquote-splicing-symbol
   (global.get $string-unquote-splicing-symbol))

 (macro %string-unquote-symbol
   (global.get $string-unquote-symbol))

 (include "./constants.wam")
 (include "./globals.wam")
 (include "./ascii.wam")
 (include "./values.wam")
 (include "./boxes.wam")
 (include "./lex-r7rs-rule-ids.wam")
 (include "./string-loader.wam")

 (memory (debug (export "memory")) 1)

 ;; todo: belongs elsewhere
 (macro %get-small-integer-value
   (expr ,v)
   (i32.shr_s ,v _tag-size-bits))

 ;; todo: belongs elsewhere
 (macro %is-small-integer
   (expr ,v)
   (i32.eq (%get-value-tag ,v) _tag-small-integer))

 ;; results from parse-exactness-value
 (define _no-exactness (i32.const 0))
 (define _exact        (i32.const 1))
 (define _inexact      (i32.const 2))

 ;; Define the parse context structure
 (define _ctx-flags-offset (+offset 0 4))
 (define _ctx-tail-offset  (+offset))
 (define _ctx-value-offset (+offset))
 (define _ctx-size         (+offset))

 (debug
  (global $ctx-flags-offset (export "ctx-flags-offset") i32 _ctx-flags-offset)
  (global $ctx-tail-offset  (export "ctx-tail-offset")  i32 _ctx-tail-offset)
  (global $ctx-value-offset (export "ctx-value-offset") i32 _ctx-value-offset)
  (global $ctx-size         (export "ctx-size")         i32 _ctx-size))

 ;; Flags
 (define _ctx-auto-unnest       (i32.const 0x01))
 (define _ctx-datum-comment     (i32.const 0x02))
 (define _ctx-finalized         (i32.const 0x04))
 (define _ctx-finalizing        (i32.const 0x08))
 (define _ctx-type-bytevector   (i32.const 0x10))
 (define _ctx-type-vector       (i32.const 0x20))
 (define _ctx-type-mask         (i32.const 0x30))
 (define _ctx-type-mask-inverse (i32.const 0xffffffcf))

 (debug
  (global $ctx-auto-unnest       (export "ctx-auto-unnest")       i32 _ctx-auto-unnest)
  (global $ctx-datum-comment     (export "ctx-datum-comment")     i32 _ctx-datum-comment)
  (global $ctx-finalized         (export "ctx-finalized")         i32 _ctx-finalized)
  (global $ctx-finalizing        (export "ctx-finalizing")        i32 _ctx-finalizing)
  (global $ctx-type-bytevector   (export "ctx-type-bytevector")   i32 _ctx-type-bytevector)
  (global $ctx-type-vector       (export "ctx-type-vector")       i32 _ctx-type-vector)
  (global $ctx-type-mask         (export "ctx-type-mask")         i32 _ctx-type-mask)
  (global $ctx-type-mask-inverse (export "ctx-type-mask-inverse") i32 _ctx-type-mask-inverse))

 ;; The stack is implemented as a list of bytevectors.
 (global $ctx-stack (debug (export "ctx-stack")) (mut i32) _null)

 (macro %get-ctx-stack
   (global.get $ctx-stack))

 (macro %set-ctx-stack
   (expr ,v)
   (global.set $ctx-stack ,v))

 (macro %push-ctx
   (expr ,v)
   (%set-ctx-stack ($make-pair ,v (global.get $ctx-stack))))

 (macro %get-current-ctx
   ($get-pair-car (%get-ctx-stack)))

 (macro %get-ctx-flags
   (expr ,ctx)
   ($get-bytevector-i32 ,ctx _ctx-flags-offset))

 (macro %get-ctx-tail
   (expr ,ctx)
   ($get-bytevector-i32 ,ctx _ctx-tail-offset))

 (macro %get-ctx-type
   (expr ,ctx)
   (i32.and _ctx-type-mask (%get-ctx-flags ,ctx)))

 (macro %get-ctx-value
   (expr ,ctx)
   ($get-bytevector-i32 ,ctx _ctx-value-offset))

 (macro %set-ctx-flags
   (expr ,ctx)
   (expr ,flags)
   ($set-bytevector-i32 ,ctx _ctx-flags-offset ,flags))

 (macro %set-ctx-tail
   (expr ,ctx)
   (expr ,tail)
   ($set-bytevector-i32 ,ctx _ctx-tail-offset ,tail))

 (macro %set-ctx-value
   (expr ,ctx)
   (expr ,value)
   ($set-bytevector-i32 ,ctx _ctx-value-offset ,value))

 (macro %get-current-ctx-flags
   (%get-ctx-flags (%get-current-ctx)))

 (macro %get-current-ctx-value
   (%get-ctx-value (%get-current-ctx)))

 (macro %is-auto-unnest-ctx
   (expr ,ctx)
   (i32.and (%get-ctx-flags ,ctx) _ctx-auto-unnest))

 (macro %is-datum-comment-ctx
   (expr ,ctx)
   (i32.and (%get-ctx-flags ,ctx) _ctx-datum-comment))

 (macro %is-bytevector-ctx
   (expr ,ctx)
   (i32.and (%get-ctx-flags ,ctx) _ctx-type-bytevector))

 (macro %is-finalized-ctx
   (expr ,ctx)
   (i32.and (%get-ctx-flags ,ctx) _ctx-finalized))

 (macro %is-finalizing-ctx
   (expr ,ctx)
   (i32.and (%get-ctx-flags ,ctx) _ctx-finalizing))

 (macro %is-list-ctx
   (expr ,ctx)
   (i32.eqz (i32.and (%get-ctx-flags ,ctx) _ctx-type-mask)))

 (macro %is-vector-ctx
   (expr ,ctx)
   (i32.eq _ctx-type-vector
           (i32.and (%get-ctx-flags ,ctx) _ctx-type-mask)))

 (macro %set-auto-unnest-ctx
   (label $ctx)
   (%set-ctx-flags $ctx (i32.or (%get-ctx-flags $ctx) _ctx-auto-unnest)))

 (macro %set-datum-comment-ctx
   (label $ctx)
   (%set-ctx-flags $ctx (i32.or (%get-ctx-flags $ctx) _ctx-datum-comment)))

 (macro %set-bytevector-ctx
   (label $ctx)
   (%set-ctx-flags $ctx (i32.or (i32.and (%get-ctx-flags $ctx) _ctx-type-mask-inverse)
                                _ctx-type-bytevector)))

 (macro %set-finalized-ctx
   (label $ctx)
   (%set-ctx-flags $ctx (i32.or (%get-ctx-flags $ctx) _ctx-finalized)))

 (macro %set-finalizing-ctx
   (label $ctx)
   (%set-ctx-flags $ctx (i32.or (%get-ctx-flags $ctx) _ctx-finalizing)))

 ;; (macro %set-list-ctx
 ;;   (label $ctx)
 ;;   (%set-ctx-flags $ctx (i32.and (%get-ctx-flags $ctx) _ctx-type-mask-inverse)))

 (macro %set-vector-ctx
   (label $ctx)
   (%set-ctx-flags $ctx (i32.or (i32.and (%get-ctx-flags $ctx) _ctx-type-mask-inverse)
                                _ctx-type-vector)))

 (global $parse-error (debug (export "parse-error")) (mut i32) _null)

 (macro %get-parse-error
   (global.get $parse-error))

 (macro %set-parse-error
   (expr ,v)
   (global.set $parse-error ,v))

 (macro %get-parse-result
   (if (result i32) (i32.eq (%get-parse-error) _null)
     (then ($get-pair-car ($get-pair-cdr (%get-current-ctx-value))))
     (else (%get-parse-error))))

 (macro %is-parse-finished
   (i32.or (i32.ne (%get-parse-error) _null)
           (i32.eq ($get-pair-cdr (%get-ctx-stack)) _null)))

 (global $parse-location (debug (export "parse-location")) (mut i32) _null)

 (func $get-parse-location (export "get-parse-location")
   (result i32)
   (global.get $parse-location))

 (macro %set-parse-location
   (expr ,v)
   (global.set $parse-location ,v))

 (global $quasiquote-symbol       (debug (export "quasiquote-symbol"))       (mut i32) _null)
 (global $quote-symbol            (debug (export "quote-symbol"))            (mut i32) _null)
 (global $unquote-splicing-symbol (debug (export "unquote-splicing-symbol")) (mut i32) _null)
 (global $unquote-symbol          (debug (export "unquote-symbol"))          (mut i32) _null)

 (macro %quasiquote-symbol
   (global.get $quasiquote-symbol))

 (macro %quote-symbol
   (global.get $quote-symbol))

 (macro %unquote-splicing-symbol
   (global.get $unquote-splicing-symbol))

 (macro %unquote-symbol
   (global.get $unquote-symbol))

 (start $init-parse)
 (func $init-parse (debug (export "init-parse"))
   (global.set $string-quasiquote-symbol       ($load-string _string-quasiquote-symbol-data))
   (global.set $string-quote-symbol            ($load-string _string-quote-symbol-data))
   (global.set $string-unquote-symbol          ($load-string _string-unquote-symbol-data))
   (global.set $string-unquote-splicing-symbol ($load-string _string-unquote-splicing-symbol-data))

   (global.set $quasiquote-symbol       ($make-symbol (%string-quasiquote-symbol)))
   (global.set $quote-symbol            ($make-symbol (%string-quote-symbol)))
   (global.set $unquote-splicing-symbol ($make-symbol (%string-unquote-splicing-symbol)))
   (global.set $unquote-symbol          ($make-symbol (%string-unquote-symbol)))

   (%set-ctx-stack _null))

 (func $make-parse-context (debug (export "make-parse-context"))
   (result i32)

   (local $ctx i32)
   (local $value i32)

   (set! $ctx ($alloc-bytevector _ctx-size))

   (%set-ctx-flags $ctx (i32.const 0))

   (set! $value ($make-pair _null _null))
   (%set-ctx-value $ctx $value)
   (%set-ctx-tail $ctx $value)

   $ctx)

 (func $dealloc-parse-context (debug (export "dealloc-parse-context"))
   (param $ctx i32)
   ($dealloc-pair (%get-ctx-value $ctx))
   ($dealloc-bytevector $ctx))

 (func $nest (debug (export "nest"))
   (%push-ctx ($make-parse-context)))

 (func $unnest (debug (export "unnest"))

   (local $ctx i32)
   (local $head i32)
   (local $value i32)

   (set! $head (%get-ctx-stack))

   (if (i32.eq $head _null)
       (then
        ;; fail unmatched close paren
        (return)
        ))

   (set! $ctx ($get-pair-car $head))
   (%set-ctx-stack ($get-pair-cdr $head))

   ($dealloc-pair $head)
   (set! $value ($get-pair-cdr (%get-ctx-value $ctx)))

   (if (%is-datum-comment-ctx $ctx)
       (then
        ($dealloc-value $value))
     (else
      ($append-value (if (result i32) (%is-list-ctx $ctx)
                       (then (%make-value _tag-pair $value))
                       (else
                        (if (result i32) (%is-vector-ctx $ctx)
                          (then ($build-vector $value))
                          (else ($build-bytevector $value)))
                        ($dealloc-list $value))))))

   ($dealloc-parse-context $ctx))

 (func $append-value (debug (export "append-value"))
   (param $v i32)

   (local $ctx i32)
   (local $new-tail i32)

   (set! $ctx (%get-current-ctx))

   (if (%is-bytevector-ctx $ctx)
       (then
        (if (i32.eqz (%is-small-integer $v))
            (then
             (%set-parse-error _error-illegal-bytevector-element))
          (else
           (set! $v (%get-small-integer-value $v))
           (if (i32.gt_u $v (i32.const 0xff))
               (then
                (%set-parse-error _error-illegal-bytevector-element)))))))

   (if (%is-finalized-ctx $ctx)
       (then
        (%set-parse-error _error-pair-missing-close-parenthesis))
     (else
      (if (%is-finalizing-ctx $ctx)
          (then
           (%set-finalized-ctx $ctx)
           ($set-pair-cdr (%get-ctx-tail $ctx) $v))
        (else
         (set! $new-tail ($make-pair $v _null))
         ($set-pair-cdr (%get-ctx-tail $ctx) $new-tail)
         (%set-ctx-tail $ctx $new-tail)))))

   ;; datum comment, quote, quasiquote, splice, unquote, and
   ;; unquote-splicing all generate auto-unnest contexts.

   (if (%is-auto-unnest-ctx $ctx)
       (then
        ($unnest))))

 (func $unwind-parse-stack (debug (export "unwind-parse-stack"))
   (loop $again
     (if (i32.ne ($get-pair-cdr (%get-ctx-stack)) _null)
         (then
          ($unnest)
          (br $again)))))

 ;; todo: this belongs elsewhere
 (func $dealloc-value (export "dealloc-value")
   (param $value i32)

   (local $idx i32)
   (local $tag i32)
   (local $type i32)

   (set! $tag (%get-value-tag $value))

   (if (i32.eq $tag _tag-pair)
       (then
        ($dealloc-value ($get-pair-car $value))
        ($dealloc-value ($get-pair-cdr $value))
        ($dealloc-pair $value)
        (return)))

   (if (i32.eq $tag _tag-box)
       (then
        (set! $type (%get-box-type $value))

        (if (i32.eq $tag _type-bytevector)
            (then
             ($dealloc-bytevector $value)
             (return)))

        (if (i32.eq $tag _type-number)
            (then
             ($dealloc-number $value)
             (return)))

        (if (i32.eq $tag _type-string)
            (then
             ($dealloc-string $value)
             (return)))

        (if (i32.eq $tag _type-vector)
            (then
             (set! $idx ($get-vector-length $value))
             (loop $again
               (if $idx
                   (then
                    (%decr i32 $idx)
                    ($dealloc-value ($get-vector-element $value $idx))
                    (br $again))))
             ($dealloc-vector $value)
             (return))))))

 (func $init-parser (debug (export "init-parser"))

   (local $ctx i32)
   (local $value i32)

   (if (i32.eq (%get-ctx-stack) _null)
       (then ($nest)))

   (if (i32.ne (%get-parse-error) _null)
       (then
        ($unwind-parse-stack)
        ($dealloc-value (%get-current-ctx-value))

        (%set-parse-error _null)))

   (set! $ctx (%get-current-ctx))
   (set! $value (%get-ctx-value $ctx))

   ($set-pair-car $value _null)
   ($set-pair-cdr $value _null)

   (%set-ctx-tail $ctx $value)
   (%set-ctx-flags $ctx (i32.const 0)))

 (func $parse (export "parse")
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-delimiter i32)
   (local $end-match i32)
   (local $rule-id i32)

   ($init-parser)

   (loop $again

     ;; Atmosphere matches whitespace, comments, and directives.

     (set! $rule-id
           (set! $end-match ($lex-match-atmosphere $text $end)))

     (if (i32.ne $end-match _null)
         (then

          ;; Directives must be followed by a delimiter, or the end of the input.

          (if (i32.eq $rule-id _lex-rule-directive)
              (then
               (if (i32.lt_u $text $end)
                   (then
                    (drop ;; rule-id
                     (set! $end-delimiter ($lex-match-delimiter $end-match $end)))

                    (if (i32.eq $end-delimiter _null)
                        (then
                         (%set-parse-location $text)
                         (return _error-delimiter-must-follow-directive)))))

               ;; set parser state for fold-case/no-fold-case

               ($process-directive $text $end-match)))

          (set! $text $end-match)
          (br $again)))

     ;; Delimited tokens are strings, vertical bar-delimited identifiers, and
     ;; the open and close paren characters.

     (set! $rule-id
           (set! $end-match
                 ($lex-match-delimited-token $text $end)))

     (if (i32.ne $end-match _null)
         (then
          ($parse-delimited-token $rule-id $text $end-match)

          ;; If the text processed so far makes a complete value, then stop and
          ;; return that to the caller.

          (if (%is-parse-finished)
              (then
               (%set-parse-location $end-match)
               (return (%get-parse-result))))

          (br $again)))

     ;; An undelimited token is anything else that isn't whitespace, a comment,
     ;; or a directive.

     (set! $rule-id
           (set! $end-match
                 ($lex-match-undelimited-token $text $end)))

     (if (i32.ne $end-match _null)
         (then
          (if (i32.lt_u $end-match $end)
              (then

               ;; A delimiter must follow an undelimited token, where a
               ;; delimiter is one of whitespace, double quote, vertical bar,
               ;; semicolon, open paren, or close paren.

               (drop ;; rule-id
                (set! $end-delimiter ($lex-match-delimiter $end-match $end)))

               (if (i32.eq $end-delimiter _null)
                   (then
                    (%set-parse-location $text)
                    (return _error-unrecognized-token)))))

          ($parse-undelimited-token $rule-id $text $end-match)

          ;; If the text processed so far makes a complete value or
          ;; has resulted in an error, then stop and return that to
          ;; the caller.

          (if (%is-parse-finished)
              (then
               (%set-parse-location $end-match)
               (return (%get-parse-result))))

          (br $again)))

     ;; Datum comments are similar to quotes. Where ' indicates that
     ;; the following datum should be appended to the parsed value in
     ;; a list beginning with the symbol "quote", datum comments
     ;; indicate that the following datum should be dropped and not
     ;; added to the parsed value.

     (set! $rule-id
           (set! $end-match
                 ($lex-match-datum-comment $text $end)))

     (if (i32.ne $end-match _null)
         (then
          ($parse-datum-comment $rule-id $text $end-match)

          ;; If the text processed so far makes a complete value, then stop and
          ;; return that to the caller.

          (if (%is-parse-finished)
              (then
               (%set-parse-location $end-match)
               (return (%get-parse-result))))

          (br $again))))

   (%set-parse-location $text)

   (if (result i32) (i32.eq $text $end)
     (then _error-incomplete-input)
     (else _error-unrecognized-token)))

 (func $process-directive (debug (export "process-directive"))
   (param $text i32)
   (param $end i32)
   ;; todo
   )

 (func $parse-delimited-token (export "parse-delimited-token")
   (param $rule-id i32)
   (param $text i32)
   (param $end i32)

   (if (i32.eq $rule-id _lex-rule-paren-char)
       (then
        (if (i32.eq ($get-string-char $text) _char-open-paren)
            (then
             ($nest))
          (else
           (if (i32.eq (%get-ctx-stack) _null)
               (then
                (%set-parse-error _error-unmatched-close-parenthesis))
             (else
              ($unnest)))))
        (return)))

   (if (i32.eq $rule-id _lex-rule-quoted-string)
       (then
        ($parse-string $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-delimited-token-string)
       (then
        (if (i32.eq ($match-string (%string-begin-vector) $text $end)
                    $end)
            (then
             ($nest)
             (%set-vector-ctx (%get-current-ctx)))
          (else
           ($nest)
           (%set-bytevector-ctx (%get-current-ctx))))
        (return)))

   (if (i32.eq $rule-id _lex-rule-vertical-line-quoted-symbol)
       (then
        ($parse-vertical-line-quoted-symbol $text $end)
        (return)))

   (unreachable))

 (func $parse-undelimited-token (export "parse-undelimited-token")
   (param $rule-id i32)
   (param $text i32)
   (param $end i32)

   (if (i32.eq $rule-id _lex-rule-token-char)
       (then
        ;; $lex-rule-token-char  '`,.
        ($parse-token-char $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-ordinary-identifier)
       (then
        ($parse-simple-identifier $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-boolean)
       (then
        ($parse-boolean $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-escaped-character)
       (then
        ($parse-escaped-character $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-named-character)
       (then
        ($parse-named-character $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-escaped-character-hex)
       (then
        ($parse-escaped-character-hex $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-num-10)
       (then
        ($parse-num-10 $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-num-16)
       (then
        ($parse-num-16 $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-num-2)
       (then
        ($parse-num-2 $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-num-8)
       (then
        ($parse-num-8 $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-unquote-splicing)
       (then
        ($parse-unquote-splicing $text $end)
        (return)))

   (if (i32.eq $rule-id _lex-rule-peculiar-identifier)
       (then
        ($parse-simple-identifier $text $end)
        (return)))

   (unreachable))

 (func $parse-unquote-splicing (debug (export "parse-unquote-splicing"))
   (param $text i32)
   (param $end i32)

   ($nest)
   ($append-value (%unquote-splicing-symbol))
   (%set-auto-unnest-ctx (%get-current-ctx)))

 (func $parse-token-char (debug (export "parse-token-char"))
   (param $text i32)
   (param $end i32)

   (local $char i32)
   (local $symbol i32)

   (set! $char ($get-string-char $text))

   (if (i32.eq $char _char-dot)
       (then
        (%set-finalizing-ctx (%get-current-ctx))
        (return)))

   ($nest)

   (if (i32.eq $char _char-quote)
       (then
        (set! $symbol (%quote-symbol)))
     (else
      (if (i32.eq $char _char-backtick)
          (then
           (set! $symbol (%quasiquote-symbol)))
        (else
         (if (i32.eq $char _char-comma)
             (then
              (set! $symbol (%unquote-symbol)))
           (else
            (unreachable)))))))

   ($append-value $symbol)
   (%set-auto-unnest-ctx (%get-current-ctx)))

 (func $parse-datum-comment (debug (export "parse-datum-comment"))
   (param $text i32)
   (param $end i32)

   (%set-auto-unnest-ctx (%get-current-ctx))
   (%set-datum-comment-ctx (%get-current-ctx)))

 (func $parse-simple-identifier (debug (export "parse-simple-identifier"))
   (param $text i32)
   (param $end i32)

   ($append-value ($make-symbol ($slice-string-addr $text $end))))

 (func $parse-boolean (debug (export "parse-boolean"))
   (param $text i32)
   (param $end i32)

   ;; "#true" has length 5, "#false" has length 6
   ($append-value (if (result i32) (i32.eq (i32.const 5) (i32.sub $end $text))
                    (then _true)
                    (else _false))))

 (func $parse-escaped-character (debug (export "parse-escaped-character"))
   (param $text i32)
   (param $end i32)

   ($append-value (%make-value _tag-char ($get-string-char (i32.add $text (i32.const 2))))))

 (func $parse-named-character (debug (export "parse-named-character"))
   (param $text i32)
   (param $end i32)

   (local $char i32)
   (local $length i32)

   (set! $text (i32.add $text (i32.const 2)))
   (set! $length (i32.sub $end $text))

   (set! $char
         (if (result i32) (i32.eq $length (i32.const 5))
           (then
            (if (result i32) ($match-string (%string-alarm) $text $end)
              (then _char-bell)
              (else _char-space)))
           (else
            (if (result i32) (i32.eq $length (i32.const 6))
              (then
               (if (result i32) ($match-string (%string-delete) $text $end)
                 (then _char-delete)
                 (else
                  (if (result i32) ($match-string (%string-escape) $text $end)
                    (then _char-escape)
                    (else _char-carriage-return))))) ;; return
              (else
               (if (result i32) (i32.eq $length (i32.const 3)) ;; tab
                 (then _char-tab)
                 (else
                  (if (result i32) (i32.eq $length (i32.const 4)) ;; null
                    (then _char-null)
                    (else
                     (if (result i32) (i32.eq $length (i32.const 7)) ;; newline
                       (then _char-line-feed)
                       (else
                        (debug
                         (if (result i32) (i32.eq $length (i32.const 9)) ;; backspace
                           (then _char-backspace)
                           (else (unreachable) _null))))))))))))))

   ($append-value (%make-value _tag-char $char)))

 (func $parse-escaped-character-hex (debug (export "parse-escaped-character-hex"))
   (param $text i32)
   (param $end i32)

   ;; add 1 to skip over the #
   ($append-value (%make-value _tag-char ($parse-hex-escape (i32.add $text (i32.const 1)) $end))))

 (func $parse-vertical-line-quoted-symbol (debug (export "parse-vertical-line-quoted-symbol"))
   (param $text i32)
   (param $end i32)

   (local $char i32)
   (local $char-list i32)
   (local $end-match i32)
   (local $next i32)
   (local $rule-id i32)
   (local $tail i32)

   (set! $char-list ($make-pair _null _null))
   (set! $tail $char-list)

   ;; skip over initial vertical line
   (set! $text (i32.add $text (i32.const 1)))

   (loop $again

     (if (i32.lt_u $text $end)
         (then

          (set! $rule-id
                (set! $end-match ($lex-match-symbol-element $text $end)))

          (set! $char
                (if (result i32) (i32.eq $rule-id _lex-rule-symbol-element/character)
                  (then
                   ($get-string-char $text))
                  (else
                   (if (result i32) (i32.eq $rule-id _lex-rule-escaped-vertical-line)
                     (then
                      ;; add 1 to skip over backslash
                      ($get-string-char (i32.add $text (i32.const 1))))
                     (else
                      (if (result i32) (i32.eq $rule-id _lex-rule-mnemonic-escape)
                        (then
                         ;; add 1 to skip over backslash
                         ($parse-mnemonic-char (i32.add $text (i32.const 1))))
                        (else
                         (debug
                          (if (i32.ne $rule-id _lex-rule-inline-hex-escape)
                              (then
                               (unreachable))))

                         ($parse-hex-escape $text $end-match))))))))

          (set! $next ($make-pair $char _null))
          ($set-pair-cdr $tail $next)
          (set! $tail $next)

          (set! $text $end-match)
          (br $again))))

   ($append-value ($make-symbol ($build-string ($get-pair-cdr $char-list))))
   ($dealloc-list $char-list))

 (func $parse-string (debug (export "parse-string"))
   (param $text i32)
   (param $end i32)

   (local $char i32)
   (local $char-list i32)
   (local $end-match i32)
   (local $next i32)
   (local $rule-id i32)
   (local $tail i32)

   (set! $char-list ($make-pair _null _null))
   (set! $tail $char-list)

   ;; skip over initial double quote
   (set! $text (i32.add $text (i32.const 1)))

   (loop $again

     (if (i32.lt_u $text $end)
         (then

          (set! $rule-id
                (set! $end-match ($lex-match-string-element $text $end)))

          (if (i32.ne $rule-id _lex-rule-escaped-line-ending)
              (then
               (set! $char
                     (if (result i32) (i32.eq $rule-id _lex-rule-string-element/character)
                       (then
                        ($get-string-char $text))
                       (else
                        (if (result i32) (i32.or (i32.eq $rule-id _lex-rule-escaped-double-quote)
                                                 (i32.eq $rule-id _lex-rule-escaped-backslash))
                          (then
                           ;; add 1 to skip over backslash
                           ($get-string-char (i32.add $text (i32.const 1))))
                          (else
                           (if (result i32) (i32.eq $rule-id _lex-rule-mnemonic-escape)
                             (then
                              ;; add 1 to skip over backslash
                              ($parse-mnemonic-char (i32.add $text (i32.const 1))))
                             (else
                              (debug
                               (if (i32.ne $rule-id _lex-rule-inline-hex-escape)
                                   (then
                                    (unreachable))))

                              ($parse-hex-escape $text $end-match))))))))

               (set! $next ($make-pair $char _null))
               ($set-pair-cdr $tail $next)
               (set! $tail $next)))

          (set! $text $end-match)
          (br $again))))

   ($append-value ($build-string ($get-pair-cdr $char-list)))
   ($dealloc-list $char-list))

 (func $parse-mnemonic-char (debug (export "parse-mnemonic-char"))
   (param $text i32)
   (result i32)

   (local $char i32)

   (set! $char ($get-string-char $text))

   (if (result i32) (i32.eq $char _char-a)
     (then _char-bell)
     (else
      (if (result i32) (i32.eq $char _char-b)
        (then _char-backspace)
        (else
         (if (result i32) (i32.eq $char _char-t)
           (then _char-tab)
           (else
            (if (result i32) (i32.eq $char _char-n)
              (then _char-line-feed)
              (else
               (if (result i32) (i32.eq $char _char-r)
                 (then _char-carriage-return)
                 (else (unreachable) _null)))))))))))

 (func $parse-hex-escape (debug (export "parse-hex-escape"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $accum i32)
   (local $char i32)
   (local $code-point i32)
   (local $value i32)

   ;; move text forward 2 to skip over \x
   (set! $text (i32.add $text (i32.const 2)))

   ;; move end back 1 to account for final semicolon
   (set! $end (i32.sub $end (i32.const 1)))

   (set! $code-point (i32.const 0))
   (loop $again

     (if (i32.and $code-point (i32.const 0xf0000000))
         (then
          ;; todo: inline hex overflow error
          (return _char-null)))

     (set! $char ($get-string-char $text))

     (set! $value (i32.sub $char
                           (if (result i32) (i32.le_u $char _char-9)
                             (then _char-0)
                             (else
                              (if (result i32) (i32.le_u $char _char-F)
                                (then _char-A)
                                (else _char-a))))))

     (set! $code-point (i32.or (i32.shl $code-point (i32.const 4)) $value))

     (set! $text (i32.add $text (i32.const 1)))

     (if (i32.lt_u $text $end)
         (then
          (br $again))))

   (if (i32.eq ($calc-encoded-length $code-point) (i32.const -1))
       (then
        ;; todo: invalid code point
        (return _char-null)))

   $code-point)

 (func $parse-num-2 (debug (export "parse-num-2"))
   (param $text i32)
   (param $end i32)

   (local $number-start i32)
   (local $rule-id i32)
   (local $value i32)

   (drop ;; rule-id
    (set! $number-start ($lex-match-prefix-2 $text $end)))

   (set! $value ($parse-num-2-value $number-start $end))

   ($append-value (if (result i32) (i32.ne ($parse-exactness-value $text $number-start)
                                           _inexact)
                    (then $value)
                    (else ($to-inexact $value)))))

 (func $parse-num-2-value (debug (export "parse-num-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $rule-id i32)

   (set! $rule-id
         (drop ;; end
          ($lex-match-complex-2 $text $end)))

   (if (i32.eq $rule-id _lex-rule-signed-real-2)
       (then
        (return ($parse-signed-real-2-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-full-complex-2)
       (then
        (return ($parse-full-complex-2-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-polar-2)
       (then
        (return ($parse-complex-polar-2-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-unit-im-2)
       (then
        (return ($parse-complex-unit-im-2-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-im-only-2)
       (then
        (return ($parse-complex-im-only-2-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-infnan-im-2)
       (then
        (return ($parse-complex-infnan-im-2-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-unit-im)
       (then
        (return ($parse-unit-im-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-infnan)
       (then
        (return ($parse-infnan-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-infnan-im)
       (then
        (return ($parse-infnan-im-value $text $end))))

   (unreachable))

 (func $parse-full-complex-2-value (debug (export "parse-full-complex-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)
   (local $im i32)
   (local $is-negative-im i32)
   (local $re i32)
   (local $rule-id i32)

   (set! $rule-id
         (set! $end-match
               ($lex-match-real-2 $text $end)))

   (set! $re
         (if (result i32) (i32.eq $rule-id _lex-rule-infnan)
           (then ($parse-infnan-value $text $end-match))
           (else ($parse-real-2-value $text $end-match))))

   (set! $is-negative-im (i32.eq ($get-string-char $end-match) _char-minus))

   (set! $text (i32.add $end-match (i32.const 1)))

   (set! $rule-id
         (set! $end-match
               ($lex-match-ureal-2 $text $end)))

   (set! $im
         (if (result i32) (i32.eq $rule-id _lex-rule-uinteger-2)
           (then ($parse-uinteger-2-value $text $end-match))
           (else ($parse-urational-2-value $text $end-match))))

   (if $is-negative-im
       (then
        (set! $im ($negate-number $im))))

   ($make-complex $re $im))

 (func $parse-complex-polar-2-value (debug (export "parse-complex-polar-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $magnitude f64)
   (local $end-match i32)
   (local $arg f64)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-2 $text $end)))

   (set! $magnitude ($coerce-f64 ($parse-real-2-value $text $end-match)))

   (set! $arg ($coerce-f64 ($parse-real-2-value (i32.add $end-match (i32.const 1)) $end)))

   (set! $re ($make-boxed-f64 (f64.mul $magnitude ($cos $arg))))

   ($make-complex
    $re
    ($make-boxed-f64 (f64.mul $magnitude ($sin $arg)))))

 (func $parse-complex-unit-im-2-value (debug (export "parse-complex-unit-im-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-2 $text $end)))

   (set! $re ($parse-real-2-value $text $end-match))

   ($make-complex $re
                  ($make-small-integer
                   (if (result i32) (i32.eq ($get-string-char $end-match) _char-plus)
                     (then (i32.const 1))
                     (else (i32.const -1))))))

 (func $parse-complex-im-only-2-value (debug (export "parse-complex-im-only-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   ($make-complex ($make-small-integer (i32.const 0))
                  ($parse-signed-real-2-value $text
                                              (i32.sub $end (i32.const 1)))))

 (func $parse-complex-infnan-im-2-value (debug (export "parse-complex-infnan-im-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-2 $text $end)))

   (set! $re ($parse-real-2-value $text $end-match))

   ($make-complex $re ($parse-infnan-value $end-match $end)))

 (func $parse-real-2-value (debug (export "parse-real-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $rule-id i32)

   (set! $rule-id
         (drop ;; end
          ($lex-match-real-2 $text $end)))

   (if (result i32) (i32.eq $rule-id _lex-rule-signed-real-2)
     (then
      ($parse-signed-real-2-value $text $end))
     (else
      ($parse-infnan-value $text $end))))

 (func $parse-signed-real-2-value (debug (export "parse-signed-real-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $start i32)
   (local $rule-id i32)
   (local $value i32)

   (set! $start $text)

   (drop ;; rule-id
    (set! $text ($lex-match-sign $text $end)))

   (set! $rule-id
         (drop ;; end
          ($lex-match-ureal-2 $text $end)))

   (set! $value
         (if (result i32) (i32.eq $rule-id _lex-rule-uinteger-2)
           (then
            ($parse-uinteger-2-value $text $end))
           (else
            ($parse-urational-2-value $text $end))))

   (if (i32.eq ($get-string-char $start) _char-minus)
       (then
        (set! $value ($negate-number $value))))

   $value)

 (func $parse-urational-2-value (debug (export "parse-urational-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)

   (drop ;; rule-id
    (set! $end-match
          ($lex-match-uinteger-2 $text $end)))

   ($make-rational ($parse-uinteger-2-value $text $end-match)
                   ($parse-uinteger-2-value (i32.add $end-match (i32.const 1)) $end)))

 (func $parse-uinteger-2-value (debug (export "parse-uinteger-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $length i32)
   (set! $length (i32.sub $end $text))

   (if (i32.lt_u $length (i32.const 29))
       (then
        ;; 1-28 bits will fit in a 29-bit (signed) tagged small integer
        (return ($parse-small-uinteger-2-value $text $end))))

   (if (i32.lt_u $length (i32.const 64))
       (then
        ;; 29-63 bits will fit in an i64
        (return ($parse-i64-uinteger-2-value $text $end))))

   ;; >= 64 bits
   ($parse-integer-uintger-2-value $text $end))

 (func $parse-small-uinteger-2-value (debug (export "parse-small-uinteger-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $char i32)
   (local $value i32)

   (set! $value (i32.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $value (i32.add (i32.shl $value (i32.const 1)) (i32.eq $char _char-1)))

          (%incr i32 $text)
          (br $again))))

   ($make-small-integer $value))

 (func $parse-i64-uinteger-2-value (debug (export "parse-i64-uinteger-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $char i32)
   (local $value i64)

   (set! $value (i64.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $value (i64.add (i64.shl $value (i64.const 1))
                                (i64.extend_i32_u (i32.eq $char _char-1))))

          (%incr i32 $text)
          (br $again))))

   ($make-boxed-i64 $value))

 (func $parse-integer-uintger-2-value (debug (export "parse-integer-uinteger-2-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $accum i64)
   (local $bit-length i32)
   (local $char i32)
   (local $value i32)

   (set! $bit-length (i32.sub $end $text))

   ;; normally, we'd have (x + 63) >> 6, but here we need to allow for a sign
   ;; bit as well, so it becomes (x + 64) >> 6 = (x >> 6) + 1.
   (set! $value ($alloc-integer (i32.add (i32.shr_u $bit-length (i32.const 6))
                                         (i32.const 1))))

   (set! $accum (i64.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $accum (i64.add (i64.shl $accum (i64.const 1))
                                (i64.extend_i32_u (i32.eq $char _char-1))))

          (if (i32.eqz (i32.and $bit-length (i32.const 0x3f)))
              (then
               ($set-integer-i64-digit $value (i32.shr_u $bit-length (i32.const 6)) $accum)
               (set! $accum (i64.const 0))))

          (%incr i32 $text)
          (%decr i32 $bit-length)
          (br $again))))

   $value)

 (func $parse-num-8 (debug (export "parse-num-8"))
   (param $text i32)
   (param $end i32)

   (local $number-start i32)
   (local $rule-id i32)
   (local $value i32)

   (drop ;; rule-id
    (set! $number-start ($lex-match-prefix-8 $text $end)))

   (set! $value ($parse-num-8-value $number-start $end))

   ($append-value (if (result i32) (i32.ne ($parse-exactness-value $text $number-start)
                                           _inexact)
                    (then $value)
                    (else ($to-inexact $value)))))

 (func $parse-num-8-value (debug (export "parse-num-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $rule-id i32)

   (set! $rule-id
         (drop ;; end
          ($lex-match-complex-8 $text $end)))

   (if (i32.eq $rule-id _lex-rule-signed-real-8)
       (then
        (return ($parse-signed-real-8-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-full-complex-8)
       (then
        (return ($parse-full-complex-8-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-polar-8)
       (then
        (return ($parse-complex-polar-8-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-unit-im-8)
       (then
        (return ($parse-complex-unit-im-8-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-im-only-8)
       (then
        (return ($parse-complex-im-only-8-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-infnan-im-8)
       (then
        (return ($parse-complex-infnan-im-8-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-unit-im)
       (then
        (return ($parse-unit-im-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-infnan)
       (then
        (return ($parse-infnan-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-infnan-im)
       (then
        (return ($parse-infnan-im-value $text $end))))

   (unreachable))

 (func $parse-full-complex-8-value (debug (export "parse-full-complex-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)
   (local $im i32)
   (local $is-negative-im i32)
   (local $re i32)
   (local $rule-id i32)

   (set! $rule-id
         (set! $end-match
               ($lex-match-real-8 $text $end)))

   (set! $re
         (if (result i32) (i32.eq $rule-id _lex-rule-infnan)
           (then ($parse-infnan-value $text $end-match))
           (else ($parse-real-8-value $text $end-match))))

   (set! $is-negative-im (i32.eq ($get-string-char $end-match) _char-minus))

   (set! $text (i32.add $end-match (i32.const 1)))

   (set! $rule-id
         (set! $end-match
               ($lex-match-ureal-8 $text $end)))

   (set! $im
         (if (result i32) (i32.eq $rule-id _lex-rule-uinteger-8)
           (then ($parse-uinteger-8-value $text $end-match))
           (else ($parse-urational-8-value $text $end-match))))

   (if $is-negative-im
       (then
        (set! $im ($negate-number $im))))

   ($make-complex $re $im))

 (func $parse-complex-polar-8-value (debug (export "parse-complex-polar-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $magnitude f64)
   (local $end-match i32)
   (local $arg f64)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-8 $text $end)))

   (set! $magnitude ($coerce-f64 ($parse-real-8-value $text $end-match)))

   (set! $arg ($coerce-f64 ($parse-real-8-value (i32.add $end-match (i32.const 1)) $end)))

   (set! $re ($make-boxed-f64 (f64.mul $magnitude ($cos $arg))))

   ($make-complex
    $re
    ($make-boxed-f64 (f64.mul $magnitude ($sin $arg)))))

 (func $parse-complex-unit-im-8-value (debug (export "parse-complex-unit-im-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-8 $text $end)))

   (set! $re ($parse-real-8-value $text $end-match))

   ($make-complex $re
                  ($make-small-integer
                   (if (result i32) (i32.eq ($get-string-char $end-match) _char-plus)
                     (then (i32.const 1))
                     (else (i32.const -1))))))

 (func $parse-complex-im-only-8-value (debug (export "parse-complex-im-only-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   ($make-complex ($make-small-integer (i32.const 0))
                  ($parse-signed-real-8-value $text
                                              (i32.sub $end (i32.const 1)))))

 (func $parse-complex-infnan-im-8-value (debug (export "parse-complex-infnan-im-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-8 $text $end)))

   (set! $re ($parse-real-8-value $text $end-match))

   ($make-complex $re ($parse-infnan-value $end-match $end)))

 (func $parse-real-8-value (debug (export "parse-real-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $rule-id i32)

   (set! $rule-id
         (drop ;; end
          ($lex-match-real-8 $text $end)))

   (if (result i32) (i32.eq $rule-id _lex-rule-signed-real-8)
     (then
      ($parse-signed-real-8-value $text $end))
     (else
      ($parse-infnan-value $text $end))))

 (func $parse-signed-real-8-value (debug (export "parse-signed-real-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $start i32)
   (local $rule-id i32)
   (local $value i32)

   (set! $start $text)

   (drop ;; rule-id
    (set! $text ($lex-match-sign $text $end)))

   (set! $rule-id
         (drop ;; end
          ($lex-match-ureal-8 $text $end)))

   (set! $value
         (if (result i32) (i32.eq $rule-id _lex-rule-uinteger-8)
           (then
            ($parse-uinteger-8-value $text $end))
           (else
            ($parse-urational-8-value $text $end))))

   (if (i32.eq ($get-string-char $start) _char-minus)
       (then
        (set! $value ($negate-number $value))))

   $value)

 (func $parse-urational-8-value (debug (export "parse-urational-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)

   (drop ;; rule-id
    (set! $end-match
          ($lex-match-uinteger-8 $text $end)))

   ($make-rational ($parse-uinteger-8-value $text $end-match)
                   ($parse-uinteger-8-value (i32.add $end-match (i32.const 1)) $end)))

 (func $parse-uinteger-8-value (debug (export "parse-uinteger-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $length i32)
   (set! $length (i32.sub $end $text))

   (if (i32.lt_u $length (i32.const 10))
       (then
        ;; 1-28 bits will fit in a 29-bit (signed) tagged small integer
        (return ($parse-small-uinteger-8-value $text $end))))

   ;; todo
   (if (i32.lt_u $length (i32.const 64))
       (then
        ;; 29-63 bits will fit in an i64
        (return ($parse-i64-uinteger-8-value $text $end))))

   ;; >= 64 bits
   ($parse-integer-uintger-8-value $text $end))

 (func $parse-small-uinteger-8-value (debug (export "parse-small-uinteger-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $char i32)
   (local $value i32)

   (set! $value (i32.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $value (i32.add (i32.shl $value (i32.const 3)) (i32.sub $char _char-0)))

          (%incr i32 $text)
          (br $again))))

   ($make-small-integer $value))

 (func $parse-i64-uinteger-8-value (debug (export "parse-i64-uinteger-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $char i32)
   (local $value i64)

   (set! $value (i64.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $value (i64.add (i64.shl $value (i64.const 3))
                                (i64.extend_i32_u (i32.sub $char _char-0))))

          (%incr i32 $text)
          (br $again))))

   ($make-boxed-i64 $value))

 (func $parse-integer-uintger-8-value (debug (export "parse-integer-uinteger-8-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $accum i64)
   (local $bit-length i32)
   (local $char i32)
   (local $value i32)

   (set! $bit-length (i32.mul (i32.sub $end $text) (i32.const 3)))

   ;; normally, we'd have (x + 63) >> 6, but here we need to allow for a sign
   ;; bit as well, so it becomes (x + 64) >> 6 = (x >> 6) + 1.
   (set! $value ($alloc-integer (i32.add (i32.shr_u $bit-length (i32.const 6))
                                         (i32.const 1))))

   (set! $accum (i64.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $accum (i64.add (i64.shl $accum (i64.const 3))
                                (i64.extend_i32_u (i32.sub $char _char-0))))

          ;; todo
          (if (i32.eqz (i32.and $bit-length (i32.const 0x3f)))
              (then
               ($set-integer-i64-digit $value (i32.shr_u $bit-length (i32.const 6)) $accum)
               (set! $accum (i64.const 0))))

          (%incr i32 $text)
          (%decr-n i32 $bit-length 3)
          (br $again))))

   $value)

 (func $parse-num-10 (debug (export "parse-num-10"))
   (param $text i32)
   (param $end i32)

   (local $exactness i32)
   (local $number-start i32)
   (local $rule-id i32)
   (local $value i32)

   (drop ;; rule-id
    (set! $number-start ($lex-match-prefix-10 $text $end)))

   (set! $exactness ($parse-exactness-value $text $number-start))

   (set! $value ($parse-num-10-value $number-start $end $exactness))

   ($append-value (if (result i32) (i32.ne $exactness _inexact)
                    (then $value)
                    (else ($to-inexact $value)))))

 (func $parse-num-10-value (debug (export "parse-num-10-value"))
   (param $text i32)
   (param $end i32)
   (param $exactness i32)
   (result i32)

   (local $rule-id i32)

   (set! $rule-id
         (drop ;; end
          ($lex-match-complex-10 $text $end)))

   (if (i32.eq $rule-id _lex-rule-signed-real-10)
       (then
        (return ($parse-signed-real-10-value $text $end $exactness))))

   (if (i32.eq $rule-id _lex-rule-full-complex-10)
       (then
        (return ($parse-full-complex-10-value $text $end $exactness))))

   (if (i32.eq $rule-id _lex-rule-complex-polar-10)
       (then
        (return ($parse-complex-polar-10-value $text $end $exactness))))

   (if (i32.eq $rule-id _lex-rule-complex-unit-im-10)
       (then
        (return ($parse-complex-unit-im-10-value $text $end $exactness))))

   (if (i32.eq $rule-id _lex-rule-complex-im-only-10)
       (then
        (return ($parse-complex-im-only-10-value $text $end $exactness))))

   (if (i32.eq $rule-id _lex-rule-complex-infnan-im-10)
       (then
        (return ($parse-complex-infnan-im-10-value $text $end $exactness))))

   (if (i32.eq $rule-id _lex-rule-unit-im)
       (then
        (return ($parse-unit-im-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-infnan)
       (then
        (return ($parse-infnan-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-infnan-im)
       (then
        (return ($parse-infnan-im-value $text $end))))

   (unreachable))

 (func $parse-full-complex-10-value (debug (export "parse-full-complex-10-value"))
   (param $text i32)
   (param $end i32)
   (param $exactness i32)
   (result i32)

   (local $end-match i32)
   (local $im i32)
   (local $is-negative-im i32)
   (local $re i32)
   (local $rule-id i32)

   (set! $rule-id
         (set! $end-match
               ($lex-match-real-10 $text $end)))

   (set! $re
         (if (result i32) (i32.eq $rule-id _lex-rule-infnan)
           (then ($parse-infnan-value $text $end-match))
           (else ($parse-real-10-value $text $end-match $exactness))))

   (set! $is-negative-im (i32.eq ($get-string-char $end-match) _char-minus))

   (set! $text (i32.add $end-match (i32.const 1)))

   (set! $rule-id
         (set! $end-match
               ($lex-match-ureal-10 $text $end)))

   (set! $im
         (if (result i32) (i32.eq $rule-id _lex-rule-uinteger-10)
           (then ($parse-uinteger-10-value $text $end-match))
           (else ($parse-urational-10-value $text $end-match))))

   (if $is-negative-im
       (then
        (set! $im ($negate-number $im))))

   ($make-complex $re $im))

 (func $parse-complex-polar-10-value (debug (export "parse-complex-polar-10-value"))
   (param $text i32)
   (param $end i32)
   (param $exactness i32)
   (result i32)

   (local $magnitude f64)
   (local $end-match i32)
   (local $arg f64)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-10 $text $end)))

   (set! $magnitude ($coerce-f64 ($parse-real-10-value $text $end-match $exactness)))

   (set! $arg ($coerce-f64 ($parse-real-10-value (i32.add $end-match (i32.const 1))
                                                 $end
                                                 $exactness)))

   (set! $re ($make-boxed-f64 (f64.mul $magnitude ($cos $arg))))

   ($make-complex $re ($make-boxed-f64 (f64.mul $magnitude ($sin $arg)))))

 (func $parse-complex-unit-im-10-value (debug (export "parse-complex-unit-im-10-value"))
   (param $text i32)
   (param $end i32)
   (param $exactness i32)
   (result i32)

   (local $end-match i32)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-10 $text $end)))

   (set! $re ($parse-real-10-value $text $end-match $exactness))

   ($make-complex $re
                  ($make-small-integer
                   (if (result i32) (i32.eq ($get-string-char $end-match) _char-plus)
                     (then (i32.const 1))
                     (else (i32.const -1))))))

 (func $parse-complex-im-only-10-value (debug (export "parse-complex-im-only-10-value"))
   (param $text i32)
   (param $end i32)
   (param $exactness i32)
   (result i32)

   ($make-complex ($make-small-integer (i32.const 0))
                  ($parse-signed-real-10-value $text
                                               (i32.sub $end (i32.const 1))
                                               $exactness)))

 (func $parse-complex-infnan-im-10-value (debug (export "parse-complex-infnan-im-10-value"))
   (param $text i32)
   (param $end i32)
   (param $exactness i32)
   (result i32)

   (local $end-match i32)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-10 $text $end)))

   (set! $re ($parse-real-10-value $text $end-match $exactness))

   ($make-complex $re ($parse-infnan-value $end-match $end)))

 (func $parse-real-10-value (debug (export "parse-real-10-value"))
   (param $text i32)
   (param $end i32)
   (param $exactness i32)
   (result i32)

   (local $rule-id i32)

   (set! $rule-id
         (drop ;; end
          ($lex-match-real-10 $text $end)))

   (if (result i32) (i32.eq $rule-id _lex-rule-signed-real-10)
     (then
      ($parse-signed-real-10-value $text $end $exactness))
     (else
      ($parse-infnan-value $text $end))))

 (func $parse-signed-real-10-value (debug (export "parse-signed-real-10-value"))
   (param $text i32)
   (param $end i32)
   (param $exactness i32)
   (result i32)

   (local $start i32)
   (local $rule-id i32)
   (local $value i32)

   (set! $start $text)

   (drop ;; rule-id
    (set! $text ($lex-match-sign $text $end)))

   (set! $rule-id
         (drop ;; end
          ($lex-match-ureal-10 $text $end)))

   (set! $value
         (if (result i32) (i32.eq $rule-id _lex-rule-uinteger-10)
           (then
            ($parse-uinteger-10-value $text $end))
           (else
            (if (result i32) (i32.eq $rule-id _lex-rule-urational-10)
              (then
               ($parse-urational-10-value $text $end))
              (else
               ($parse-decimal-10-value $text $end $exactness))))))

   (if (i32.eq ($get-string-char $start) _char-minus)
       (then
        (set! $value ($negate-number $value))))

   $value)

 (func $parse-urational-10-value (debug (export "parse-urational-10-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)

   (drop ;; rule-id
    (set! $end-match
          ($lex-match-uinteger-10 $text $end)))

   ($make-rational ($parse-uinteger-10-value $text $end-match)
                   ($parse-uinteger-10-value (i32.add $end-match (i32.const 1)) $end)))

 ;; max positive i64 divided by 10.
 (define _max-significand (i64.const 0x0ccccccccccccccc))

 (func $parse-decimal-10-value (debug (export "parse-decimal-10-value"))
   (param $text i32)
   (param $end i32)
   (param $exactness i32)
   (result i32)

   (local $char i32)
   (local $decimal-point i32)
   (local $end-match i32)
   (local $end-significand i32)
   (local $exp i32)
   (local $exp-digits i32)
   (local $exp-pow-10 f64)
   (local $exp-start i32)
   (local $exp-value i32)
   (local $fractional-digits i32)
   (local $scan i32)
   (local $significand i64)

   (drop ;; rule-id
    (set! $end-match
          ($lex-match-decimal-10-forms $text $end)))

   (set! $scan $text)
   (set! $significand (i64.const 0))
   (set! $decimal-point _null)

   (loop $scan-significand
     (if (i32.and (i32.lt_u $scan $end-match)
                  (i64.lt_u $significand _max-significand))
         (then
          (set! $char ($get-string-char $scan))
          (if (i32.eq $char _char-dot)
              (then
               (set! $decimal-point $scan))
            (else
             (set! $significand (i64.add (i64.mul $significand (i64.const 10))
                                         (i64.extend_i32_u (i32.sub $char _char-0))))))

          (%incr i32 $scan)
          (br $scan-significand))))

   (set! $end-significand $scan)

   (if (i32.eq $decimal-point _null)
       (then
        (loop $scan-decimal-point
          (if (i32.lt_u $scan $end-match)
              (then
               (set! $char ($get-string-char $scan))
               (if (i32.eq $char _char-dot)
                   (then
                    (set! $decimal-point (i32.sub $scan (i32.const 1))))
                 (else
                  (%incr i32 $scan)
                  (br $scan-decimal-point))))))))

   (set! $fractional-digits (if (result i32) (i32.eq $decimal-point _null)
                              (then (i32.const 0))
                              (else (i32.sub (i32.sub $end-significand $decimal-point)
                                             (i32.const 1)))))

   (if (i32.eq $end $end-match)
       (then
        (set! $exp-pow-10 ($pow-10-f64 (i32.sub (i32.const 0) $fractional-digits))))

     (else
      ;; parse suffix: e+25, for example

      (set! $exp-start (i32.add $end-match (i32.const 1)))

      (drop ;; rule-id
       (set! $exp-digits
             ($lex-match-sign $exp-start $end)))

      (set! $exp-value ($parse-uinteger-10-value $exp-digits $end))

      (if (i32.and (i32.gt_u $exp-digits $exp-start)
                   (i32.eq ($get-string-char $exp-start) _char-minus))
          (then
           (set! $exp-value ($negate-number $exp-value))))

      (if (%is-small-integer $exp-value)
          (then

           (set! $exp-pow-10 ($pow-10-f64 (i32.sub (%get-small-integer-value $exp-value)
                                                   $fractional-digits))))
        (else
         ($dealloc-number $exp)
         ;; todo handle negative
         (set! $exp-pow-10 (f64.const +inf))))))

   ;; todo: (big) integer multiplication and division will make this more
   ;; accurate.

   ($make-boxed-f64 (f64.mul (f64.convert_i64_u $significand) $exp-pow-10)))

 (func $pow-10-f64 (debug (export "pow-10-f64"))
   (param $n i32)
   (result f64)

   (local $is-negative i32)
   (local $result f64)

   (set! $is-negative (i32.lt_s $n (i32.const 0)))

   (if $is-negative
       (then (set! $n (i32.sub (i32.const 0) $n))))

   (if (i32.and $n (i32.const 0x0ffffe00))
       (then
        (set! $result (f64.const +inf)))

     (else

      (set! $result (if (result f64) (i32.and $n (i32.const 0x01))
                      (then (f64.const 10.0))
                      (else (f64.const 1.0))))

      ;; unrolled loop
      (if (i32.and $n (i32.const 0x02))
          (then
           (set! $result (f64.mul $result (f64.const 100.0)))))

      (if (i32.and $n (i32.const 0x04))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e4)))))

      (if (i32.and $n (i32.const 0x08))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e8)))))

      (if (i32.and $n (i32.const 0x10))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e16)))))

      (if (i32.and $n (i32.const 0x20))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e32)))))

      (if (i32.and $n (i32.const 0x40))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e64)))))

      (if (i32.and $n (i32.const 0x80))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e128)))))

      (if (i32.and $n (i32.const 0x100))
          (then
           (set! $result (f64.mul $result (f64.const 1.0e256)))))))

   (if $is-negative
       (then
        (set! $result (f64.div (f64.const 1.0) $result))))

   $result)

 (func $parse-uinteger-10-value (debug (export "parse-uinteger-10-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $length i32)
   (set! $length (i32.sub $end $text))

   (if (i32.lt_u $length (i32.const 9))
       (then
        ;; 1-28 bits will fit in a 29-bit (signed) tagged small integer
        (return ($parse-small-uinteger-10-value $text $end))))

   ;; todo
   (if (i32.lt_u $length (i32.const 64))
       (then
        ;; 29-63 bits will fit in an i64
        (return ($parse-i64-uinteger-10-value $text $end))))

   ;; >= 64 bits
   ($parse-integer-uintger-10-value $text $end))

 (func $parse-small-uinteger-10-value (debug (export "parse-small-uinteger-10-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $char i32)
   (local $value i32)

   (set! $value (i32.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $value (i32.add (i32.add (i32.shl $value (i32.const 3))
                                         (i32.shl $value (i32.const 1)))
                                 (i32.sub $char _char-0)))

          (%incr i32 $text)
          (br $again))))

   ($make-small-integer $value))

 (func $parse-i64-uinteger-10-value (debug (export "parse-i64-uinteger-10-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $char i32)
   (local $value i64)

   (set! $value (i64.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $value (i64.add (i64.add (i64.shl $value (i64.const 3))
                                         (i64.shl $value (i64.const 1)))
                                (i64.extend_i32_u (i32.sub $char _char-0))))

          (%incr i32 $text)
          (br $again))))

   ($make-boxed-i64 $value))

 (func $parse-integer-uintger-10-value (debug (export "parse-integer-uinteger-10-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $accum i64)
   (local $bit-length i32)
   (local $char i32)
   (local $value i32)

   ;; todo
   (set! $bit-length (i32.sub $end $text))

   ;; normally, we'd have (x + 63) >> 6, but here we need to allow for a sign
   ;; bit as well, so it becomes (x + 64) >> 6 = (x >> 6) + 1.
   (set! $value ($alloc-integer (i32.add (i32.shr_u $bit-length (i32.const 6))
                                         (i32.const 1))))

   (set! $accum (i64.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $accum (i64.add (i64.add (i64.shl $accum (i64.const 3))
                                         (i64.shl $accum (i64.const 1)))
                                (i64.extend_i32_u (i32.sub $char _char-0))))

          ;; todo
          (if (i32.eqz (i32.and $bit-length (i32.const 0x3f)))
              (then
               ($set-integer-i64-digit $value (i32.shr_u $bit-length (i32.const 6)) $accum)
               (set! $accum (i64.const 0))))

          (%incr i32 $text)
          ;;todo
          (%decr i32 $bit-length)
          (br $again))))

   $value)

 (func $parse-num-16 (debug (export "parse-num-16"))
   (param $text i32)
   (param $end i32)

   (local $number-start i32)
   (local $rule-id i32)
   (local $value i32)

   (drop ;; rule-id
    (set! $number-start ($lex-match-prefix-16 $text $end)))

   (set! $value ($parse-num-16-value $number-start $end))

   ($append-value (if (result i32) (i32.ne ($parse-exactness-value $text $number-start)
                                           _inexact)
                    (then $value)
                    (else ($to-inexact $value)))))

 (func $parse-num-16-value (debug (export "parse-num-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $rule-id i32)

   (set! $rule-id
         (drop ;; end
          ($lex-match-complex-16 $text $end)))

   (if (i32.eq $rule-id _lex-rule-signed-real-16)
       (then
        (return ($parse-signed-real-16-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-full-complex-16)
       (then
        (return ($parse-full-complex-16-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-polar-16)
       (then
        (return ($parse-complex-polar-16-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-unit-im-16)
       (then
        (return ($parse-complex-unit-im-16-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-im-only-16)
       (then
        (return ($parse-complex-im-only-16-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-complex-infnan-im-16)
       (then
        (return ($parse-complex-infnan-im-16-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-unit-im)
       (then
        (return ($parse-unit-im-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-infnan)
       (then
        (return ($parse-infnan-value $text $end))))

   (if (i32.eq $rule-id _lex-rule-infnan-im)
       (then
        (return ($parse-infnan-im-value $text $end))))

   (unreachable))

 (func $parse-full-complex-16-value (debug (export "parse-full-complex-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)
   (local $im i32)
   (local $is-negative-im i32)
   (local $re i32)
   (local $rule-id i32)

   (set! $rule-id
         (set! $end-match
               ($lex-match-real-16 $text $end)))

   (set! $re
         (if (result i32) (i32.eq $rule-id _lex-rule-infnan)
           (then ($parse-infnan-value $text $end-match))
           (else ($parse-real-16-value $text $end-match))))

   (set! $is-negative-im (i32.eq ($get-string-char $end-match) _char-minus))

   (set! $text (i32.add $end-match (i32.const 1)))

   (set! $rule-id
         (set! $end-match
               ($lex-match-ureal-16 $text $end)))

   (set! $im
         (if (result i32) (i32.eq $rule-id _lex-rule-uinteger-16)
           (then ($parse-uinteger-16-value $text $end-match))
           (else ($parse-urational-16-value $text $end-match))))

   (if $is-negative-im
       (then
        (set! $im ($negate-number $im))))

   ($make-complex $re $im))

 (func $parse-complex-polar-16-value (debug (export "parse-complex-polar-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $magnitude f64)
   (local $end-match i32)
   (local $arg f64)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-16 $text $end)))

   (set! $magnitude ($coerce-f64 ($parse-real-16-value $text $end-match)))

   (set! $arg ($coerce-f64 ($parse-real-16-value (i32.add $end-match (i32.const 1)) $end)))

   (set! $re ($make-boxed-f64 (f64.mul $magnitude ($cos $arg))))

   ($make-complex $re ($make-boxed-f64 (f64.mul $magnitude ($sin $arg)))))

 (func $parse-complex-unit-im-16-value (debug (export "parse-complex-unit-im-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-16 $text $end)))

   (set! $re ($parse-real-16-value $text $end-match))

   ($make-complex $re
                  ($make-small-integer
                   (if (result i32) (i32.eq ($get-string-char $end-match) _char-plus)
                     (then (i32.const 1))
                     (else (i32.const -1))))))

 (func $parse-complex-im-only-16-value (debug (export "parse-complex-im-only-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   ($make-complex ($make-small-integer (i32.const 0))
                  ($parse-signed-real-16-value $text
                                               (i32.sub $end (i32.const 1)))))

 (func $parse-complex-infnan-im-16-value (debug (export "parse-complex-infnan-im-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)
   (local $re i32)

   (drop ;; rule-id
    (set! $end-match ($lex-match-real-16 $text $end)))

   (set! $re ($parse-real-16-value $text $end-match))

   ($make-complex $re ($parse-infnan-value $end-match $end)))

 (func $parse-real-16-value (debug (export "parse-real-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $rule-id i32)

   (set! $rule-id
         (drop ;; end
          ($lex-match-real-16 $text $end)))

   (if (result i32) (i32.eq $rule-id _lex-rule-signed-real-16)
     (then
      ($parse-signed-real-16-value $text $end))
     (else
      ($parse-infnan-value $text $end))))

 (func $parse-signed-real-16-value (debug (export "parse-signed-real-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $start i32)
   (local $rule-id i32)
   (local $value i32)

   (set! $start $text)

   (drop ;; rule-id
    (set! $text ($lex-match-sign $text $end)))

   (set! $rule-id
         (drop ;; end
          ($lex-match-ureal-16 $text $end)))

   (set! $value
         (if (result i32) (i32.eq $rule-id _lex-rule-uinteger-16)
           (then
            ($parse-uinteger-16-value $text $end))
           (else
            ($parse-urational-16-value $text $end))))

   (if (i32.eq ($get-string-char $start) _char-minus)
       (then
        (set! $value ($negate-number $value))))

   $value)

 (func $parse-urational-16-value (debug (export "parse-urational-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $end-match i32)

   (drop ;; rule-id
    (set! $end-match
          ($lex-match-uinteger-16 $text $end)))

   ($make-rational ($parse-uinteger-16-value $text $end-match)
                   ($parse-uinteger-16-value (i32.add $end-match (i32.const 1)) $end)))

 (func $parse-uinteger-16-value (debug (export "parse-uinteger-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $length i32)
   (set! $length (i32.sub $end $text))

   (if (i32.lt_u $length (i32.const 8))
       (then
        ;; 1-28 bits will fit in a 29-bit (signed) tagged small integer
        (return ($parse-small-uinteger-16-value $text $end))))

   ;; todo
   (if (i32.lt_u $length (i32.const 64))
       (then
        ;; 29-63 bits will fit in an i64
        (return ($parse-i64-uinteger-16-value $text $end))))

   ;; >= 64 bits
   ($parse-integer-uintger-16-value $text $end))

 (func $parse-small-uinteger-16-value (debug (export "parse-small-uinteger-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $char i32)
   (local $value i32)

   (set! $value (i32.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $value (i32.add (i32.shl $value (i32.const 4)) ($hex-digit-value $char)))

          (%incr i32 $text)
          (br $again))))

   ($make-small-integer $value))

 (func $parse-i64-uinteger-16-value (debug (export "parse-i64-uinteger-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $char i32)
   (local $value i64)

   (set! $value (i64.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $value (i64.add (i64.shl $value (i64.const 4))
                                (i64.extend_i32_u ($hex-digit-value $char))))

          (%incr i32 $text)
          (br $again))))

   ($make-boxed-i64 $value))

 (func $parse-integer-uintger-16-value (debug (export "parse-integer-uinteger-16-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $accum i64)
   (local $bit-length i32)
   (local $char i32)
   (local $value i32)

   (set! $bit-length (i32.sub $end $text))

   ;; normally, we'd have (x + 63) >> 6, but here we need to allow for a sign
   ;; bit as well, so it becomes (x + 64) >> 6 = (x >> 6) + 1.
   (set! $value ($alloc-integer (i32.add (i32.shr_u $bit-length (i32.const 6))
                                         (i32.const 1))))

   (set! $accum (i64.const 0))

   (loop $again
     (if (i32.ne $text $end)
         (then
          (set! $char ($get-string-char $text))
          (set! $accum (i64.add (i64.shl $accum (i64.const 4))
                                (i64.extend_i32_u ($hex-digit-value $char))))

          (if (i32.eqz (i32.and $bit-length (i32.const 0x3f)))
              (then
               ($set-integer-i64-digit $value (i32.shr_u $bit-length (i32.const 6)) $accum)
               (set! $accum (i64.const 0))))

          (%incr i32 $text)
          (%decr i32 $bit-length)
          (br $again))))

   $value)

 (func $hex-digit-value (debug (export "hex-digit-value"))
   (param $char i32)
   (result i32)

   (if (result i32) (i32.le_u $char _char-9)
     (then (i32.sub $char _char-0))
     (else
      (i32.add (i32.const 10)
               (if (result i32) (i32.le_u $char _char-F)
                 (then (i32.sub $char _char-A))
                 (else (i32.sub $char _char-a)))))))

 (func $parse-exactness-value (debug (export "parse-exactness-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $length i32)

   (set! $length (i32.sub $end $text))

   (if (i32.or (i32.and $length (i32.const 1))
               (i32.gt_u $length (i32.const 4)))
       (then
        (unreachable)))

   (loop $again
     (if (i32.eq $text $end)
       (then
        (return _no-exactness)))

     (if ($match-exact-prefix $text $end)
         (then (return _exact)))

     (if ($match-inexact-prefix $text $end)
         (then (return _inexact)))

     (%incr-n i32 $text 2)
     (br $again))

   (unreachable))

 (func $match-exact-prefix (debug (export "match-exact-prefix"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (i32.ne _null ($match-string/ascii-ci (%string-exact-prefix) $text $end)))

 (func $match-inexact-prefix (debug (export "match-inexact-prefix"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (i32.ne _null ($match-string/ascii-ci (%string-inexact-prefix) $text $end)))

 (func $parse-infnan-im-value (debug (export "parse-infnan-im-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   ($make-complex ($make-small-integer (i32.const 0))
                  ($parse-infnan-value $text $end)))

 (func $parse-infnan-value (debug (export "parse-infnan-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   (local $initial i32)

   (set! $initial ($ascii-lower ($get-string-char (i32.add $text (i32.const 1)))))

   ($make-boxed-f64 (if (result f64) (i32.eq ($get-string-char $text) _char-plus)
                      (then
                       (if (result f64) (i32.eq $initial _char-i)
                         (then (f64.const +inf))
                         (else (f64.const +nan))))
                      (else
                       (if (result f64) (i32.eq $initial _char-i)
                         (then (f64.const -inf))
                         (else (f64.const -nan)))))))

 (func $parse-unit-im-value (debug (export "parse-unit-im-value"))
   (param $text i32)
   (param $end i32)
   (result i32)

   ($make-complex ($make-small-integer (i32.const 0))
                  ($make-small-integer
                   (if (result i32) (i32.eq ($get-string-char $text) _char-plus)
                     (then (i32.const 1))
                     (else (i32.const -1)))))))

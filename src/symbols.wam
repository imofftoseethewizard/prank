(module

 ;; Symbols are offsets into an array of string references, deduplicated by a
 ;; simple hash table using the string contents.

 (import "strings" "dealloc-string"   (func $dealloc-string (param i32)   ))
 (import "strings" "string-equal"     (func $string-equal   (param i32 i32)     (result i32)))
 (import "strings" "hash-string"      (func $hash-string    (param i32)         (result i32)))

 (include "./constants.wam")
 (include "./globals.wam")
 (include "./values.wam")

 (memory (debug (export "memory")) 1)

 (const #entry-size      8)
 (const #entry-size-bits 3)

 (global $hash-offset-mask      (debug (export "hash-offset-mask"))      (mut i32) (i32.const 0))
 (global $hash-table-addr       (debug (export "hash-table-addr"))       (mut i32) (i32.const 0))
 (global $symbol-count          (debug (export "symbol-count"))          (mut i32) (i32.const 0))
 (global $symbol-table-capacity (debug (export "symbol-table-capacity")) (mut i32) (i32.const 0))
 (global $symbol-table-size     (debug (export "symbol-table-size"))     (mut i32) (i32.const 0))

 (macro %get-hash-offset-mask
   (global.get $hash-offset-mask))

 (macro %get-hash-table-addr
   (global.get $hash-table-addr))

 (macro %get-symbol-count
   (global.get $symbol-count))

 (macro %get-symbol-table-capacity
   (global.get $symbol-table-capacity))

 (macro %get-symbol-table-size
   (global.get $symbol-table-size))

 (macro %set-hash-offset-mask
   (expr ,v)
   (global.set $hash-offset-mask ,v))

 (macro %set-hash-table-addr
   (expr ,v)
   (global.set $hash-table-addr ,v))

 (macro %set-symbol-count
   (expr ,v)
   (global.set $symbol-count ,v))

 (macro %set-symbol-table-capacity
   (expr ,v)
   (global.set $symbol-table-capacity ,v))

 (macro %set-symbol-table-size
   (expr ,v)
   (global.set $symbol-table-size ,v))

 ;; This should be set to be large enough to include all of the symbols required
 ;; to start the base system.  Currently 4K, but actual value TBD.
 (define _initial-table-size           (i32.const 0x10))

 ;; This is used to find the next slot to try when there is a collision
 (define _next-hash-coefficient        (i32.const 1220703125)) ;; 5^13
 (define _next-hash-constant           (i32.const 282475249))  ;; 7^10

 (define _symbol-table-entry-size      (i32.const #entry-size))
 (define _symbol-table-entry-size-bits (i32.const #entry-size-bits))

 (debug
  (global $initial-table-size           (export "initial-table-size")           i32 _initial-table-size)
  (global $next-hash-coefficient        (export "next-hash-coefficient")        i32 _next-hash-coefficient)
  (global $next-hash-constant           (export "next-hash-constant")           i32 _next-hash-constant)
  (global $symbol-table-entry-size      (export "symbol-table-entry-size")      i32 _symbol-table-entry-size)
  (global $symbol-table-entry-size-bits (export "symbol-table-entry-size-bits") i32 _symbol-table-entry-size-bits))


 ;; The capacity of the hash table is 75% of its size.  When it is near full, a
 ;; collision should be expected to happen 75% of the time, and that on average,
 ;; it will take 4 steps to find an empty slot.

 (macro %calc-symbol-table-capacity
   (i32.shr_u (i32.mul (%get-symbol-table-size) (i32.const 3)) (i32.const 2)))

 (macro %calc-hash-offset-mask
   (i32.shl (i32.sub (%get-symbol-table-size) (i32.const 1)) _value-size-bits))

 (macro %get-symbol-name
   (expr ,symbol)
   (i32.load ,symbol))

 (macro %get-symbol-hash
   (expr ,symbol)
   (i32.load (i32.add ,symbol (i32.const _value-size))))

 (macro %calc-hash-offset
   (expr ,hash)
   (i32.and ,hash (%get-hash-offset-mask)))

 (macro %next-hash
   (label $var)
   (set! $var (i32.mul (i32.add $var _next-hash-constant) _next-hash-coefficient)))

 (macro %is-symbol-table-full
   (i32.eq (%get-symbol-count) (%get-symbol-table-capacity)))

 (macro %get-hash-addr
   (expr ,hash)
   (i32.add (%get-hash-table-addr) (%calc-hash-offset ,hash)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Initialization
 ;;

 (start $init-symbols)
 (func $init-symbols (debug (export "init-symbols"))

   (%set-symbol-count (i32.const 0))
   (%set-symbol-table-size _initial-table-size)
   (%set-symbol-table-capacity (%calc-symbol-table-capacity))
   (%set-hash-offset-mask (%calc-hash-offset-mask))

   (%set-hash-table-addr (i32.shl _initial-table-size _symbol-table-entry-size-bits))

   ;; This step is important, as it marks each slot unused.
   (memory.fill
    (%get-hash-table-addr)
    _null
    (i32.shl (%get-symbol-table-size) _value-size-bits)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Make symbol
 ;;
 ;;

 (func $make-symbol (export "make-symbol")
   (param $name i32)
   (result i32)

   (%make-value _tag-symbol ($inter-symbol $name)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Inter symbol
 ;;

 (func $inter-symbol (debug (export "inter-symbol"))

   ;; inter-symbol checks the hash table for the given string.  If it's not
   ;; found, then it is added to the hash table, and the new symbol is returned
   ;; If it is found, then the given string is deallocated, and the existing
   ;; symbol is returned.  The deallocation is due to the fact that in the case
   ;; where the string is not found, either the symbol table needs to own the
   ;; string, or it needs to make a copy, and it's cheaper to simply keep
   ;; ownership.  It would be awkward if the caller had to distinguish between
   ;; new symbols and already present symbols, so it makes sense to keep the
   ;; behavior the same for both branches. The most common case is probably use
   ;; by the parser, where the parser has no use for the string after
   ;; inter-symbol, so it would have to deallocate it anyway.

   (param $name i32)
   (result i32)

   (local $candidate i32)
   (local $h i32)
   (local $hash i32)
   (local $hash-addr i32)
   (local $symbol i32)

   (set! $h ($hash-string $name))
   (set! $hash $h)
   (set! $symbol _null)

   (loop $again
     (set! $hash-addr (%get-hash-addr $h))
     (set! $candidate (i32.load $hash-addr))

     (if (i32.eq $candidate _null)
         (then
          ;; an unused slot means that this string has not yet been interred
          (set! $symbol ($store-symbol $name $hash $hash-addr)))
       (else
        (if ($string-equal $name (%get-symbol-name $candidate))
            (then

             ;; found. This function owns the string, so here we have to be sure
             ;; to deallocate it.
             (set! $symbol $candidate)
             ($dealloc-string $name))
          (else
           (%next-hash $h)
           (br $again))))))

   $symbol)

 (func $store-symbol (debug (export "store-symbol"))
   (param $name i32)
   (param $hash i32)
   (param $hash-addr i32)
   (result i32)

   (local $symbol i32)

   (set! $symbol (i32.shl (%get-symbol-count) _symbol-table-entry-size-bits))

   (%global.incr i32 $symbol-count)

   (i32.store $symbol $name)

   ;; Save the hash here so that when the hash table needs to be rebuilt,
   ;; the strings won't have to be rehashed.

   (i32.store (i32.add $symbol _value-size) $hash)

   ;; If the symbol table is full, then grow-symbol-table will insert the new
   ;; symbol into the hash table as it is rebuilt.  (This is why the symbol
   ;; is inserted there first).  Otherwise, the offset came from the search
   ;; in make symbol, and its the proper place to store it.

   (if (%is-symbol-table-full)
       (then
        ($grow-symbol-table))
     (else
      (i32.store $hash-addr $symbol)))

   $symbol)

 (func $grow-symbol-table (debug (export "grow-symbol-table"))

   (%global.double i32 $symbol-table-size)
   (%set-symbol-table-capacity (%calc-symbol-table-capacity))
   (%set-hash-offset-mask (%calc-hash-offset-mask))

   (%set-hash-table-addr (i32.shl (%get-symbol-table-size) _symbol-table-entry-size-bits))

   (memory.fill (%get-hash-table-addr)
                _null
                (i32.shl (%get-symbol-table-size) _value-size-bits))

   ($rebuild-hash-table))

 (func $rebuild-hash-table (debug (export "rebuild-hash-table"))

   ;; There is nothing extraordinary about this function. It replays the
   ;; insertion of every symbol in the symbol table in the order that they were
   ;; interred.

   (local $addr i32)
   (local $end-symbol i32)
   (local $h i32)
   (local $symbol-hash-addr i32)
   (local $symbol i32)

   (set! $symbol (i32.const 0))
   (set! $end-symbol (i32.shl (%get-symbol-count) _symbol-table-entry-size-bits))

   (set! $symbol-hash-addr (i32.add $symbol _value-size))

   (loop $symbols
     (set! $h (i32.load $symbol-hash-addr))

     (loop $hashes
       (set! $addr (%get-hash-addr $h))

       (if (i32.eq (i32.load $addr) _null)
           (then
            (i32.store $addr $symbol))

         (else
          (%next-hash $h)
          (br $hashes))))

     (if (i32.lt_u $symbol $end-symbol)
         (then
          (%incr-n i32 $symbol #entry-size)
          (%incr-n i32 $symbol-hash-addr #entry-size)
          (br $symbols)))))

 ;; end of module
 )

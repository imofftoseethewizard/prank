;; # Block Allocation Manager
;;
;; This module manages allocation and deallocation of variable-length blocks of
;; memory.It is intended to be used by the bytevectors, numbers, strings,
;; symbols, and vectors modules, and by the garbage collector for its internal
;; indexes.
;;
;;
;; ## Design
;;
;; The simplest memory management policy is static allocation, common on small,
;; embedded devices with limited RAM and functionality.  FORTH uses a slightly
;; more advanced allocation scheme with just a single "dictionary" pointer that
;; increases with each allocation.  One could think of this as static
;; allocation, but incrementally defined.  Beyond that, things get complex
;; quickly.  To support reuse of memory that is no longer needed, we need to
;; track deallocated blocks, and these could be stored in a list, either
;; implemented as a linked list or in a dynamic array.  Typcial distributions of
;; block sizes lead to fragmentation and a loss of memory efficiency.  (There
;; are special cases where this does not apply, such as when all blocks have the
;; same size, or when they have varying sizes, but form a power law
;; distribution, etc).  Further if the number of free blocks grows large, then
;; searching through the list of free blocks for one of a matching size becomes
;; increasingly expensive, or we could maintain a sorted array, but then
;; allocation and free become expensive.  The free list could be recast as a
;; heap, but then we aren't guaranteed to find a block of the correct size, so
;; to maintain computational efficiency we need to allow blocks to be split.
;; Splitting blocks just makes the fragmentation problem worse.  We could
;; coalesce adjacent free blocks, but then we need an ordered data structure
;; again, and we're back to having a free list.  But now the free list needs to
;; be careful not to corrupt the heap when coalescing free blocks.  That still
;; leaves the possibility of small bits of memory lost between larger blocks
;; which have a long lifetime.  To handle that, we need to be able to relocate
;; allocated blocks, but that requires an ordered list of all blocks -- both
;; free and allocated -- and indirection of block id and block storage address.
;; So that's what we have here: indirection of storage address, an ordered list
;; of blocks, an ordered list of free blocks, and a heap of free blocks.
;; Allocation is O(#free^1/2) and deallocation are O(log(#free)).
;; Defragmentation is incremental.
;;
;; ## Data Representation
;;
;; A block is a an address of an item in the block list.  Each block contains
;; the address of the memory it references, the size, and links to the previous
;; and next blocks in the list.
;;
;; A free entry is the address of an item in the free list.  Each free entry
;; contains the address of the block it references, and links to the previous
;; and next entries in the list.
;;
;; The heap is sorted by size and implemented as an array, each element of which
;; comprises two values, the block and the free entry that contains it.  While
;; this block is accessible from the free entry by a single memory dereference,
;; access to the size of the blocks stored in the heap is common within loops in
;; this module, so the extra memory is probably worth it.  (In simulations of
;; memory use of 100MB of blocks of typical struct sizes -- Poisson
;; distribution, expected 5 values of 4 bytes each -- heap sizes typically stay
;; very close to the square root of the number of allocated blocks, around 2500
;; elements, indicating that the extra storage cost was aobut 10KB.)
;;
;; A blockset is an index into an array of structures which capture the state of
;; a client's memory.  These structures include pointers to the block list,
;; free list, heap, and various values necessary for managing memory.
;;
;;
;; ## Memory Access
;;
;; The block allocation manager has no direct access to the memory it manages.
;; It uses its own memory to store the state of each client module, the block
;; lists, free lists, and heaps.  It needs access to client memory when it is
;; attempting to allocate a block larger than any free block in the heap, in
;; which case it uses client proxies memory.size and memory.grow.  It also needs
;; access during defragmentation, when it needs to call a proxy for memory.copy.
;; Access to these instructions is provided through three tables, one for each
;; of the memory functions mentioned.  The client module provides a client id,
;; which is the index into each of the tables for its proxies for the memory it
;; owns.  The clients need to be coordinated to ensure that there are no
;; conflicts.  (The client ids are defined in globals.wam.)
;;
;; See $memory-copy-sig, $memory-copy, etc below the import section.
;;
;; Clients need to import these tables and fill their entries before calling any
;; block allocation manager functions.
;;
;;
;; ## Allocation Algorithm
;;
;; The allocation first checks that the largest free block is at least as big as
;; the request, otherwise a new free block is added, potentially growing the
;; managed memory. It then searches a representative subset of the heap for the
;; smallest free block that is at least as big as the requested size.  If that
;; block is not greater than the maximum allowable overage, then it is used,
;; otherwise it splits the largest free block to create a new block to return to
;; the caller.
;;
;;
;; ## Deallocation Algorithm
;;
;; Deallocation adds the block to the free list and the heap, and if the
;; length of the free list is greater than the square root
;; ## Heap maintenance
;;
;; During defragmentation, free blocks are coalesced.  One free block becomes
;; bigger and another is removed from the block list.  The heap, however, will
;; still have references to these blocks.  There is no efficient way to find
;; these blocks, so they must be marked for future disposal and handled when the
;; heap encounters them.  In order not to corrupt the heap, the sizes of the
;; blocks must remain unchanged.  The solution here is set the address field to
;; -1 to signal that a block is unused.  To coalese two free blocks, the two
;; source blocks are both set to unused and removed from the block list and free
;; list.  A new block is created to replace them and added to the heap.  When a
;; traversal of the heap encounters an entry with an unused block, it sets the
;; block's size field to 0 and sinks it to the bottom.  Later when a new entry
;; is added, if the would-be parent of the entry is unused, then instead of
;; becoming a child, it takes the unused entry's place and the unused entry is
;; deallocated.
;;
;; That leaves the question of when the heap checks for unused nodes Obviously,
;; if the free list and the heap have the same number of items, checking is
;; unnecessary.  It is also obvious that the root needs to be checked before it
;; is returned as a free block.  Perhaps less obvious is that if the heap were
;; half unused items, that would only add one more operation to every full
;; traversal, on average, and most sink/swim operations do not actually fully
;; traverse the heap.  A lot of unused items in the heap is does not incur a
;; large computational penalty, but it does consume pair memory.  On the other
;; hand, keeping the unused items to a minimum would require more computation,
;; so we need a policy parameter and a two sets of heap traversal routines.
;; TODO: When the fraction of unused nodes crosses the policy threshold, heap
;; operations use the set of routines that check for unused nodes during
;; traversals.
;;
;; Adding an node and removing the head from heap both require knowing where
;; the last node of the heap is (or, equivalently) where it should go.
;; Adding an node is straightforward: add it at the appropriate place, and
;; repeatedly swap it with its parent until the heap condition is satisfied, in
;; this case, that the block it references is no smaller than its two children,
;; but no bigger than its parent.  In the case of removing an node, we
;; replace the root with last elemment of the heap, and then swap with its
;; largest child until the heap condition is satisfied.  With an array-based
;; heap, this is
;;
;; Removing a block from the free list
;;
;; Adding an node to the heap.
;;
;; Finding Free Blocks
;;
;; (32 - clz(Heap count)) >> 1 levels
;; compute max <= limit
;; check for unused blocks, sink if found

(module

 (import "pairs" "make-pair" (func $make-pair (param i32 i32) (result i32)))

 (include "./globals.wam")

 ;; Used to store per-client information
 (memory (debug (export "memory")) 2)

 ;; (global $heap-node-size-bits (export "heap-node-size-bits") i32 (i32.const 3))
 (global $blockset-size-bits (export "blockset-size-bits") i32 (i32.const 6))

 (debug (global $debug (export "#debug") (mut i32) (i32.const 0)))

 ;; ;; Each heap node is 8 bytes, allow 16 nodes per blockset
 ;; (global $per-blockset-heap0-capacity-bytes (export "per-blockset-heap0-capacity-bytes") i32 (i32.const 128))

 ;; ;; 1KB, enough for 128 heap nodes
 ;; (global $initial-heap-size (export "initial-heap-size") i32 (i32.const 0x400))

 (global $alloc-precision-bits (export "alloc-precision-bits") i32 (i32.const 4))

 (global $item-count      (export "item-count")      (mut i32) (i32.const 0))
 (global $free-item-count (export "free-item-count") (mut i32) (i32.const 0))
 (global $item-free-list  (export "item-free-list")  (mut i32) (i32.const 0))

 (global $blockset-block-count           (export "blockset-block-count")           i32 (i32.const 0x00))
 (global $blockset-block-list            (export "blockset-block-list")            i32 (i32.const 0x04))
 (global $blockset-defrag-cursor         (export "blockset-defrag-cursor")         i32 (i32.const 0x08))
 (global $blockset-end-block             (export "blockset-end-block")             i32 (i32.const 0x0c))
 (global $blockset-free-space            (export "blockset-free-space")            i32 (i32.const 0x18))
 (global $blockset-immobile-block-size   (export "blockset-immobile-block-size")   i32 (i32.const 0x24))
 (global $blockset-relocation-size-limit (export "blockset-relocation-size-limit") i32 (i32.const 0x28))

 (global $block-addr                (export "block-addr")                i32 (i32.const 0x00))
 (global $block-size                (export "block-size")                i32 (i32.const 0x04))
 (global $block-next-block          (export "block-next-block")          i32 (i32.const 0x08))
 (global $block-previous-block      (export "block-previous-block")      i32 (i32.const 0x0c))

 (type $memory-copy-sig (func (param i32 i32 i32)))
 (type $memory-grow-sig (func (param i32) (result i32)))
 (type $memory-size-sig (func (result i32)))

 (table $memory-copy (export "memory-copy") 16 funcref)
 (table $memory-grow (export "memory-grow") 16 funcref)
 (table $memory-size (export "memory-size") 16 funcref)

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Block Accessors
 ;;

 (macro %get-block-addr
   (expr ,block)
   (i32.load ,block))

 (macro %get-block-size
   (expr ,block)
   (i32.load (i32.add ,block (global.get $block-size))))

 (macro %get-next-block
   (expr ,block)
   (i32.load (i32.add ,block (global.get $block-next-block))))

 (macro %get-previous-block
   (expr ,block)
   (i32.load (i32.add ,block (global.get $block-previous-block))))

 (macro %set-block-addr
   (expr ,block)
   (expr ,addr)
   (i32.store ,block ,addr))

 (macro %set-block-size
   (expr ,block)
   (expr ,size)
   (i32.store (i32.add ,block (global.get $block-size)) ,size))

 (macro %set-next-block
   (expr ,block)
   (expr ,size)
   (i32.store (i32.add ,block (global.get $block-next-block)) ,size))

 (macro %set-previous-block
   (expr ,block)
   (expr ,size)
   (i32.store (i32.add ,block (global.get $block-previous-block)) ,size))

 (debug
  (func $get-block-addr (export "get-block-addr")
    (param $block i32)
    (result i32)
    (%get-block-addr (local.get $block)))

  (func $get-block-size (export "get-block-size")
    (param $block i32)
    (result i32)
    (%get-block-size (local.get $block)))

  (func $get-next-block (export "get-next-block")
    (param $block i32)
    (result i32)
    (%get-next-block (local.get $block)))

  (func $get-previous-block (export "get-previous-block")
    (param $block i32)
    (result i32)
    (%get-previous-block (local.get $block)))

  (func $set-block-addr (export "set-block-addr")
    (param $block i32)
    (param $addr i32)
    (%set-block-addr (local.get $block) (local.get $addr)))

  (func $set-block-size (export "set-block-size")
    (param $block i32)
    (param $size i32)
    (%set-block-size (local.get $block) (local.get $size))))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Block Utilities
 ;;

 (macro %get-next-block-addr
   (expr ,block)
   (i32.add (%get-block-addr ,block) (%get-block-size ,block)))

 (debug

  (func $get-next-block-addr (export "get-next-block-addr")
    (param $block i32)
    (result i32)
    (%get-next-block-addr (local.get $block))))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Blockset Accessors
 ;;

 (macro %get-blockset-block-count
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-block-count))))

 (macro %get-blockset-block-list
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-block-list))))

 (macro %get-blockset-defrag-cursor
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-defrag-cursor))))

 (macro %get-blockset-end-block
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-end-block))))

 (macro %get-blockset-immobile-block-size
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-immobile-block-size))))

 (macro %get-blockset-relocation-size-limit
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-relocation-size-limit))))

 (macro %get-blockset-free-space
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-free-space))))

 (macro %set-blockset-block-count
   (expr ,blockset)
   (expr ,block-count)
   (i32.store (i32.add ,blockset (global.get $blockset-block-count))
              ,block-count))

 (macro %set-blockset-block-list
   (expr ,blockset)
   (expr ,block-list)
   (i32.store (i32.add ,blockset (global.get $blockset-block-list))
              ,block-list))

 (macro %set-blockset-defrag-cursor
   (expr ,blockset)
   (expr ,defrag-cursor)
   (i32.store (i32.add ,blockset (global.get $blockset-defrag-cursor))
              ,defrag-cursor))

 (macro %set-blockset-end-block
   (expr ,blockset)
   (expr ,end-block)
   (i32.store (i32.add ,blockset (global.get $blockset-end-block))
              ,end-block))

 (macro %set-blockset-immobile-block-size
   (expr ,blockset)
   (expr ,immobile-block-size)
   (i32.store (i32.add ,blockset (global.get $blockset-immobile-block-size))
              ,immobile-block-size))

 (macro %set-blockset-relocation-size-limit
   (expr ,blockset)
   (expr ,relocation-size-limit)
   (i32.store (i32.add ,blockset (global.get $blockset-relocation-size-limit))
              ,relocation-size-limit))

 (macro %set-blockset-free-space
   (expr ,blockset)
   (expr ,free-space)
   (i32.store (i32.add ,blockset (global.get $blockset-free-space))
              ,free-space))

 (func $get-blockset-immobile-block-size (export "get-blockset-immobile-block-size")
   (param $blockset i32)
   (result i32)
   (%get-blockset-immobile-block-size (local.get $blockset)))

 (func $get-blockset-relocation-size-limit (export "get-blockset-relocation-size-limit")
   (param $blockset i32)
   (result i32)
   (%get-blockset-relocation-size-limit (local.get $blockset)))

 (func $set-blockset-immobile-block-size (export "set-blockset-immobile-block-size")
   (param $blockset i32)
   (param $immobile-block-size i32)
   (%set-blockset-immobile-block-size (local.get $blockset) (local.get $immobile-block-size)))

 (func $set-blockset-relocation-size-limit (export "set-blockset-relocation-size-limit")
   (param $blockset i32)
   (param $relocation-size-limit i32)
   (%set-blockset-relocation-size-limit (local.get $blockset) (local.get $relocation-size-limit)))

 (debug
  (func $get-blockset-block-count (export "get-blockset-block-count")
    (param $blockset i32)
    (result i32)
    (%get-blockset-block-count (local.get $blockset)))

  (func $get-blockset-block-list (export "get-blockset-block-list")
    (param $blockset i32)
    (result i32)
    (%get-blockset-block-list (local.get $blockset)))

  (func $get-blockset-defrag-cursor (export "get-blockset-defrag-cursor")
    (param $blockset i32)
    (result i32)
    (%get-blockset-defrag-cursor (local.get $blockset)))

  (func $get-blockset-end-block (export "get-blockset-end-block")
    (param $blockset i32)
    (result i32)
    (%get-blockset-end-block (local.get $blockset)))

  (func $get-blockset-free-space (export "get-blockset-free-space")
    (param $blockset i32)
    (result i32)
    (%get-blockset-free-space (local.get $blockset)))

  (func $set-blockset-block-count (export "set-blockset-block-count")
    (param $blockset i32)
    (param $block-count i32)
    (%set-blockset-block-count (local.get $blockset) (local.get $block-count)))

  (func $set-blockset-block-list (export "set-blockset-block-list")
    (param $blockset i32)
    (param $block-list i32)
    (%set-blockset-block-list (local.get $blockset) (local.get $block-list)))

  (func $set-blockset-defrag-cursor (export "set-blockset-defrag-cursor")
    (param $blockset i32)
    (param $defrag-cursor i32)
    (%set-blockset-defrag-cursor (local.get $blockset) (local.get $defrag-cursor)))

  (func $set-blockset-end-block (export "set-blockset-end-block")
    (param $blockset i32)
    (param $end-block i32)
    (%set-blockset-end-block (local.get $blockset) (local.get $end-block))))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Blockset Utilities
 ;;

 (func $decr-blockset-block-count (debug (export "decr-blockset-block-count"))
   (param $blockset i32)
   (local $addr i32)
   (local.set $addr (i32.add (local.get $blockset) (global.get $blockset-block-count)))
   (i32.store (local.get $addr) (i32.sub (i32.load (local.get $addr)) (i32.const 1))))

 (func $incr-blockset-block-count (debug (export "incr-blockset-block-count"))
   (param $blockset i32)
   (local $addr i32)
   (local.set $addr (i32.add (local.get $blockset) (global.get $blockset-block-count)))
   (i32.store (local.get $addr) (i32.add (i32.load (local.get $addr)) (i32.const 1))))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; List Items
 ;;
 ;;

 (func $link-blocks (debug (export "link-blocks"))
   (param $blockset i32)
   (param $a i32)
   (param $b i32)

   (if (i32.ne (local.get $a) (global.get $null))
       (then
        (i32.store (i32.add (local.get $a) (global.get $block-next-block))
                   (local.get $b)))
     (else
      (%set-blockset-block-list (local.get $blockset) (local.get $b))))

   (if (i32.ne (local.get $b) (global.get $null))
       (then
        (i32.store (i32.add (local.get $b) (global.get $block-previous-block))
                   (local.get $a)))
     (else
      (%set-blockset-end-block (local.get $blockset) (local.get $a)))))

 (func $link-free-entries (debug (export "link-free-entries"))
   (param $blockset i32)
   (param $a i32)
   (param $b i32)

   (if (i32.ne (local.get $a) (global.get $null))
       (then
        (i32.store (i32.add (local.get $a) (global.get $free-entry-next-entry))
                   (local.get $b)))
     (else
      (%set-blockset-free-list (local.get $blockset) (local.get $b))))

   (if (i32.ne (local.get $b) (global.get $null))
       (then
        (i32.store (i32.add (local.get $b) (global.get $free-entry-previous-entry))
                   (local.get $a))))

   ;; (else
   ;;     (%set-blockset-end-free-entry (local.get $blockset) (local.get $a)))
   )

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Module Initialization
 ;;
 ;;

 (start $init-blockset-manager)
 (func $init-blockset-manager (debug (export "init-blockset-manager"))
   (global.set $blocks-top (i32.const 0))
   (global.set $block-count (i32.const 0))
   (global.set $block-free-list (global.get $null)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Blockset Initialization
 ;;
 ;;

 (func $init-blockset (export "init-blockset")
   (param $blockset i32)
   (param $immobile-block-size i32)
   (param $relocation-size-limit i32)

   (%set-blockset-immobile-block-size
    (local.get $blockset)
    (local.get $immobile-block-size))

   (%set-blockset-relocation-size-limit
    (local.get $blockset)
    (local.get $relocation-size-limit))

   (%set-blockset-block-count      (local.get $blockset) (i32.const 0))
   (%set-blockset-block-list       (local.get $blockset) (global.get $null))
   (%set-blockset-defrag-cursor    (local.get $blockset) (global.get $null))
   (%set-blockset-end-block        (local.get $blockset) (global.get $null))
   (%set-blockset-free-space       (local.get $blockset) (i32.const 0))

   (memory.fill
    (local.set $addr (%get-blockset-quantized-free-area (local.get $blockset)))
    (global.get $null)
    (global.get $blockset-quantized-free-list-area-size)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Blocks
 ;;

 (func $make-block (debug (export "make-block"))
   (param $addr i32)
   (param $size i32)
   (result i32)

   (local $block i32)

   (debug
    (%global.incr i32 $block-count)
    (%global.decr i32 $free-block-count))

   (if (i32.eq (global.get $block-free-list) (global.get $null))
       (then
        (call $grow-storage (global.get $default-grow-storage-block-count))))

   (local.set $block (global.get $block-free-list))
   (global.set $block-free-list (%get-block-addr (global.get $block-free-list)))

   (%set-block-addr (local.get $block) (local.get $addr))
   (%set-block-size (local.get $block) (local.get $size))

   (local.get $block))

 (func $grow-storage (debug (export "grow-storage"))
   (param $count i32)

   (local $bytes-required i32)
   (local $new-top i32)
   (local $pages-required i32)

   (local.set $new-top (i32.add (global.get $blocks-top)
                                (i32.shl (local.get $count)
                                         (global.get $block-size-bits))))

   (local.set $bytes-required (i32.sub (local.get $new-top)
                                       (i32.shl (memory.size)
                                                (global.get $page-size))))

   (if (i32.gt_s (local.get $bytes-required) (i32.const 0))
       (then
        (local.set $pages-required (i32.add (i32.shr_u (i32.sub (local.get $bytes-required)
                                                                (i32.const 1))
                                                       (global.get $page-size-bits))
                                            (i32.const 1)))

        (drop (memory.grow (local.get $pages-required)))))

   (call $fill-block-free-list (local.get $count)))

 (func $fill-block-free-list (debug (export "fill-block-free-list"))
   (param $count i32)

   (local $next-block i32)
   (local $block i32)
   (local $top i32)

   (local.set $block (global.get $blocks-top))

   (local.set $top (i32.add (i32.shl (local.get $count)
                                     (global.get $block-size-bits))
                            (global.get $blocks-top)))

   (loop $again
     (local.set $next-block (i32.add (local.get $block) (global.get $block-size)))
     (if (i32.lt_u (local.get $next-block) (local.get $top))
         (then
          (%set-block-addr (local.get $block) (local.get $next-block))
          (debug
           (%set-block-size (local.get $block) (i32.const 0xdeadce11)))
          (local.set $block (local.get $next-block))
          (br $again))
       (else
        (i32.store (local.get $block) (global.get $block-free-list)))))

   (global.set $block-free-list (global.get $blocks-top))
   (global.set $blocks-top (local.get $top)))

 (func $free-block (debug (export "free-block"))
   (param $item i32)

   (%set-block-addr (local.get $block) (global.get $block-free-list))

   (%global.incr i32 $free-block-count)
   (debug
    (%set-block-size (local.get $block) (i32.const 0xdeadce11))
    (%global.decr i32 $block-count))

   (global.set $block-free-list (local.get $block)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Allocation
 ;;

 ;; This is used in test/test_block_mgr.py::test_stochastic.  The average of
 ;; many calls to this stub should account for the overhead of calling
 ;; alloc-block so that the performance of alloc-block's internals can be more
 ;; precisely measured.

 (func $stub-alloc-block (export "stub-alloc-block")
   (param $blockset-id i32)
   (param $size i32)
   (result i32)
   (global.get $null))

 (func $alloc-block (export "alloc-block")
   (param $blockset-id i32)
   (param $size i32)
   (result i32)

   (local $blockset i32)
   (local $free-entry i32)
   (local $heap i32)
   (local $new-block i32)
   (local $node-idx i32)

   (local.set $size (call $quantize-size (local.get $size)))

   (local.set $free-list (%get-quantized-free-list (local.get $blockset) (local.get $size)))
   (local.set $last-free-list (%get-last-quantized-free-list (local.get $blockset)))

   (loop $again
     (local.set $block (call $pop-free-block (local.get $free-list)))
     (if (i32.eq (local.get $block) (global.get $null))
         (then
          (if (i32.ne (local.get $free-list) (local.get $last-free-list))
              (then
               (%incr-n i32 $free-list #value-size)
               (br $again))))))

   (if (i32.eq (local.get $block) (global.get $null))
       (then
        (local.set $block (call $provision-free-block (local.get $blockset) (local.get $size)))))

   (if (i32.gt_u (%get-block-size (local.get $block)) (local.get $size))
       (then
        (call $split-free-block (local.get $blockset) (local.get $block) (local.set $size))))

   (%mark-block-allocated (local.get $block))
   (local.get $block))

 (func $quantize-size (debug (export "quantize-size"))

   ;; One of the memory efficiency versus CPU efficiency trade-offs that can be
   ;; made is either to allocate precisely the amount requested and have a
   ;; longer free list, and therefore increased search and maintenance time, or
   ;; to allocate approximately and have a smaller free list.  This function is
   ;; part of the latter approach.  Essentially, it reduces the precision of the
   ;; requested size, so that for example, a request for 207 bytes would be
   ;; rounded up to 208 since 207 = 0xcf = 0b11001111, and below we only
   ;; use 4 bits of precision, so that gives 0b11010000 = 0xd0 = 208.  If only
   ;; 3 bits were used, then we would have rounded up to 0b11100000 = 0xe0 = 224.

   (param $size i32)
   (result i32)

   (local $mask i32)
   (local $rank i32)

   (local.set $rank (i32.sub (i32.const 32) (i32.clz (local.get $size))))

   (if (i32.le_u (local.get $rank) (global.get $alloc-precision-bits))
       (then
        (local.set $mask (i32.const 0)))
     (else
      (local.set $mask (i32.sub (i32.shl (i32.const 1)
                                         (i32.sub (local.get $rank)
                                                  (global.get $alloc-precision-bits)))
                                (i32.const 1)))))

   (i32.and (i32.add (local.get $size) (local.get $mask))
            (i32.xor (local.get $mask) (i32.const -1))))

 (func $pop-free-block (debug (export "pop-free-block"))
   (param $free-list i32)
   (param $idx i32)
   (result i32)

   (local $block i32)
   (local $head i32)
   (local $next i32)

   (local.set $block (global.get $null))
   (local.set $head (%get-free-list-head (local.get $free-list)))

   (loop $again
     (if (i32.ne (local.get $head) (global.get $null))
         (then
          (local.set $block (call $get-pair-car (local.get $head)))
          (local.set $next (call $get-pair-cdr (local.set $head)))

          (call $dealloc-pair (local.get $head))
          (local.set $head (local.get $next))

          (if (%is-unused-block (local.get $block))
              (then
               (call $free-block (local.get $block))
               (local.set $block (global.get $null))
               (br $again))))))

   (%set-free-list-head (local.get $free-list) (local.get $head))
   (local.get $block))

 (func $provision-free-block (debug (export "provision-free-block"))
   (param $blockset i32)
   (param $size i32)

   (local $block i32)
   (local $block-addr i32)
   (local $blockset-id i32)
   (local $end-block i32)
   (local $end-page i32)
   (local $free-pages i32)
   (local $page-count i32)
   (local $total-pages i32)

   (local.set $blockset-id (%get-blockset-id (local.get $blockset)))

   (local.set $page-count (i32.add (i32.shr_u (i32.sub (local.get $size)
                                                       (i32.const 1))
                                              (global.get $page-size-bits))
                                   (i32.const 1)))

   (local.set $total-pages (call_indirect
                            $memory-size
                            (type $memory-size-sig)
                            (local.get $blockset-id)))

   (local.set $end-block (%get-blockset-end-block (local.get $blockset)))

   (if (i32.eq (local.get $end-block) (global.get $null))
       (then
        (local.set $free-pages (local.get $total-pages))
        (local.set $block-addr (i32.const 0)))

     (else
      (local.set $end-page (i32.shr_u (%get-next-block-addr (local.get $end-block))
                                      (global.get $page-size-bits)))

      (local.set $free-pages (i32.sub (local.get $total-pages) (local.get $end-page)))

      (local.set $block-addr (%get-next-block-addr (local.get $end-block)))))

   (if (i32.lt_u (local.get $free-pages) (local.get $page-count))
       (then
        (drop (call_indirect $memory-grow
                             (type $memory-grow-sig)
                             (i32.sub (local.get $page-count)
                                      (local.get $free-pages))
                             (local.get $blockset-id)))))

   (local.set $block (call $make-block
                           (local.get $block-addr)
                           (i32.shl (local.get $page-count)
                                    (global.get $page-size-bits))))

   (call $link-blocks (local.get $blockset) (local.get $end-block) (local.get $block))
   (call $link-blocks (local.get $blockset) (local.get $block) (global.get $null))

   (debug
    (call $incr-blockset-block-count (local.get $blockset)))

   (local.get $block))

 (func $split-free-block (debug (export "split-free-block"))
   (param $blockset i32)
   (param $block i32)
   (param $split-size i32)

   (local $block i32)
   (local $new-block i32)
   (local $next-block i32)
   (local $remainder-size i32)

   (local.set $remainder-size
              (i32.sub (%get-block-size (local.get $block))
                       (local.get $split-size)))

   (local.set $next-block (%get-next-block (local.get $block)))

   (local.set $new-block (call $make-block
                               (i32.add (%get-block-addr (local.get $block))
                                        (local.get $split-size))
                               (local.get $remainder-size)))

   (%set-block-size (local.get $block) (local.get $split-size))

   (call $link-blocks (local.get $blockset) (local.get $block) (local.get $new-block))
   (call $link-blocks (local.get $blockset) (local.get $new-block) (local.get $next-block))

   (call $add-free-block (local.get $blockset) (local.get $new-block)))


 ;;-----------------------------------------------------------------------------
 ;;
 ;; Resize Block
 ;;

 (func $resize-block (export "resize-block")
   (param $blockset-id i32)
   (param $block i32)
   (param $new-size i32)
   (result i32)

   (local $new-block i32)
   (local $old-size i32)
   (local $size i32)

   (local.set $new-block (call $alloc-block (local.get $blockset-id) (local.get $new-size)))

   (local.set $old-size (%get-block-size (local.get $block)))

   (local.set $size (if (result i32) (i32.gt_u (local.get $new-size) (local.get $old-size))
                      (then (local.get $old-size))
                      (else (local.get $new-size))))

   (call_indirect $memory-copy
                  (type $memory-copy-sig)
                  (%get-block-addr (local.get $new-block))
                  (%get-block-addr (local.get $block))
                  (local.get $size)
                  (local.get $blockset-id))

   (call $dealloc-block (local.get $blockset-id) (local.get $block))

   (local.get $new-block))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Deallocation
 ;;

 ;; This is used in test/test_block_mgr.py::test_stochastic.  The average of
 ;; many calls to this stub should account for the overhead of calling
 ;; dealloc-block so that the performance of dealloc-block's internals can be
 ;; more precisely measured.

 (func $stub-dealloc-block (export "stub-dealloc-block")
   (param $blockset-id i32)
   (param $block i32))

 (func $dealloc-block (export "dealloc-block")
   (param $blockset-id i32)
   (param $block i32)

   (local $blockset i32)
   (local $free-list-length i32)
   (local $heap-size i32)

   (call $add-free-block (local.get $blockset) (local.get $block))

   (if (?)
       (then
        (call $step-defragment-blockset (local.get $blockset))))

   )

 (func $add-free-block (debug (export "add-free-block"))
   (param $blockset i32)
   (param $block i32)

   (local $free-list i32)
   (local.set $free-list (%get-quantized-free-list (local.get $blockset)
                                                   (%get-block-size (local.get $block))))

   (%set-free-list-head (local.get $free-list)
                        (call $make-pair
                              (local.get $block)
                              (%get-free-list-head (local.get $free-list))))

   (%mark-block-free (local.get $block))

   (%set-blockset-free-space (local.get $blockset)
                             (i32.add (%get-blockset-free-space (local.get $blockset))
                                      (%get-block-size (local.get $block)))))

 (func $step-defragment-blockset (debug (export "step-defragment-blockset"))
   (param $blockset i32)

   (local $cursor i32)

   (local.set $cursor (%get-blockset-defrag-cursor (local.get $blockset)))

   (local.set $free-block (call $find-next-free-block (local.get $cursor)))

   (if (i32.eq (local.get $free-block) (global.get $null))
       (then
        (%set-blockset-defrag-cursor (local.get $blockset) (global.get $null))
        (return)))

   (call $coalesce-free-blocks (local.get $blockset) (local.get $free-block))

   (local.set $relo-start (%get-next-block (local.get $free-block)))

   (if (i32.eq (local.get $relo-start) (global.get $null))
       (then
        (%set-blockset-defrag-cursor (local.get $blockset) (global.get $null))
        (return)))

   ;; Scan from free block upward for allocated blocks, stopping when
   ;; we've found the limit that we can move or the next free block.
   (local.set $relo-last
              (local.set $relo-size
                         (call $scan-relocatable-blocks
                               (local.get $relo-start)
                               (%get-blockset-relocation-size-limit (local.get $blockset))
                               (%get-blockset-immobile-block-size (local.get $blockset)))))

   (local.set $relo-end (%get-next-block (local.get $relo-last)))

   (if (i32.eqz (local.get $relo-size))
       (then
        ;; The block after free-block is too big to move. Move the cursor to that block.
        ;; See $get-blockset-immobile-block-size below.
        (%set-blockset-defrag-cursor (local.get $blockset) (local.get $relo-end))
        (return)))

   ;; Shift the blocks down in memory, adjusting their addresses.
   (call $relocate-blocks
         (local.get $blockset)
         (%get-block-addr (local.get $free-block))
         (local.get $relo-start)
         (local.get $relo-end)
         (local.get $relo-size))

   ;; Remove free-block from before relo-start.
   (call $link-blocks
         (local.get $blockset)
         (%get-previous-block (local.get $free-block))
         (local.get $relo-start))

   (%set-block-addr
    (local.get $free-block)
    (i32.add (%get-block-addr (local.get $relo-start))
             (local.get $relo-size)))

   (call $link-blocks (local.get $blockset) (local.get $relo-last) (local.get $free-block))
   (call $link-blocks (local.get $blockset) (local.get $free-block) (local.get $relo-end))

   (%set-blockset-defrag-cursor (local.get $blockset) (local.get $free-block)))

 (func $find-next-free-block (debug (export "find-next-free-block"))
   (param $block i32)
   (result i32)

   (loop $again
     (if (i32.ne (local.get $block) (global.get $null))
         (then
          (if (%is-allocated-block (local.get $block))
              (then
               (local.set $block (%get-next-block (local.get $block)))
               (br $again))))))

   (local.get $block))

 (func $coalesce-free-blocks (debug (export "coalesce-free-blocks"))
   (param $blockset i32)
   (param $block i32)

   (local $next i32)

   (loop $again
     (local.set $next (%get-next-block (local.get $block)))
     (if (i32.ne (local.get $next) (global.get $null))
         (then
          (if (%is-free-block (local.get $next))
              (then
               (%set-block-size (i32.add (%get-block-size (local.get $block))
                                         (%get-block-size (local.get $next))))
               (%mark-block-unused (local.get $next))
               (call $link-blocks (local.get $block) (%get-next-block (local.get $next)))
               (br $again)))))))

 (func $scan-relocatable-blocks (debug (export "scan-relocatable-blocks"))
   (param $start-block i32)
   (param $aggregate-size-limit i32)
   (param $single-block-size-limit i32)
   (result i32 i32)

   (local $block i32)
   (local $last-block i32)
   (local $count i32)
   (local $size i32)
   (local $size-remaining i32)

   (local.set $last-block (local.get $start-block))
   (local.set $block (local.get $start-block))
   (local.set $count (i32.const 0))
   (local.set $size-remaining (local.get $aggregate-size-limit))

   ;; The logic is simpler to start with the total number of bytes that can be
   ;; moved and subtract from it the size of each block that will be moved.
   ;; Note that this is a signed value, unlike all other values in this module.

   (loop $again
     (if (%is-allocated-block (local.get $block))
         (then
          (local.set $size (%get-block-size (local.get $block)))
          (if (i32.le_s (local.get $size) (local.get $size-remaining))
              (then
               ;; The current block will fit with the remaining bytes available.
               (local.set $size-remaining (i32.sub (local.get $size-remaining)
                                                   (local.get $size)))
               (local.set $last-block (local.get $block))
               (local.set $block (%get-next-block (local.get $block)))
               (if (i32.ne (local.get $block) (global.get $null))
                   (then
                    (%incr i32 $count)
                    (br $again))))
            (else
             ;; The current block won't fit. If this is the first block, then it is
             ;; be bigger than the size allowable for a sequence of blocks, but it might
             ;; be relocatable if it's below the single block size limit.
             (if (i32.and (i32.eqz (local.get $count))
                          (i32.lt_u (local.get $size)
                                    (local.get $single-block-size-limit)))
                 (then
                  ;; This is the statement that requires aggregate size limit to be
                  ;; a signed value.
                  (local.set $size-remaining (i32.sub (local.get $size-remaining)
                                                      (local.get $size)))
                  (local.set $last-block (local.get $block))
                  (local.set $block (%get-next-block (local.get $block))))))))))

   ;; Return values

   ;; Address of the block beyond the last block that can be moved
   (local.get $last-block)

   ;; The size remaining is the aggregate size limit minus the size of each block
   ;; that can be moved.  The difference below results in the sum of the sizes
   ;; of the blocks that can be moved.
   (i32.sub (local.get $aggregate-size-limit) (local.get $size-remaining)))

 ;; ## Defragmentation
 ;;
 ;; Defragmentation is the process of relocating allocated blocks so that free
 ;; blocks can be merged.
 ;;
 ;; Policy parameters: step frequency, target # of bytes copied per step, min
 ;; size of non-relocatable block.
 ;;
 ;; At each step, we need to be able to remove two entries from the free list
 ;; and replace them with a larger entry.  The two candidate entries will be the
 ;; first two above the cursor, so we will need to have the address of the free
 ;; entry immediately below (or at) the cursor.  We need a fast way to find the
 ;; highest address of a free entry at or below the cursor.  The naive approach
 ;; would be to scan from the beginning of the list, but as the number of free
 ;; list entries grows, this becomes increasingly slower.  Since the heap is
 ;; ordered by free block size, we should expect that any arbitrary subset will
 ;; be a random sample over the address space.  This sample won't be uniform,
 ;; especially during defragmentation, where the address space below the cursor
 ;; will be undersampled.  The root node of the heap is generally going to be
 ;; above the cursor, both in the initial part of defragmentation when most heap
 ;; nodes are above the cursor, and the in the later part when most of the
 ;; lower free blocks have been swept up above the cursor.  A useful property of
 ;; heaps is that the top half (in terms of levels) contains roughly the square
 ;; root of the total number of nodes in the heap.  For example, a heap of
 ;; 1023 nodes has 10 levels.  The first 5 levels contain 31 nodes, and
 ;; 31^2 = 961.  An average linear scan of a free list of 1023 entries is going
 ;; to take 512 comparisons, but if we make 31 comparisions of the top half of
 ;; the heap to find a better starting place, we should expect a further 33 to
 ;; find the desired entry.  For a heap of this size, it's roughly 1/8th the
 ;; computational cost to scan the top half of the heap for a better starting
 ;; point than to start at the beginning of the free list.
 ;;
 ;; Assuming then, that we have a pointer to the highest free list entry before
 ;; the cursor, then the defragmentation algorithm is as follows:
 ;;
 ;; 1. Scan the block list forward from the cursor to find the next free block.
 ;;
 ;;   a. if there is no such block, reset the cursor to the beginning of the
 ;;      block list
 ;;
 ;;   b. if a free block is found, leave the cursor at the block before the
 ;;      free block
 ;;
 ;; 2. Scan the block list beyond that free block to find the set of blocks
 ;;    which satisify one of the following conditions, with earlier conditions
 ;;    taking precedence
 ;;
 ;;   a. The set of blocks before the successor to the next free block.
 ;;
 ;;   b. A set of blocks less than the policy limit,
 ;;
 ;;   c. A single block less than the single block policy limit, or
 ;;
 ;; 3. If the set of blocks found in step 2 is empty, then end the step by the
 ;;    following
 ;;
 ;;   a. if the next free block is the last block, reset the cursor to the
 ;;      beginning of the block list
 ;;
 ;;   b. if the next block after the next free block is a free block, then merge
 ;;      the two free blocks by increasing the size of the lower free block,
 ;;      removing its successor from the block list and the free list, and
 ;;      setting the successor's address to -1
 ;;
 ;;   c. if the next block after the next free block is an allocated block, then
 ;;      it is greater than the max relocatable block size. Set the cursor to
 ;;      the next block after the next free block.
 ;;
 ;; 4. Move the blocks found in step 2 lower in memory by the size of the next
 ;;    free block, and adjust their addresses accordingly.
 ;;
 ;; 5. If the last relocated block is followed by a free block, then end the
 ;;    step by the following
 ;;
 ;;    a. then create a new free block with address at the top of the relocated
 ;;       blocks and size of the next free block (formerly below the relocated
 ;;       blocks) plus its successor (formerly above)
 ;;
 ;;    b. remove the next free block and its successor from the free list and
 ;;       from the block list
 ;;
 ;;    c. insert the new free block into the block list after the last relocated
 ;;       block
 ;;
 ;;    d. insert the new free block into the free list at the place formerly
 ;;       occupied by the next free block
 ;;
 ;;    e. set the address of the next free block and its successor to -1
 ;;
 ;;    f. set the cursor to the last relocated block.
 ;;
 ;; 6. If the last relocated block is not followed by a free block, then end the
 ;;    step by the following
 ;;
 ;;    a. remove the next free block from the block list (immediately before the
 ;;       first relocated block)
 ;;
 ;;    b. insert the next free block into the block list immediately following
 ;;       the last relocated block
 ;;
 ;;    c. update the address of the next free block
 ;;
 ;;    d. set the cursor to the last relocated block.
 ;;

 (func $relocate-blocks (debug (export "relocate-blocks"))
   (param $blockset i32)
   (param $dest-addr i32)
   (param $start-block i32)
   (param $end-block i32)
   (param $size i32)

   (local $block i32)
   (local $offset i32)
   (local $source-addr i32)

   (local.set $source-addr (%get-block-addr (local.get $start-block)))

   (call_indirect $memory-copy
                  (type $memory-copy-sig)
                  (local.get $dest-addr)
                  (local.get $source-addr)
                  (local.get $size)
                  (%get-blockset-id (local.get $blockset)))

   (local.set $block (local.get $start-block))
   (local.set $offset (i32.sub (local.get $source-addr) (local.get $dest-addr)))

   (loop $again
     (if (i32.ne (local.get $block) (local.get $end-block))
         (then
          (%set-block-addr
           (local.get $block)
           (i32.sub (%get-block-addr (local.get $block))
                    (local.get $offset)))
          (local.set $block (%get-next-block (local.get $block)))
          (br $again)))))

 ;; end of module
 )

;; # Block Allocation Manager
;;
;; This module manages allocation and deallocation of variable-length blocks of
;; memory.  It is intended to be used by the bytevectors, numbers, strings, and
;; vectors modules, and by the garbage collector for its internal indexes.
;;
;; ## Design
;;
;; The simplest memory management policy is static allocation, common on small,
;; embedded devices with limited RAM and functionality.  FORTH uses a slightly
;; more advanced allocation scheme with just a single "dictionary" pointer that
;; increases with each allocation.  One could think of this as static
;; allocation, but incrementally defined.  Beyond that, things get complex
;; quickly.  To support reuse of memory that is no longer needed, we need to
;; track deallocated blocks, and these could be stored in a list, either
;; implemented as a linked list or in a dynamic array.  Typcial distributions of
;; block sizes lead to fragmentation and a loss of memory efficiency.  (There
;; are special cases where this does not apply, such as when all blocks have the
;; same size, or when they have varying sizes, but form a power law
;; distribution, etc).  Further if the number of free blocks grows large, then
;; searching through the list of free blocks for one of a matching size becomes
;; increasingly expensive, or we could maintain a sorted array, but then
;; allocation and free become expensive.  The free list could be recast as a
;; heap, but then we aren't guaranteed to find a block of the correct size, so
;; to maintain computational efficiency we need to allow blocks to be split.
;; Splitting blocks just makes the fragmentation problem worse.  We could
;; coalesce adjacent free blocks, but then we need an ordered data structure
;; again, and we're back to having a free list.  But now the free list needs to
;; be careful not to corrupt the heap when coalescing free blocks.  That still
;; leaves the possibility of small bits of memory lost between larger blocks
;; which have a long lifetime.  To handle that, we need to be able to relocate
;; allocated blocks, but that requires an ordered list of all blocks -- both
;; free and allocated -- and indirection of block id and block storage address.
;; If all of that sounds complicated, it is, and it ends up being slow.  The
;; first several versions of this module followed that pattern, but they
;; suffered from increasingly slow performance as the number of managed blocks
;; grew.
;;
;; The solution to the poor scaling was to get rid of the heap and replace it
;; with a set of free lists, each containing a relatively small range of block
;; sizes.  This design enables an O(1) lookup for an appropriately-sized block.
;; The number of free lists is kept small by having only a few lists per
;; size "rank", where rank here means the index of the highest set bit in the
;; size -- for example, 1 has rank 1; 2 and 3 have rank 2; 4 to 7 have rank 3
;; etc.  The number of free lists for each rank is determined by the "precision"
;; configured for the block-mgr as a whole.  A precision of 4 provides for 16
;; free lists for each rank (though for ranks less than 4, only one free list
;; for each size, of course). In general, a higher precision leads to better
;; performance, though beyond a precision of 4, the gains are very small.
;;
;; The current implementation also uses a doubly linked list to store the
;; blocks.  Having the predecessor links saves time during defragmentation,
;; so that the relocated free block and be easily removed from the block
;; list and inserted into a later position.
;;
;; ## External Interface
;;
;;
;; ## Data Representation
;;
;; block ref
;; block ref free list
;; block size/flags
;; block list
;; free list array
;;
;; A block is a an address of an item in the block list.  Each block contains
;; the address of the memory it references, the size, and links to the previous
;; and next blocks in the list.
;;
;; A blockset is an index into an array of structures which capture the state of
;; a client's memory.  These structures include pointers to the block list,
;; free lists, and various values necessary for managing memory.
;;
;;
;; ## Memory Access
;;
;; The block allocation manager has no direct access to the memory it manages.
;; It uses its own memory to store the state of each client module, the block
;; lists and free lists It needs access to client memory when it is attempting
;; to allocate a block larger than any free block available, in which case it
;; uses client proxies memory.size and memory.grow.  It also needs access during
;; defragmentation, when it needs to call a proxy for memory.copy.  Access to
;; these instructions is provided through three tables, one for each of the
;; memory functions mentioned.  The client module provides a client id, which is
;; the index into each of the tables for its proxies for the memory it owns.
;; The clients need to be coordinated to ensure that there are no conflicts.
;; (The client ids are defined in globals.wam.)
;;
;; See $memory-copy-sig, $memory-copy, etc below the import section.
;;
;; Clients need to import these tables and fill their entries before calling any
;; block allocation manager functions.
;;
;; ## Algorithms
;;
;; ### Allocation
;;
;; 1. check sized free list
;; 2. check last free list, walk downward
;; 3. provision
;;
;; ### Deallocation
;;
;; ### Defragmentation


(module

 (import "pairs" "dealloc-pair" (func $dealloc-pair (param i32)))
 (import "pairs" "get-pair-car" (func $get-pair-car (param i32)     (result i32)))
 (import "pairs" "get-pair-cdr" (func $get-pair-cdr (param i32)     (result i32)))
 (import "pairs" "make-pair"    (func $make-pair    (param i32 i32) (result i32)))
 (import "pairs" "set-pair-cdr" (func $set-pair-cdr (param i32 i32)))

 (include "./constants.wam")
 (include "./globals.wam")

 ;; Used to store blockset records and the blocksets' quantized free list heads.
 (memory (debug (export "memory")) 1)

 (debug (global $debug (export "#debug") (mut i32) (i32.const 0)))

 (define _blockset-block-list            (+offset 0 4))
 (define _blockset-end-block             (+offset))
 (define _blockset-fragment-count        (+offset))
 (define _blockset-fragment-counts-base  (+offset))
 (define _blockset-fragment-counts-top   (+offset))
 (define _blockset-free-lists-base       (+offset))
 (define _blockset-free-lists-top        (+offset))
 (define _blockset-last-free-list        (+offset))
 (define _blockset-relocation-size-limit (+offset))
 (define _blockset-sweep-cursor          (+offset))
 (define _blockset-total-size            (+offset))
 (define _blockset-unused-count          (+offset))
 (define _blockset-block-count           (+offset))
 (define _blockset-free-count            (+offset))
 (define _blockset-free-space            (+offset))

 (debug
  (global $blockset-block-list            (export "blockset-block-list")            i32 _blockset-block-list)
  (global $blockset-end-block             (export "blockset-end-block")             i32 _blockset-end-block)
  (global $blockset-fragment-count        (export "blockset-fragment-count")        i32 _blockset-fragment-count)
  (global $blockset-fragment-counts-base  (export "blockset-fragment-counts-base")  i32 _blockset-fragment-counts-base)
  (global $blockset-fragment-counts-top   (export "blockset-fragment-counts-top")   i32 _blockset-fragment-counts-top)
  (global $blockset-free-lists-base       (export "blockset-free-lists-base")       i32 _blockset-free-lists-base)
  (global $blockset-free-lists-top        (export "blockset-free-lists-top")        i32 _blockset-free-lists-top)
  (global $blockset-last-free-list        (export "blockset-last-free-list")        i32 _blockset-last-free-list)
  (global $blockset-relocation-size-limit (export "blockset-relocation-size-limit") i32 _blockset-relocation-size-limit)
  (global $blockset-sweep-cursor          (export "blockset-sweep-cursor")          i32 _blockset-sweep-cursor)
  (global $blockset-total-size            (export "blockset-total-size")            i32 _blockset-total-size)
  (global $blockset-unused-count          (export "blockset-unused-count")          i32 _blockset-unused-count)

  (global $blockset-block-count  (export "blockset-block-count")  i32 _blockset-block-count)
  (global $blockset-free-count   (export "blockset-free-count")   i32 _blockset-free-count)
  (global $blockset-free-space   (export "blockset-free-space")   i32 _blockset-free-space))

 (debug   (global $alloc-precision-bits (export "alloc-precision-bits") (mut i32) (i32.const 4)))
 (release (global $alloc-precision-bits                                      i32  (i32.const 4)))

 (debug   (global $fragment-size-bits (export "fragment-size-bits") (mut i32) (i32.const 4)))
 (release (global $fragment-size-bits                               i32       (i32.const 4)))

 (debug   (global $fragment-size (export "fragment-size") (mut i32) (i32.const 16)))
 (release (global $fragment-size                               i32  (i32.const 16)))

 (define _ref-size      (i32.const 0x10))
 (define _ref-size-bits (i32.const 4))

 (debug
  (global $ref-size      (export "refs-size")      i32 _ref-size)
  (global $ref-size-bits (export "refs-size-bits") i32 _ref-size-bits))

 (global $refs-top      (debug (export "refs-top"))      (mut i32) (i32.const 0))
 (global $ref-count     (debug (export "ref-count"))     (mut i32) (i32.const 0))
 (global $ref-free-list (debug (export "ref-free-list")) (mut i32) (i32.const 0))

 (macro %get-refs-top
   (global.get $refs-top))

 (macro %get-ref-count
   (global.get $ref-count))

 (macro %get-ref-free-list
   (global.get $ref-free-list))

 (macro %set-refs-top
   (expr ,v)
   (global.set $refs-top ,v))

 (macro %set-ref-count
   (expr ,v)
   (global.set $ref-count ,v))

 (macro %set-ref-free-list
   (expr ,v)
   (global.set $ref-free-list ,v))

 ;; create 4 KB of block refs (256 * 16 = 4096) when growing storage
 (global $provision-block-ref-count (debug (export "provision-block-ref-count")) i32 (i32.const 256))

 ;; Offsets into a block ref element.
 (define _block-addr           (i32.const 0x00))
 (define _block-size           (i32.const 0x04))
 (define _block-flags          (i32.const 0x04))
 (define _block-next-block     (i32.const 0x08))
 (define _block-previous-block (i32.const 0x0c))

 ;; Flags and masks used to unpack the $block-size/$block-flags value within a
 ;; block ref.
 (define _block-size-mask   (i32.const 0x3fffffff))
 (define _block-flags-mask  (i32.const 0xc0000000))
 (define _block-free-flag   (i32.const 0x80000000))
 (define _block-unused-flag (i32.const 0x40000000))

 (debug
  ;; Offsets into a block ref element.
  (global $block-addr           (debug (export "block-addr"))           i32 _block-addr)
  (global $block-size           (debug (export "block-size"))           i32 _block-size)
  (global $block-flags          (debug (export "block-flags"))          i32 _block-flags)
  (global $block-next-block     (debug (export "block-next-block"))     i32 _block-next-block)
  (global $block-previous-block (debug (export "block-previous-block")) i32 _block-previous-block)

  ;; Flags and masks used to unpack the $block-size/$block-flags value within a
  ;; block ref.
  (global $block-size-mask   (debug (export "block-size-mask"))   i32 _block-size-mask)
  (global $block-flags-mask  (debug (export "block-flags-mask"))  i32 _block-flags-mask)
  (global $block-free-flag   (debug (export "block-free-flag"))   i32 _block-free-flag)
  (global $block-unused-flag (debug (export "block-unused-flag")) i32 _block-unused-flag))

 ;; The block manager does not have direct access to the managed memory.
 ;; Instead the clients register proxies for memory.copy, memory.grow, and
 ;; memory.size in the following tables.  See block-mgr-memory-proxies.wam and
 ;; block-mgr-memory-proxy-imports.wam.

 (table $memory-copy (export "memory-copy") 16 funcref)
 (table $memory-grow (export "memory-grow") 16 funcref)
 (table $memory-size (export "memory-size") 16 funcref)

 (type $memory-copy-sig (func (param i32 i32 i32)))
 (type $memory-grow-sig (func (param i32) (result i32)))
 (type $memory-size-sig (func (result i32)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Block Accessors
 ;;

 (macro %get-block-addr
   (expr ,block)
   (i32.load ,block))

 (macro %get-block-flags-addr
   (expr ,block)
   (i32.add ,block _block-flags))

 (macro %get-block-size-addr
   (expr ,block)
   (i32.add ,block _block-size))

 (macro %get-block-size
   (expr ,block)
   (i32.and (i32.load (%get-block-size-addr ,block))
            _block-size-mask))

 (macro %get-next-block
   (expr ,block)
   (i32.load (i32.add ,block _block-next-block)))

 (macro %get-previous-block
   (expr ,block)
   (i32.load (i32.add ,block _block-previous-block)))

 (macro %is-allocated-block
   (expr ,block)
   (i32.eqz (i32.and (i32.load (%get-block-flags-addr ,block))
                     _block-flags-mask)))

 (macro %is-fragment
   (expr ,block)
   (i32.lt_u (%get-block-size ,block) (global.get $fragment-size)))

 (macro %is-free-block
   (expr ,block)
   (i32.and (i32.load (%get-block-flags-addr ,block)) _block-free-flag))

 (macro %is-unused-block
   (expr ,block)
   (i32.and (i32.load (%get-block-flags-addr ,block)) _block-unused-flag))

 (macro %set-block-addr
   (expr ,block)
   (expr ,addr)
   (i32.store ,block ,addr))

 (macro %set-block-size
   (expr ,block)
   (expr ,size)
   (i32.store (%get-block-size-addr ,block)
              (i32.and ,size _block-size-mask)))

 (macro %set-next-block
   (expr ,block)
   (expr ,size)
   (i32.store (i32.add ,block _block-next-block) ,size))

 (macro %set-previous-block
   (expr ,block)
   (expr ,size)
   (i32.store (i32.add ,block _block-previous-block) ,size))

 (debug
  (func $get-block-addr (export "get-block-addr")
    (param $block i32)
    (result i32)
    (%get-block-addr $block))

  (func $get-block-size (export "get-block-size")
    (param $block i32)
    (result i32)
    (%get-block-size $block))

  (func $get-next-block (export "get-next-block")
    (param $block i32)
    (result i32)
    (%get-next-block $block))

  (func $get-previous-block (export "get-previous-block")
    (param $block i32)
    (result i32)
    (%get-previous-block $block))

  (func $is-allocated-block (export "is-allocated-block")
    (param $block i32)
    (result i32)
    (%is-allocated-block $block))

  (func $is-free-block (export "is-free-block")
    (param $block i32)
    (result i32)
    (%is-free-block $block))

  (func $is-unused-block (export "is-unused-block")
    (param $block i32)
    (result i32)
    (%is-unused-block $block))

  (func $set-block-addr (export "set-block-addr")
    (param $block i32)
    (param $addr i32)
    (%set-block-addr $block $addr))

  (func $set-block-size (export "set-block-size")
    (param $block i32)
    (param $size i32)
    (%set-block-size $block $size)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Block Utilities
 ;;

 (macro %get-next-block-addr
   (expr ,block)
   (i32.add (%get-block-addr ,block) (%get-block-size ,block)))

 (func $mark-block-allocated (debug (export "mark-block-allocated"))
   (param $block i32)

   (local $addr i32)
   (local $size-flags i32)

   (set! $addr (%get-block-size-addr $block))
   (set! $size-flags (i32.load $addr))

   (i32.store $addr (i32.and $size-flags _block-size-mask)))

 (func $mark-block-free (debug (export "mark-block-free"))
   (param $block i32)

   (local $addr i32)
   (local $size-flags i32)

   (set! $addr (%get-block-size-addr $block))
   (set! $size-flags (i32.load $addr))

   (i32.store $addr (i32.or $size-flags _block-free-flag)))

 (func $mark-block-unused (debug (export "mark-block-unused"))
   (param $block i32)

   (local $addr i32)
   (local $size-flags i32)

   (set! $addr (%get-block-size-addr $block))
   (set! $size-flags (i32.load $addr))

   (i32.store $addr (i32.or $size-flags _block-unused-flag)))

 (debug
  (func $get-next-block-addr (export "get-next-block-addr")
    (param $block i32)
    (result i32)
    (%get-next-block-addr $block)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Blockset Accessors
 ;;

 (macro %get-blockset
   (expr ,blockset-id)
   (i32.shl ,blockset-id _blockset-size-bits))

 (macro %get-blockset-block-count
   (expr ,blockset)
   (i32.load (i32.add ,blockset _blockset-block-count)))

 (macro %get-blockset-block-list
   (expr ,blockset)
   (i32.load (i32.add ,blockset _blockset-block-list)))

 (macro %get-blockset-last-free-list
   (expr ,blockset)
   (i32.load (i32.add ,blockset _blockset-last-free-list)))

 (macro %get-blockset-end-block
   (expr ,blockset)
   (i32.load (i32.add ,blockset _blockset-end-block)))

 (macro %get-blockset-fragment-count
   (expr ,blockset)
   (i32.load (i32.add ,blockset _blockset-fragment-count)))

 (macro %get-blockset-free-count
   (expr ,blockset)
   (i32.load (i32.add ,blockset _blockset-free-count)))

 (macro %get-blockset-fragment-counts-base
   (expr ,blockset)
   (i32.load (i32.add ,blockset _blockset-fragment-counts-base)))

 (macro %get-blockset-fragment-counts-top
   (expr ,blockset)
   (i32.load (i32.add ,blockset _blockset-fragment-counts-top)))

 (macro %get-blockset-free-lists-base
   (expr ,blockset)
   (i32.load (i32.add ,blockset _blockset-free-lists-base)))

 (macro %get-blockset-free-lists-top
   (expr ,blockset)
   (i32.load (i32.add ,blockset _blockset-free-lists-top)))

 (macro %get-blockset-free-space
   (expr ,blockset)
   (i32.load (i32.add ,blockset _blockset-free-space)))

 (macro %get-blockset-relocation-size-limit
   (expr ,blockset)
   (i32.load (i32.add ,blockset _blockset-relocation-size-limit)))

 (macro %get-blockset-sweep-cursor
   (expr ,blockset)
   (i32.load (i32.add ,blockset _blockset-sweep-cursor)))

 (macro %get-blockset-total-size
   (expr ,blockset)
   (i32.load (i32.add ,blockset _blockset-total-size)))

 (macro %get-blockset-unused-count
   (expr ,blockset)
   (i32.load (i32.add ,blockset _blockset-unused-count)))

 (macro %set-blockset-block-count
   (expr ,blockset)
   (expr ,block-count)
   (i32.store (i32.add ,blockset _blockset-block-count)
              ,block-count))

 (macro %set-blockset-fragment-count
   (expr ,blockset)
   (expr ,fragment-count)
   (i32.store (i32.add ,blockset _blockset-fragment-count)
              ,fragment-count))

 (macro %set-blockset-free-count
   (expr ,blockset)
   (expr ,free-count)
   (i32.store (i32.add ,blockset _blockset-free-count)
              ,free-count))

 (macro %set-blockset-sweep-cursor
   (expr ,blockset)
   (expr ,sweep-cursor)
   (i32.store (i32.add ,blockset _blockset-sweep-cursor)
              ,sweep-cursor))

 (macro %set-blockset-total-size
   (expr ,blockset)
   (expr ,total-size)
   (i32.store (i32.add ,blockset _blockset-total-size)
              ,total-size))

 (macro %set-blockset-unused-count
   (expr ,blockset)
   (expr ,unused-count)
   (i32.store (i32.add ,blockset _blockset-unused-count)
              ,unused-count))

 (macro %set-blockset-block-list
   (expr ,blockset)
   (expr ,block-list)
   (i32.store (i32.add ,blockset _blockset-block-list)
              ,block-list))

 (macro %set-blockset-fragment-counts-base
   (expr ,blockset)
   (expr ,fragment-counts-base)
   (i32.store (i32.add ,blockset _blockset-fragment-counts-base)
              ,fragment-counts-base))

 (macro %set-blockset-fragment-counts-top
   (expr ,blockset)
   (expr ,fragment-counts-top)
   (i32.store (i32.add ,blockset _blockset-fragment-counts-top)
              ,fragment-counts-top))

 (macro %set-blockset-free-lists-base
   (expr ,blockset)
   (expr ,free-lists-base)
   (i32.store (i32.add ,blockset _blockset-free-lists-base)
              ,free-lists-base))

 (macro %set-blockset-free-lists-top
   (expr ,blockset)
   (expr ,free-lists-top)
   (i32.store (i32.add ,blockset _blockset-free-lists-top)
              ,free-lists-top))

 (macro %set-blockset-last-free-list
   (expr ,blockset)
   (expr ,last-free-list)
   (i32.store (i32.add ,blockset _blockset-last-free-list)
              ,last-free-list))

 (macro %set-blockset-end-block
   (expr ,blockset)
   (expr ,end-block)
   (i32.store (i32.add ,blockset _blockset-end-block)
              ,end-block))

 (macro %set-blockset-relocation-size-limit
   (expr ,blockset)
   (expr ,relocation-size-limit)
   (i32.store (i32.add ,blockset _blockset-relocation-size-limit)
              ,relocation-size-limit))

 (macro %set-blockset-free-space
   (expr ,blockset)
   (expr ,free-space)
   (i32.store (i32.add ,blockset _blockset-free-space)
              ,free-space))

 (func $get-blockset-relocation-size-limit (export "get-blockset-relocation-size-limit")
   (param $blockset i32)
   (result i32)
   (%get-blockset-relocation-size-limit $blockset))

 (func $set-blockset-relocation-size-limit (export "set-blockset-relocation-size-limit")
   (param $blockset i32)
   (param $relocation-size-limit i32)
   (%set-blockset-relocation-size-limit $blockset $relocation-size-limit))

 (debug
  (func $get-blockset (export "get-blockset")
    (param $blockset-id i32)
    (result i32)
    (%get-blockset $blockset-id))

  (func $get-blockset-id (export "get-blockset-id")
    (param $blockset i32)
    (result i32)
    (%get-blockset-id $blockset))

  (func $get-blockset-block-count (export "get-blockset-block-count")
    (param $blockset i32)
    (result i32)
    (%get-blockset-block-count $blockset))

  (func $get-blockset-block-list (export "get-blockset-block-list")
    (param $blockset i32)
    (result i32)
    (%get-blockset-block-list $blockset))

  (func $get-blockset-last-free-list (export "get-blockset-last-free-list")
    (param $blockset i32)
    (result i32)
    (%get-blockset-last-free-list $blockset))

  (func $get-blockset-end-block (export "get-blockset-end-block")
    (param $blockset i32)
    (result i32)
    (%get-blockset-end-block $blockset))

  (func $get-blockset-fragment-count (export "get-blockset-fragment-count")
    (param $blockset i32)
    (result i32)
    (%get-blockset-fragment-count $blockset))

  (func $get-blockset-free-count (export "get-blockset-free-count")
    (param $blockset i32)
    (result i32)
    (%get-blockset-free-count $blockset))

  (func $get-blockset-fragment-counts-base (export "get-blockset-fragment-counts-base")
    (param $blockset i32)
    (result i32)
    (%get-blockset-fragment-counts-base $blockset))

  (func $get-blockset-fragment-counts-top (export "get-blockset-fragment-counts-top")
    (param $blockset i32)
    (result i32)
    (%get-blockset-fragment-counts-top $blockset))

  (func $get-blockset-free-lists-base (export "get-blockset-free-lists-base")
    (param $blockset i32)
    (result i32)
    (%get-blockset-free-lists-base $blockset))

  (func $get-blockset-free-lists-top (export "get-blockset-free-lists-top")
    (param $blockset i32)
    (result i32)
    (%get-blockset-free-lists-top $blockset))

  (func $get-blockset-free-space (export "get-blockset-free-space")
    (param $blockset i32)
    (result i32)
    (%get-blockset-free-space $blockset))

  (func $get-blockset-unused-count (export "get-blockset-unused-count")
    (param $blockset i32)
    (result i32)
    (%get-blockset-unused-count $blockset))

  (func $set-blockset-block-count (export "set-blockset-block-count")
    (param $blockset i32)
    (param $block-count i32)
    (%set-blockset-block-count $blockset $block-count))

  (func $set-blockset-block-list (export "set-blockset-block-list")
    (param $blockset i32)
    (param $block-list i32)
    (%set-blockset-block-list $blockset $block-list))

  (func $set-blockset-last-free-list (export "set-blockset-last-free-list")
    (param $blockset i32)
    (param $last-free-list i32)
    (%set-blockset-last-free-list $blockset $last-free-list))

  (func $set-blockset-end-block (export "set-blockset-end-block")
    (param $blockset i32)
    (param $end-block i32)
    (%set-blockset-end-block $blockset $end-block)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Blockset Utilities
 ;;

 (func $decr-blockset-fragment-count (debug (export "decr-blockset-fragment-count"))
   (param $blockset i32)
   (param $size i32)
   (local $addr i32)

   (set! $addr (i32.add $blockset _blockset-fragment-count))
   (i32.store $addr (i32.sub (i32.load $addr) (i32.const 1)))

   (set! $addr (i32.add (%get-blockset-fragment-counts-base $blockset)
                        (i32.shl $size
                                 _value-size-bits)))

   (i32.store $addr (i32.sub (i32.load $addr) (i32.const 1))))

 (func $incr-blockset-fragment-count (debug (export "incr-blockset-fragment-count"))
   (param $blockset i32)
   (param $size i32)
   (local $addr i32)
   (set! $addr (i32.add $blockset _blockset-fragment-count))
   (i32.store $addr (i32.add (i32.load $addr) (i32.const 1)))

   (set! $addr (i32.add (%get-blockset-fragment-counts-base $blockset)
                        (i32.shl $size
                                 _value-size-bits)))

   (i32.store $addr (i32.add (i32.load $addr) (i32.const 1))))

 (debug
  (func $decr-blockset-block-count (debug (export "decr-blockset-block-count"))
    (param $blockset i32)
    (local $addr i32)
    (set! $addr (i32.add $blockset _blockset-block-count))
    (i32.store $addr (i32.sub (i32.load $addr) (i32.const 1))))

  (func $decr-blockset-free-count (debug (export "decr-blockset-free-count"))
    (param $blockset i32)
    (local $addr i32)
    (set! $addr (i32.add $blockset _blockset-free-count))
    (i32.store $addr (i32.sub (i32.load $addr) (i32.const 1))))

  (func $decr-blockset-unused-count (debug (export "decr-blockset-unused-count"))
    (param $blockset i32)
    (local $addr i32)
    (set! $addr (i32.add $blockset _blockset-unused-count))
    (i32.store $addr (i32.sub (i32.load $addr) (i32.const 1))))

  (func $incr-blockset-block-count (debug (export "incr-blockset-block-count"))
    (param $blockset i32)
    (local $addr i32)
    (set! $addr (i32.add $blockset _blockset-block-count))
    (i32.store $addr (i32.add (i32.load $addr) (i32.const 1))))

  (func $incr-blockset-free-count (debug (export "incr-blockset-free-count"))
    (param $blockset i32)
    (local $addr i32)
    (set! $addr (i32.add $blockset _blockset-free-count))
    (i32.store $addr (i32.add (i32.load $addr) (i32.const 1))))

  (func $incr-blockset-unused-count (debug (export "incr-blockset-unused-count"))
    (param $blockset i32)
    (local $addr i32)
    (set! $addr (i32.add $blockset _blockset-unused-count))
    (i32.store $addr (i32.add (i32.load $addr) (i32.const 1)))))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; List Items
 ;;
 ;;

 (func $link-refs (debug (export "link-refs"))

   ;; Links the two block refs. If $a is null, then it implicitly references
   ;; the blockset's block list head; similarly if $b is null, the end block
   ;; ref is updated.

   (param $blockset i32)
   (param $a i32)
   (param $b i32)

   (if (i32.eq $a _null)
       (then
        (%set-blockset-block-list $blockset $b))
     (else
      (%set-next-block $a $b)))

   (if (i32.eq $b _null)
       (then
        (%set-blockset-end-block $blockset $a))
     (else
      (%set-previous-block $b $a))))

 (macro %calc-fragment-counts-area-base
   (i32.mul _blockset-size _blockset-count))

 (macro %calc-blockset-fragment-counts-area-size
   (i32.shl (global.get $fragment-size)
            _value-size-bits))

 (macro %calc-free-lists-area-base
   (i32.add (%calc-fragment-counts-area-base)
            (i32.mul _blockset-count
                     (%calc-blockset-fragment-counts-area-size))))

 (macro %calc-blockset-free-lists-area-size
   (i32.shl (i32.const 30)
            (i32.add (global.get $alloc-precision-bits)
                     _value-size-bits)))

 (macro %calc-initial-refs-top
   (i32.add (%calc-free-lists-area-base)
            (i32.mul _blockset-count
                     (%calc-blockset-free-lists-area-size))))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Module Initialization
 ;;
 ;;

 (start $init-blockset-manager)
 (func $init-blockset-manager (debug (export "init-blockset-manager"))
   (%set-refs-top (%calc-initial-refs-top))
   (%set-ref-count (i32.const 0))
   (%set-ref-free-list _null))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Blockset Initialization
 ;;
 ;;

 (func $init-blockset (export "init-blockset")
   (param $blockset i32)
   (param $relocation-size-limit i32)

   (local $blockset-id i32)
   (local $fragment-counts-base i32)
   (local $fragment-counts-size i32)
   (local $fragment-counts-top i32)
   (local $free-lists-base i32)
   (local $free-lists-size i32)
   (local $free-lists-top i32)

   (set! $blockset-id (%get-blockset-id $blockset))

   (%set-blockset-relocation-size-limit $blockset $relocation-size-limit)

   (%set-blockset-block-list     $blockset _null)
   (%set-blockset-end-block      $blockset _null)
   (%set-blockset-fragment-count $blockset (i32.const 0))
   (%set-blockset-total-size     $blockset (i32.const 0))
   (%set-blockset-unused-count   $blockset (i32.const 0))

   (debug
    (%set-blockset-block-count    $blockset (i32.const 0))
    (%set-blockset-free-count     $blockset (i32.const 0))
    (%set-blockset-free-space     $blockset (i32.const 0)))

   (set! $fragment-counts-size (%calc-blockset-fragment-counts-area-size))

   (set! $fragment-counts-base
         (i32.add (%calc-fragment-counts-area-base)
                  (i32.mul $blockset-id $fragment-counts-size)))

   (set! $fragment-counts-top (i32.add $fragment-counts-base $fragment-counts-size))

   (%set-blockset-fragment-counts-base $blockset $fragment-counts-base)
   (%set-blockset-fragment-counts-top $blockset $fragment-counts-top)

   (memory.fill $fragment-counts-base (i32.const 0) $fragment-counts-size)

   (set! $free-lists-size (%calc-blockset-free-lists-area-size))

   (set! $free-lists-base
         (i32.add (%calc-free-lists-area-base)
                  (i32.mul $blockset-id $free-lists-size)))

   (set! $free-lists-top (i32.add $free-lists-base $free-lists-size))

   (%set-blockset-free-lists-base $blockset $free-lists-base)
   (%set-blockset-free-lists-top $blockset $free-lists-top)
   (%set-blockset-last-free-list $blockset $free-lists-base)
   (%set-blockset-sweep-cursor $blockset $free-lists-base)

   (memory.fill $free-lists-base _null $free-lists-size))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Block Refs
 ;;
 ;; This is essentially just a copy of the functionality in the pairs module.
 ;; It could probably be abstracted into a macro or set of macros, though
 ;; that might just make it more difficult to understand.

 (func $make-ref (export "make-ref")
   (param $addr i32)
   (param $size i32)
   (result i32)

   (local $ref-addr i32)

   (if (i32.eq (%get-ref-free-list) _null)
       (then
        ($provision-block-refs (global.get $provision-block-ref-count))))

   (debug
    (%global.incr i32 $ref-count))

   (set! $ref-addr (%get-ref-free-list))
   (%set-ref-free-list (i32.load (%get-ref-free-list)))

   (%set-block-addr $ref-addr $addr)
   (%set-block-size $ref-addr $size)

   $ref-addr)

 (func $provision-block-refs (debug (export "provision-block-refs"))
   (param $count i32)

   (local $bytes-required i32)
   (local $new-top i32)
   (local $pages-required i32)

   (set! $new-top (i32.add (%get-refs-top) (i32.shl $count _ref-size-bits)))

   (set! $bytes-required (i32.sub $new-top (i32.shl (memory.size) _page-size-bits)))

   (if (i32.gt_s $bytes-required (i32.const 0))
       (then
        (set! $pages-required (i32.add (i32.shr_u (i32.sub $bytes-required (i32.const 1))
                                                  _page-size-bits)
                                       (i32.const 1)))

        (drop (memory.grow $pages-required))))

   ($fill-ref-free-list $count))

 (func $fill-ref-free-list (debug (export "fill-ref-free-list"))
   (param $count i32)

   (local $next-ref i32)
   (local $ref i32)
   (local $top i32)

   (set! $ref (%get-refs-top))

   (set! $top (i32.add (i32.shl $count _ref-size-bits)
                       (%get-refs-top)))

   (loop $again
     (set! $next-ref (i32.add $ref _ref-size))
     (if (i32.lt_u $next-ref $top)
         (then
          (%set-block-addr $ref $next-ref)
          (debug
           ;; Mark freshly-initialized refs with a distinctive bit pattern
           (%set-block-size $ref (i32.const 0x0badce11)))
          (set! $ref $next-ref)
          (br $again))
       (else
        (i32.store $ref (%get-ref-free-list)))))

   (%set-ref-free-list (%get-refs-top))
   (%set-refs-top $top))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Ref Deallocation
 ;;

 (func $dealloc-ref (export "dealloc-ref")
   (param $ref i32)

   (%set-block-addr $ref (%get-ref-free-list))

   (debug
    ;; Mark deallocated refs with a distinctive bit pattern
    (%set-block-size $ref (i32.const 0x0badce11))
    (%global.decr i32 $ref-count))

   (%set-ref-free-list $ref))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Allocation
 ;;

 ;; This is used in test/test_block_mgr.py::test_stochastic.  The average of
 ;; many calls to this stub should account for the overhead of calling
 ;; alloc-block so that the performance of alloc-block's internals can be more
 ;; precisely measured.

 (func $stub-alloc-block (export "stub-alloc-block")
   (param $blockset i32)
   (param $size i32)
   (result i32)
   _null)

 (macro %select-blockset-free-list
   (expr ,blockset)
   (expr ,size)
   (i32.add (%get-blockset-free-lists-base ,blockset)
            ($calc-free-list-offset ,size)))

 (debug
  (func $select-blockset-free-list (export "select-blockset-free-list")
    (param $blockset i32)
    (param $size i32)
    (result i32)
    (%select-blockset-free-list $blockset $size))

  (func $get-free-list-head (export "get-free-list-head")
    (param $free-list i32)
    (result i32)
    (i32.load $free-list)))

 (func $alloc-block (export "alloc-block")
   (param $blockset i32)
   (param $size i32)
   (result i32)

   (local $base-free-list i32)
   (local $block i32)
   (local $free-block-size i32)
   (local $free-list i32)
   (local $new-block i32)

   (debug
    (if (i32.eqz $size)
        (then
         (return _null))))

   ;; $quantize-size is used here to round up the requested size to the next
   ;; larger free list.  This ensures that every block in the selected free list
   ;; is big enough to satisfy the allocation.

   (set! $free-list (%select-blockset-free-list $blockset ($quantize-size $size)))

   ;; Returns the first block in the free list, or null if the list was empty.

   (set! $block ($pop-free-block $blockset $free-list))

   (if (i32.eq $block _null)
       (then

        ;; The selected free list was empty.  Search for a large block to split a
        ;; piece off of.  Most of the larger free lists, for sizes 2^24 and up are
        ;; probably going to be empty most of the time, so we start from the last
        ;; free list where a large block was retrieved from.

        (set! $base-free-list $free-list)
        (set! $free-list (%get-blockset-last-free-list $blockset))

        (loop $again
          (if (i32.gt_u $free-list $base-free-list)
              (then
               (set! $block ($pop-free-block $blockset $free-list))
               (if (i32.eq $block _null)
                   (then
                    ;; List empty, try the next lower size.
                    (%decr-n i32 $free-list #value-size)
                    (br $again))))))

        ;; A block was found, update the last free list so the next time this
        ;; code is encountered, we're likely to only run through the loop once.
        (if (i32.ne $block _null)
            (then
             (%set-blockset-last-free-list $blockset $free-list)))))

   (if (i32.eq $block _null)
       (then
        ;; The free lists do not contain a block big enough to satisfy the
        ;; request, so create a new large free block out of one or more
        ;; additional memory pages.
        (set! $block ($provision-free-block $blockset $size))))

   ;; If the block is more than just a little too big, split it and put the
   ;; remainder into the appropriate free list.

   (set! $free-block-size (%get-block-size $block))

   (if (i32.ne $size $free-block-size)
       (then
        (if (i32.or (i32.lt_u $size (global.get $fragment-size))
                    (i32.ge_u (i32.sub $size $free-block-size) (global.get $fragment-size)))
            (then
             ($split-free-block $blockset $block $size)))))

   ;; Update the block's status.
   ($mark-block-allocated $block)

   (debug
    ;; A little bit of accounting.
    (%set-blockset-free-space $blockset (i32.sub (%get-blockset-free-space $blockset) $size)))

   $block)

 (func $quantize-size (debug (export "quantize-size"))

   ;; todo reword

   ;; One of the memory efficiency versus CPU efficiency trade-offs that can be
   ;; made is either to allocate precisely the amount requested and have a
   ;; longer free list, and therefore increased search and maintenance time, or
   ;; to allocate approximately and have a smaller free list.  This function is
   ;; part of the latter approach.  Essentially, it reduces the precision of the
   ;; requested size, so that for example, a request for 207 bytes would be
   ;; rounded up to 208 since 207 = 0xcf = 0b11001111, and below we only
   ;; use 4 bits of precision, so that gives 0b11010000 = 0xd0 = 208.  If only
   ;; 3 bits were used, then we would have rounded up to 0b11100000 = 0xe0 = 224.

   (param $size i32)
   (result i32)

   (local $mask i32)
   (local $rank i32)

   (set! $rank (%rank i32 $size))

   (if (i32.le_u $rank (global.get $alloc-precision-bits))
       (then
        (set! $mask (i32.const 0)))
     (else
      (set! $mask (i32.sub (i32.shl (i32.const 1)
                                    (i32.sub $rank (global.get $alloc-precision-bits)))
                           (i32.const 1)))))

   (i32.and (i32.add $size $mask)
            (i32.xor $mask (i32.const -1))))

 (func $calc-free-list-offset (debug (export "calc-free-list-offset"))
   (param $size i32)
   (result i32)

   (local $rank i32)
   (local $rank-shift i32)

   (set! $rank (%rank i32 $size))

   (if (i32.le_u $rank (global.get $alloc-precision-bits))
       (then
        (set! $rank-shift (i32.const 0)))
     (else
      (set! $rank-shift (i32.sub $rank (global.get $alloc-precision-bits)))))

   (i32.shl (i32.add (i32.shr_u $size $rank-shift)
                     (i32.shl $rank-shift
                              (i32.sub (global.get $alloc-precision-bits) (i32.const 1))))
            _value-size-bits))

 (func $pop-free-block (debug (export "pop-free-block"))
   (param $blockset i32)
   (param $free-list i32)
   (result i32)

   (local $block i32)
   (local $head i32)
   (local $next i32)

   (set! $block _null)
   (set! $head (i32.load $free-list))

   (loop $again
     (if (i32.ne $head _null)
         (then
          (set! $block ($get-pair-car $head))
          (set! $next ($get-pair-cdr $head))

          ($dealloc-pair $head)
          (set! $head $next)

          (if (%is-unused-block $block)
              (then
               ($dealloc-ref $block)
               (set! $block _null)

               ($decr-blockset-unused-count $blockset)

               (br $again))))))

   (i32.store $free-list $head)

   (if (i32.ne $block _null)
       (then

        (debug
         ($decr-blockset-free-count $blockset))

        (if (%is-fragment $block)
            (then
             ($decr-blockset-fragment-count $blockset (%get-block-size $block))))))

   $block)

 (func $provision-free-block (debug (export "provision-free-block"))
   (param $blockset i32)
   (param $size i32)
   (result i32)

   (local $block i32)
   (local $block-addr i32)
   (local $blockset-id i32)
   (local $end-block i32)
   (local $end-page i32)
   (local $free-pages i32)
   (local $free-size i32)
   (local $page-count i32)
   (local $total-pages i32)

   (set! $blockset-id (%get-blockset-id $blockset))

   (set! $page-count (i32.add (i32.shr_u (i32.sub $size (i32.const 1))
                                         _page-size-bits)
                              (i32.const 1)))

   (set! $total-pages (call_indirect
                       $memory-size
                       (type $memory-size-sig)
                       $blockset-id))

   (set! $end-block (%get-blockset-end-block $blockset))

   (if (i32.eq $end-block _null)
       (then
        (set! $free-pages $total-pages)
        (set! $block-addr (i32.const 0)))

     (else
      (set! $end-page (i32.shr_u (%get-next-block-addr $end-block)
                                 _page-size-bits))

      (set! $free-pages (i32.sub $total-pages $end-page))

      (set! $block-addr (%get-next-block-addr $end-block))))

   (if (i32.lt_u $free-pages $page-count)
       (then
        (drop (call_indirect $memory-grow
                             (type $memory-grow-sig)
                             (i32.sub $page-count $free-pages)
                             $blockset-id))))

   (set! $free-size (i32.shl $page-count _page-size-bits))

   (set! $block ($make-ref $block-addr $free-size))

   ($link-refs $blockset $end-block $block)
   ($link-refs $blockset $block _null)

   (debug
    ($incr-blockset-block-count $blockset)

    (%set-blockset-free-space $blockset
                              (i32.add (%get-blockset-free-space $blockset)
                                       $free-size)))

   (%set-blockset-total-size $blockset
                             (i32.add (%get-blockset-total-size $blockset)
                                      $free-size))
   $block)

 (func $split-free-block (debug (export "split-free-block"))
   (param $blockset i32)
   (param $block i32)
   (param $split-size i32)

   (local $free-size i32)
   (local $new-block i32)
   (local $next-block i32)
   (local $remainder-size i32)

   (set! $free-size (%get-block-size $block))

   (set! $remainder-size
         (i32.sub $free-size $split-size))

   (set! $next-block (%get-next-block $block))

   (set! $new-block ($make-ref (i32.add (%get-block-addr $block) $split-size)
                               $remainder-size))

   (%set-block-size $block $split-size)

   ($link-refs $blockset $block $new-block)
   ($link-refs $blockset $new-block $next-block)

   (debug
    ($incr-blockset-block-count $blockset))

   ($add-free-block $blockset $new-block))


 ;;-----------------------------------------------------------------------------
 ;;
 ;; Resize Block
 ;;

 (func $resize-block (export "resize-block")
   (param $blockset i32)
   (param $block i32)
   (param $new-size i32)
   (result i32)

   (local $new-block i32)
   (local $old-size i32)
   (local $size i32)

   (set! $new-block ($alloc-block $blockset $new-size))

   (set! $old-size (%get-block-size $block))

   (set! $size (if (result i32) (i32.gt_u $new-size $old-size)
                 (then $old-size)
                 (else $new-size)))

   (call_indirect $memory-copy
                  (type $memory-copy-sig)
                  (%get-block-addr $new-block)
                  (%get-block-addr $block)
                  $size
                  $blockset)

   ($dealloc-block $blockset $block)

   $new-block)

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Deallocation
 ;;

 ;; This is used in test/test_block_mgr.py::test_stochastic.  The average of
 ;; many calls to this stub should account for the overhead of calling
 ;; dealloc-block so that the performance of dealloc-block's internals can be
 ;; more precisely measured.

 (func $stub-dealloc-block (export "stub-dealloc-block")
   (param $blockset i32)
   (param $block i32))

 (func $dealloc-block (export "dealloc-block")
   (param $blockset i32)
   (param $block i32)

   (local $size i32)

   (debug
    (if (i32.eq $block _null)
        (then
         (return))))

   (set! $size (%get-block-size $block))

   ($add-free-block $blockset $block)

   (debug
    (%set-blockset-free-space $blockset (i32.add (%get-blockset-free-space $blockset) $size)))

   ;; If the number of fragments times the relocation size limit is greater than
   ;; the total amount of memory managed by this blockset, then each time a
   ;; fragment is relocated, it will very likely be able to be merged into a
   ;; nearby free block, thus eliminating the fragment.

   (if (i32.gt_u (i32.mul (%get-blockset-fragment-count $blockset)
                          (%get-blockset-relocation-size-limit $blockset))
                 (%get-blockset-total-size $blockset))
       (then
        ($step-defragment-blockset $blockset)
        (if (i32.gt_u (%get-blockset-unused-count $blockset)
                      (%get-blockset-free-count $blockset))
            ($step-clean-free-lists $blockset)))))

 (func $add-free-block (debug (export "add-free-block"))

   ;; Adds the block to the appropriate free list, based on the block's size.

   (param $blockset i32)
   (param $block i32)

   (local $free-list i32)
   (local $last-free-list i32)
   (local $size i32)

   (set! $size (%get-block-size $block))

   (set! $free-list (%select-blockset-free-list $blockset $size))

   (i32.store $free-list ($make-pair $block (i32.load $free-list)))

   ($mark-block-free $block)

   (debug
    ($incr-blockset-free-count $blockset))

   (if (i32.lt_u $size (global.get $fragment-size))
       (then
        ($incr-blockset-fragment-count $blockset $size)))

   (set! $last-free-list (%get-blockset-last-free-list $blockset))

   (if (i32.gt_u $free-list $last-free-list)
       (then
        (%set-blockset-last-free-list $blockset $free-list))))

 (func $step-defragment-blockset (debug (export "step-defragment-blockset"))

   ;; Makes one step of incremental defragmentation. That consists of taking the
   ;; first item from each free list which contains a fragment, and attempting
   ;; to merge it with some block or blocks within the relocation size limit
   ;; above it.  It pops one free block from each list to distribute the
   ;; activity across block sizes, otherwise, one free list might become empty,
   ;; causing unnecessary block splits (and block splits are computationally
   ;; more expensive than reuse).

   (param $blockset i32)

   (local $average i32)
   (local $count-addr i32)
   (local $free-list i32)
   (local $half-average i32)
   (local $size i32)

   (set! $average (i32.shr_u (%get-blockset-fragment-count $blockset)
                             (global.get $fragment-size-bits)))

   (set! $count-addr (i32.add (%get-blockset-fragment-counts-base $blockset)
                              _value-size))

   (set! $free-list (i32.add (%get-blockset-free-lists-base $blockset)
                             _value-size))

   (set! $half-average (i32.shr_u $average (i32.const 1)))

   (set! $size (i32.const 1))

   (loop $again

     ($defragment-free-list $blockset
                            $free-list
                            (i32.add (i32.load $count-addr) $half-average)
                            $average)

     (if (i32.lt_u $size (global.get $fragment-size))
         (then
          (%incr-n i32 $free-list #value-size)
          (%incr-n i32 $count-addr #value-size)
          (%incr i32 $size)
          (br $again)))))


 (func $defragment-free-list (debug (export "defragment-free-list"))

   ;; Pops floor(count/average) free blocks from the given free list.  Unused
   ;; blocks are deallocated without being part of the count.  Each block will
   ;; be merged with any immediately following free blocks, and if the after that
   ;; the block is still a fragment, then it will be moved upward in memory
   ;; any for each coalescing it with any free neighbors, e

   (param $blockset i32)
   (param $free-list i32)
   (param $count i32)
   (param $average i32)

   (local $block i32)
   (local $next i32)
   (local $relocated i32)

   (set! $relocated _null)

   (loop $relocate
     (if (i32.ge_u $count $average)
         (then
          (set! $block ($pop-free-block $blockset $free-list))
          (if (i32.ne $block _null)
              (then

               ;; Join the free block with any adjacent free blocks above it

               ($coalesce-free-blocks $blockset $block)

               ;; Coalesce may have made the free block larger; only relocate blocks
               ;; if it's still a fragment.

               (if (%is-fragment $block)
                   (then
                    ($relocate-free-block $blockset $block)))

               ;; The block has likely increased in size or moved upwards in memory,
               ;; but it is possible that it has come up against a block that cannot
               ;; be moved.  To handle this, free blocks are held in a list until
               ;; required number have been relocated, and only then are they added
               ;; back into the free lists.

               (set! $relocated ($make-pair $block $relocated))

               (set! $count (i32.sub $count $average))
               (br $relocate))))))

   (loop $add-free
     (if (i32.ne $relocated _null)
         (then

          ;; Add it back to the free block here, when its final size is known,
          ;; otherwise a large block might get stranded in a free list for much
          ;; smaller blocks.

          ($add-free-block $blockset ($get-pair-car $relocated))

          (set! $next ($get-pair-cdr $relocated))
          ($dealloc-pair $relocated)

          (set! $relocated $next)
          (br $add-free)))))

 (func $relocate-free-block (debug (export "relocate-free-block"))
   (param $blockset i32)
   (param $free-block i32)

   (local $relo-end i32)
   (local $relo-last i32)
   (local $relo-start i32)

   (set! $relo-start (%get-next-block $free-block))

   (if (i32.eq $relo-start _null)
       (then
        (return)))

   ;; Scan from free block upward for allocated blocks, stopping when
   ;; we've found the limit that we can move or the next free block.
   (set! $relo-last
         ($scan-relocatable-blocks $relo-start
                                   (%get-blockset-relocation-size-limit $blockset)))

   (set! $relo-end (%get-next-block $relo-last))

   (if (i32.or (i32.eq $relo-start $relo-last) (i32.eq $relo-end _null))
       (then
        ;; The block after $free-block is too big to move, or $free-block is the
        ;; last free block in the block list, and there's not much point in
        ;; relocating it.
        (return)))

   ;; Shift the blocks down in memory, adjusting their addresses.
   ($relocate-blocks $blockset (%get-block-addr $free-block) $relo-start $relo-end)

   ;; Move free block up in memory
   (%set-block-addr $free-block (%get-next-block-addr $relo-last))

   ;; Remove free-block from before relo-start.
   ($link-refs $blockset (%get-previous-block $free-block) $relo-start)

   ;; Insert it after the relocated blocks.
   ($link-refs $blockset $relo-last $free-block)
   ($link-refs $blockset $free-block $relo-end)

   ;; In case the free block is now adjacent to another free block, merge them.
   ($coalesce-free-blocks $blockset $free-block))

 (func $coalesce-free-blocks (debug (export "coalesce-free-blocks"))

   ;; Merges any free blocks immediately after $block into $block.

   (param $blockset i32)
   (param $block i32)

   (local $next i32)
   (local $next-size i32)

   (loop $again
     (set! $next (%get-next-block $block))
     (if (i32.ne $next _null)
         (then
          (if (%is-free-block $next)
              (then

               ;; Check that the combined block is not too big to be
               ;; represented (size < 2^30).

               (if ($can-merge-blocks $block $next)
                   (then
                    (set! $next-size (%get-block-size $next))

                    ($incr-block-size $block $next-size)

                    (if (i32.lt_u $next-size (global.get $fragment-size))
                        (then
                         ($decr-blockset-fragment-count $blockset $next-size)))

                    ($link-refs
                     $blockset
                     $block
                     (%get-next-block $next))

                    ;; The next block has been absorbed into $block.  Marking it
                    ;; unused lets $pop-free-block know to discard the block when
                    ;; it encounters it.

                    ($mark-block-unused $next)

                    ($incr-blockset-unused-count $blockset)

                    (debug
                     ($decr-blockset-block-count $blockset)
                     ($decr-blockset-free-count $blockset))

                    (br $again)))))))))

 (func $incr-block-size (debug (export "incr-block-size"))

   ;; Increases the size of $block by $size, preserving the flags stored with
   ;; the block size, and checking for size overflow.

   (param $block i32)
   (param $size i32)

   (local $addr i32)
   (local $new-size i32)
   (local $size-flags i32)

   (set! $addr (%get-block-size-addr $block))
   (set! $size-flags (i32.load $addr))

   (set! $new-size (i32.add (i32.and $size-flags _block-size-mask) $size))

   (if (i32.gt_u $new-size _block-size-mask)
       (then
        (unreachable)))

   (i32.store $addr (i32.or (i32.and $size-flags _block-flags-mask) $new-size)))

 (func $can-merge-blocks (debug (export "can-merge-blocks"))

   ;; Returns false if the sum of the sizes of the blocks would be too large to
   ;; represent, ie. one whose size would trample the flag bits.  This is used

   (param $block i32)
   (param $next i32)
   (result i32)
   (i32.le_u (i32.add (%get-block-size $block) (%get-block-size $next))
             _block-size-mask))

 (func $scan-relocatable-blocks (debug (export "scan-relocatable-blocks"))

   ;; Scans upward in memory from $start-block stopping when it finds a free
   ;; block, or when it has found one or more allocated blocks less than
   ;; $size-limit, or if free block is followed by a single block
   ;; larger than $size-limit, but less than $single-block-size-limit.

   (param $start-block i32)
   (param $size-limit i32)
   (result i32)

   (local $block i32)
   (local $last-block i32)
   (local $size i32)
   (local $size-remaining i32)

   (set! $last-block $start-block)
   (set! $block $start-block)
   (set! $size-remaining $size-limit)

   ;; The logic is simpler to start with the total number of bytes that can be
   ;; moved and subtract from it the size of each block that will be moved.

   (loop $again
     (if (%is-allocated-block $block)
         (then
          (set! $size (%get-block-size $block))
          (if (i32.le_s $size $size-remaining)
              (then
               ;; The current block will fit with the remaining bytes available.
               (set! $size-remaining (i32.sub $size-remaining $size))
               (set! $last-block $block)
               (set! $block (%get-next-block $block))
               (if (i32.ne $block _null)
                   (then
                    (br $again))))))))

   $last-block)

 (func $relocate-blocks (debug (export "relocate-blocks"))

   ;; Copies the data and updates the address fields of the blocks from
   ;; $start-block to $end-block.  $start-block is moved to $dest-addr, and the
   ;; rest of the addresses follow from there.

   (param $blockset i32)
   (param $dest-addr i32)
   (param $start-block i32)
   (param $end-block i32)

   (local $block i32)
   (local $offset i32)
   (local $source-addr i32)

   (set! $source-addr (%get-block-addr $start-block))

   (call_indirect $memory-copy
                  (type $memory-copy-sig)
                  $dest-addr
                  $source-addr
                  (i32.sub (%get-block-addr $end-block) (%get-block-addr $start-block))
                  (%get-blockset-id $blockset))

   (set! $block $start-block)
   (set! $offset (i32.sub $source-addr $dest-addr))

   (loop $again
     (if (i32.ne $block $end-block)
         (then
          (%set-block-addr
           $block
           (i32.sub (%get-block-addr $block) $offset))
          (set! $block (%get-next-block $block))
          (br $again)))))

 (func $step-clean-free-lists (debug (export "step-clean-free-lists"))

   ;; Finds the next non-empty free list and recreates it, omitting any unused
   ;; blocks.  The blockset sweep cursor is used to track what "next" free
   ;; list means between invocations of this function.

   (param $blockset i32)

   (local $base-free-list i32)
   (local $free-list i32)
   (local $head i32)

   (set! $base-free-list (%get-blockset-free-lists-base $blockset))
   (set! $free-list (%get-blockset-sweep-cursor $blockset))

   (loop $again
     (if (i32.ge_u $free-list $base-free-list)
         (then
          (set! $head (i32.load $free-list))
          (if (i32.eq $head _null)
              (then
               (%decr-n i32 $free-list #value-size)
               (br $again))
            (else
             ($rebuild-free-list $blockset $head)
             (%decr-n i32 $free-list #value-size))))
       (else

        ;; The search reached the bottom. Reset to the top for the next run.
        (set! $free-list (%get-blockset-last-free-list $blockset)))))

   ;; Update the cursor for the next invocation.
   (%set-blockset-sweep-cursor $blockset $free-list))

 (func $rebuild-free-list (debug (export "rebuild-free-list"))

   ;; Filters a free list to omit unused blocks, deallocating block refs and
   ;; pairs as needed.  This also adjusts the blockset's unused block count.

   (param $blockset i32)
   (param $head i32)

   (local $block i32)
   (local $next i32)
   (local $unused i32)
   (local $unused-count i32)

   (set! $next ($get-pair-cdr $head))
   (set! $unused-count (i32.const 0))

   (loop $again
     (if (i32.ne $next _null)
         (then
          (set! $block ($get-pair-car $next))

          (if (%is-unused-block $block)
              (then
               ;; Unlink from the list and deallocate the block ref and the pair

               (set! $unused $next)
               (set! $next ($get-pair-cdr $next))
               ($set-pair-cdr $head $next)

               ($dealloc-ref $block)
               ($dealloc-pair $unused)
               (%incr i32 $unused-count))
            (else
             (set! $head $next)
             (set! $next ($get-pair-cdr $head))))

          (br $again))))

   ;; It's much faster to accumulate the number of unused blocks that were
   ;; deallocated and subtract them at the end than to do so incrementally.

   (%set-blockset-unused-count $blockset
                               (i32.sub (%get-blockset-unused-count $blockset)
                                        $unused-count)))

 ;; end of module
 )

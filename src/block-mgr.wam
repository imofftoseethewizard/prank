;; # Block Allocation Manager
;;
;; This module manages allocation and deallocation of variable-length blocks of
;; memory.  It is intended to be used by the bytevectors, numbers, strings, and
;; vectors modules, and by the garbage collector for its internal indexes.
;;
;; ## Design
;;
;; The simplest memory management policy is static allocation, common on small,
;; embedded devices with limited RAM and functionality.  FORTH uses a slightly
;; more advanced allocation scheme with just a single "dictionary" pointer that
;; increases with each allocation.  One could think of this as static
;; allocation, but incrementally defined.  Beyond that, things get complex
;; quickly.  To support reuse of memory that is no longer needed, we need to
;; track deallocated blocks, and these could be stored in a list, either
;; implemented as a linked list or in a dynamic array.  Typcial distributions of
;; block sizes lead to fragmentation and a loss of memory efficiency.  (There
;; are special cases where this does not apply, such as when all blocks have the
;; same size, or when they have varying sizes, but form a power law
;; distribution, etc).  Further if the number of free blocks grows large, then
;; searching through the list of free blocks for one of a matching size becomes
;; increasingly expensive, or we could maintain a sorted array, but then
;; allocation and free become expensive.  The free list could be recast as a
;; heap, but then we aren't guaranteed to find a block of the correct size, so
;; to maintain computational efficiency we need to allow blocks to be split.
;; Splitting blocks just makes the fragmentation problem worse.  We could
;; coalesce adjacent free blocks, but then we need an ordered data structure
;; again, and we're back to having a free list.  But now the free list needs to
;; be careful not to corrupt the heap when coalescing free blocks.  That still
;; leaves the possibility of small bits of memory lost between larger blocks
;; which have a long lifetime.  To handle that, we need to be able to relocate
;; allocated blocks, but that requires an ordered list of all blocks -- both
;; free and allocated -- and indirection of block id and block storage address.
;; If all of that sounds complicated, it is, and it ends up being slow.  The
;; first several versions of this module followed that pattern, but they
;; suffered from increasingly slow performance as the number of managed blocks
;; grew.
;;
;; The current implementation uses a doubly linked list to store the blocks,
;; and an array of lists of free blocks.  Each free list contains a narrow
;; range of block sizes, so that an allocation request can be satisfied
;; in O(1) time by calculating an index and popping the head of a list.
;;
;; ## External Interface
;;
;;
;; ## Data Representation
;;
;; block ref
;; block ref free list
;; block size/flags
;; block list
;; free list array
;;
;; A block is a an address of an item in the block list.  Each block contains
;; the address of the memory it references, the size, and links to the previous
;; and next blocks in the list.
;;
;; A blockset is an index into an array of structures which capture the state of
;; a client's memory.  These structures include pointers to the block list,
;; free lists, and various values necessary for managing memory.
;;
;;
;; ## Memory Access
;;
;; The block allocation manager has no direct access to the memory it manages.
;; It uses its own memory to store the state of each client module, the block
;; lists and free lists It needs access to client memory when it is attempting
;; to allocate a block larger than any free block available, in which case it
;; uses client proxies memory.size and memory.grow.  It also needs access during
;; defragmentation, when it needs to call a proxy for memory.copy.  Access to
;; these instructions is provided through three tables, one for each of the
;; memory functions mentioned.  The client module provides a client id, which is
;; the index into each of the tables for its proxies for the memory it owns.
;; The clients need to be coordinated to ensure that there are no conflicts.
;; (The client ids are defined in globals.wam.)
;;
;; See $memory-copy-sig, $memory-copy, etc below the import section.
;;
;; Clients need to import these tables and fill their entries before calling any
;; block allocation manager functions.
;;
;; ## Algorithms
;;
;; ### Allocation
;;
;; 1. check sized free list
;; 2. check last free list, walk downward
;; 3. provision
;;
;; ### Deallocation
;;
;; ### Defragmentation


(module

 (import "pairs" "dealloc-pair" (func $dealloc-pair (param i32)))
 (import "pairs" "get-pair-car" (func $get-pair-car (param i32)     (result i32)))
 (import "pairs" "get-pair-cdr" (func $get-pair-cdr (param i32)     (result i32)))
 (import "pairs" "make-pair"    (func $make-pair    (param i32 i32) (result i32)))
 (import "pairs" "set-pair-cdr" (func $set-pair-cdr (param i32 i32)))

 (include "./globals.wam")

 ;; Used to store blockset records and the blocksets' quantized free list heads.
 (memory (debug (export "memory")) 1)

 (debug (global $debug (export "#debug") (mut i32) (i32.const 0)))

 (global $blockset-block-list            (debug (export "blockset-block-list"))            i32 (i32.const 0x00))
 (global $blockset-end-block             (debug (export "blockset-end-block"))             i32 (i32.const 0x04))
 (global $blockset-fragment-count        (debug (export "blockset-fragment-count"))        i32 (i32.const 0x08))
 (global $blockset-fragment-counts-base  (debug (export "blockset-fragment-counts-base"))  i32 (i32.const 0x0c))
 (global $blockset-fragment-counts-top   (debug (export "blockset-fragment-counts-top"))   i32 (i32.const 0x10))
 (global $blockset-free-lists-base       (debug (export "blockset-free-lists-base"))       i32 (i32.const 0x14))
 (global $blockset-free-lists-top        (debug (export "blockset-free-lists-top"))        i32 (i32.const 0x18))
 (global $blockset-last-free-list        (debug (export "blockset-last-free-list"))        i32 (i32.const 0x1c))
 (global $blockset-relocation-size-limit (debug (export "blockset-relocation-size-limit")) i32 (i32.const 0x20))
 (global $blockset-sweep-cursor          (debug (export "blockset-sweep-cursor"))          i32 (i32.const 0x24))
 (global $blockset-total-size            (debug (export "blockset-total-size"))            i32 (i32.const 0x28))
 (global $blockset-unused-count          (debug (export "blockset-unused-count"))          i32 (i32.const 0x2c))

 (debug
  (global $blockset-block-count  (export "blockset-block-count")  i32 (i32.const 0x30))
  (global $blockset-free-count   (export "blockset-free-count")   i32 (i32.const 0x34))
  (global $blockset-free-space   (export "blockset-free-space")   i32 (i32.const 0x38)))

 (debug   (global $alloc-precision-bits (export "alloc-precision-bits") (mut i32) (i32.const 4)))
 (release (global $alloc-precision-bits                                      i32  (i32.const 4)))

 (debug   (global $fragment-size-bits (export "fragment-size-bits") (mut i32) (i32.const 4)))
 (release (global $fragment-size-bits                               i32       (i32.const 4)))

 (debug   (global $fragment-size (export "fragment-size") (mut i32) (i32.const 16)))
 (release (global $fragment-size                               i32  (i32.const 16)))

 (global $ref-size      (debug (export "refs-size") i32 (i32.const 0x10)))
 (global $ref-size-bits (debug (export "refs-size-bits") i32 (i32.const 4)))

 (global $refs-top      (debug (export "refs-top"))      (mut i32) (i32.const 0))
 (global $ref-count     (debug (export "ref-count"))     (mut i32) (i32.const 0))
 (global $ref-free-list (debug (export "ref-free-list")) (mut i32) (i32.const 0))

 ;; create 4 KB of block refs (256 * 16 = 4096) when growing storage
 (global $provision-block-ref-count (debug (export "provision-block-ref-count")) i32 (i32.const 256))

 ;; Offsets into a block ref element.
 (global $block-addr           (debug (export "block-addr"))           i32 (i32.const 0x00))
 (global $block-size           (debug (export "block-size"))           i32 (i32.const 0x04))
 (global $block-flags          (debug (export "block-flags"))          i32 (i32.const 0x04))
 (global $block-next-block     (debug (export "block-next-block"))     i32 (i32.const 0x08))
 (global $block-previous-block (debug (export "block-previous-block")) i32 (i32.const 0x0c))

 ;; Flags and masks used to unpack the $block-size/$block-flags value within a
 ;; block ref.
 (global $block-size-mask   (debug (export "block-size-mask")   i32 (i32.const 0x3fffffff)))
 (global $block-flags-mask  (debug (export "block-flags-mask")  i32 (i32.const 0xc0000000)))
 (global $block-free-flag   (debug (export "block-free-flag")   i32 (i32.const 0x80000000)))
 (global $block-unused-flag (debug (export "block-unused-flag") i32 (i32.const 0x40000000)))

 ;; The block manager does not have direct access to the managed memory.
 ;; Instead the clients register proxies for memory.copy, memory.grow, and
 ;; memory.size in the following tables.  See block-mgr-memory-proxies.wam and
 ;; block-mgr-memory-proxy-imports.wam.

 (table $memory-copy (export "memory-copy") 16 funcref)
 (table $memory-grow (export "memory-grow") 16 funcref)
 (table $memory-size (export "memory-size") 16 funcref)

 (type $memory-copy-sig (func (param i32 i32 i32)))
 (type $memory-grow-sig (func (param i32) (result i32)))
 (type $memory-size-sig (func (result i32)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Block Accessors
 ;;

 (macro %get-block-addr
   (expr ,block)
   (i32.load ,block))

 (macro %get-block-flags-addr
   (expr ,block)
   (i32.add ,block (global.get $block-flags)))

 (macro %get-block-size-addr
   (expr ,block)
   (i32.add ,block (global.get $block-size)))

 (macro %get-block-size
   (expr ,block)
   (i32.and (i32.load (%get-block-size-addr ,block))
            (global.get $block-size-mask)))

 (macro %get-next-block
   (expr ,block)
   (i32.load (i32.add ,block (global.get $block-next-block))))

 (macro %get-previous-block
   (expr ,block)
   (i32.load (i32.add ,block (global.get $block-previous-block))))

 (macro %is-allocated-block
   (expr ,block)
   (i32.eqz (i32.and (i32.load (%get-block-flags-addr ,block))
                     (global.get $block-flags-mask))))

 (macro %is-fragment
   (expr ,block)
   (i32.lt_u (%get-block-size ,block) (global.get $fragment-size)))

 (macro %is-free-block
   (expr ,block)
   (i32.and (i32.load (%get-block-flags-addr ,block)) (global.get $block-free-flag)))

 (macro %is-unused-block
   (expr ,block)
   (i32.and (i32.load (%get-block-flags-addr ,block)) (global.get $block-unused-flag)))

 (macro %set-block-addr
   (expr ,block)
   (expr ,addr)
   (i32.store ,block ,addr))

 (macro %set-block-size
   (expr ,block)
   (expr ,size)
   (i32.store (%get-block-size-addr ,block)
              (i32.and ,size (global.get $block-size-mask))))

 (macro %set-next-block
   (expr ,block)
   (expr ,size)
   (i32.store (i32.add ,block (global.get $block-next-block)) ,size))

 (macro %set-previous-block
   (expr ,block)
   (expr ,size)
   (i32.store (i32.add ,block (global.get $block-previous-block)) ,size))

 (debug
  (func $get-block-addr (export "get-block-addr")
    (param $block i32)
    (result i32)
    (%get-block-addr (local.get $block)))

  (func $get-block-size (export "get-block-size")
    (param $block i32)
    (result i32)
    (%get-block-size (local.get $block)))

  (func $get-next-block (export "get-next-block")
    (param $block i32)
    (result i32)
    (%get-next-block (local.get $block)))

  (func $get-previous-block (export "get-previous-block")
    (param $block i32)
    (result i32)
    (%get-previous-block (local.get $block)))

  (func $is-allocated-block (export "is-allocated-block")
    (param $block i32)
    (result i32)
    (%is-allocated-block (local.get $block)))

  (func $is-free-block (export "is-free-block")
    (param $block i32)
    (result i32)
    (%is-free-block (local.get $block)))

  (func $is-unused-block (export "is-unused-block")
    (param $block i32)
    (result i32)
    (%is-unused-block (local.get $block)))

  (func $set-block-addr (export "set-block-addr")
    (param $block i32)
    (param $addr i32)
    (%set-block-addr (local.get $block) (local.get $addr)))

  (func $set-block-size (export "set-block-size")
    (param $block i32)
    (param $size i32)
    (%set-block-size (local.get $block) (local.get $size))))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Block Utilities
 ;;

 (macro %get-next-block-addr
   (expr ,block)
   (i32.add (%get-block-addr ,block) (%get-block-size ,block)))

 (func $mark-block-allocated (debug (export "mark-block-allocated"))
   (param $block i32)

   (local $addr i32)
   (local $size-flags i32)

   (local.set $addr (%get-block-size-addr (local.get $block)))
   (local.set $size-flags (i32.load (local.get $addr)))

   (i32.store (local.get $addr) (i32.and (local.get $size-flags)
                                         (global.get $block-size-mask))))

 (func $mark-block-free (debug (export "mark-block-free"))
   (param $block i32)

   (local $addr i32)
   (local $size-flags i32)

   (local.set $addr (%get-block-size-addr (local.get $block)))
   (local.set $size-flags (i32.load (local.get $addr)))

   (i32.store (local.get $addr) (i32.or (local.get $size-flags)
                                        (global.get $block-free-flag))))

 (func $mark-block-unused (debug (export "mark-block-unused"))
   (param $block i32)

   (local $addr i32)
   (local $size-flags i32)

   (local.set $addr (%get-block-size-addr (local.get $block)))
   (local.set $size-flags (i32.load (local.get $addr)))

   (i32.store (local.get $addr) (i32.or (local.get $size-flags)
                                        (global.get $block-unused-flag))))

 (debug
  (func $get-next-block-addr (export "get-next-block-addr")
    (param $block i32)
    (result i32)
    (%get-next-block-addr (local.get $block))))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Blockset Accessors
 ;;

 (macro %get-blockset
   (expr ,blockset-id)
   (i32.shl ,blockset-id (global.get $blockset-size-bits)))

 (macro %get-blockset-block-count
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-block-count))))

 (macro %get-blockset-block-list
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-block-list))))

 (macro %get-blockset-last-free-list
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-last-free-list))))

 (macro %get-blockset-end-block
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-end-block))))

 (macro %get-blockset-fragment-count
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-fragment-count))))

 (macro %get-blockset-free-count
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-free-count))))

 (macro %get-blockset-fragment-counts-base
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-fragment-counts-base))))

 (macro %get-blockset-fragment-counts-top
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-fragment-counts-top))))

 (macro %get-blockset-free-lists-base
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-free-lists-base))))

 (macro %get-blockset-free-lists-top
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-free-lists-top))))

 (macro %get-blockset-free-space
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-free-space))))

 (macro %get-blockset-relocation-size-limit
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-relocation-size-limit))))

 (macro %get-blockset-sweep-cursor
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-sweep-cursor))))

 (macro %get-blockset-total-size
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-total-size))))

 (macro %get-blockset-unused-count
   (expr ,blockset)
   (i32.load (i32.add ,blockset (global.get $blockset-unused-count))))

 (macro %set-blockset-block-count
   (expr ,blockset)
   (expr ,block-count)
   (i32.store (i32.add ,blockset (global.get $blockset-block-count))
              ,block-count))

 (macro %set-blockset-fragment-count
   (expr ,blockset)
   (expr ,fragment-count)
   (i32.store (i32.add ,blockset (global.get $blockset-fragment-count))
              ,fragment-count))

 (macro %set-blockset-free-count
   (expr ,blockset)
   (expr ,free-count)
   (i32.store (i32.add ,blockset (global.get $blockset-free-count))
              ,free-count))

 (macro %set-blockset-sweep-cursor
   (expr ,blockset)
   (expr ,sweep-cursor)
   (i32.store (i32.add ,blockset (global.get $blockset-sweep-cursor))
              ,sweep-cursor))

 (macro %set-blockset-total-size
   (expr ,blockset)
   (expr ,total-size)
   (i32.store (i32.add ,blockset (global.get $blockset-total-size))
              ,total-size))

 (macro %set-blockset-unused-count
   (expr ,blockset)
   (expr ,unused-count)
   (i32.store (i32.add ,blockset (global.get $blockset-unused-count))
              ,unused-count))

 (macro %set-blockset-block-list
   (expr ,blockset)
   (expr ,block-list)
   (i32.store (i32.add ,blockset (global.get $blockset-block-list))
              ,block-list))

 (macro %set-blockset-fragment-counts-base
   (expr ,blockset)
   (expr ,fragment-counts-base)
   (i32.store (i32.add ,blockset (global.get $blockset-fragment-counts-base))
              ,fragment-counts-base))

 (macro %set-blockset-fragment-counts-top
   (expr ,blockset)
   (expr ,fragment-counts-top)
   (i32.store (i32.add ,blockset (global.get $blockset-fragment-counts-top))
              ,fragment-counts-top))

 (macro %set-blockset-free-lists-base
   (expr ,blockset)
   (expr ,free-lists-base)
   (i32.store (i32.add ,blockset (global.get $blockset-free-lists-base))
              ,free-lists-base))

 (macro %set-blockset-free-lists-top
   (expr ,blockset)
   (expr ,free-lists-top)
   (i32.store (i32.add ,blockset (global.get $blockset-free-lists-top))
              ,free-lists-top))

 (macro %set-blockset-last-free-list
   (expr ,blockset)
   (expr ,last-free-list)
   (i32.store (i32.add ,blockset (global.get $blockset-last-free-list))
              ,last-free-list))

 (macro %set-blockset-end-block
   (expr ,blockset)
   (expr ,end-block)
   (i32.store (i32.add ,blockset (global.get $blockset-end-block))
              ,end-block))

 (macro %set-blockset-relocation-size-limit
   (expr ,blockset)
   (expr ,relocation-size-limit)
   (i32.store (i32.add ,blockset (global.get $blockset-relocation-size-limit))
              ,relocation-size-limit))

 (macro %set-blockset-free-space
   (expr ,blockset)
   (expr ,free-space)
   (i32.store (i32.add ,blockset (global.get $blockset-free-space))
              ,free-space))

 (func $get-blockset-relocation-size-limit (export "get-blockset-relocation-size-limit")
   (param $blockset i32)
   (result i32)
   (%get-blockset-relocation-size-limit (local.get $blockset)))

 (func $set-blockset-relocation-size-limit (export "set-blockset-relocation-size-limit")
   (param $blockset i32)
   (param $relocation-size-limit i32)
   (%set-blockset-relocation-size-limit (local.get $blockset) (local.get $relocation-size-limit)))

 (debug
  (func $get-blockset (export "get-blockset")
    (param $blockset-id i32)
    (result i32)
    (%get-blockset (local.get $blockset-id)))

  (func $get-blockset-id (export "get-blockset-id")
    (param $blockset i32)
    (result i32)
    (%get-blockset-id (local.get $blockset)))

  (func $get-blockset-block-count (export "get-blockset-block-count")
    (param $blockset i32)
    (result i32)
    (%get-blockset-block-count (local.get $blockset)))

  (func $get-blockset-block-list (export "get-blockset-block-list")
    (param $blockset i32)
    (result i32)
    (%get-blockset-block-list (local.get $blockset)))

  (func $get-blockset-last-free-list (export "get-blockset-last-free-list")
    (param $blockset i32)
    (result i32)
    (%get-blockset-last-free-list (local.get $blockset)))

  (func $get-blockset-end-block (export "get-blockset-end-block")
    (param $blockset i32)
    (result i32)
    (%get-blockset-end-block (local.get $blockset)))

  (func $get-blockset-fragment-count (export "get-blockset-fragment-count")
    (param $blockset i32)
    (result i32)
    (%get-blockset-fragment-count (local.get $blockset)))

  (func $get-blockset-free-count (export "get-blockset-free-count")
    (param $blockset i32)
    (result i32)
    (%get-blockset-free-count (local.get $blockset)))

  (func $get-blockset-fragment-counts-base (export "get-blockset-fragment-counts-base")
    (param $blockset i32)
    (result i32)
    (%get-blockset-fragment-counts-base (local.get $blockset)))

  (func $get-blockset-fragment-counts-top (export "get-blockset-fragment-counts-top")
    (param $blockset i32)
    (result i32)
    (%get-blockset-fragment-counts-top (local.get $blockset)))

  (func $get-blockset-free-lists-base (export "get-blockset-free-lists-base")
    (param $blockset i32)
    (result i32)
    (%get-blockset-free-lists-base (local.get $blockset)))

  (func $get-blockset-free-lists-top (export "get-blockset-free-lists-top")
    (param $blockset i32)
    (result i32)
    (%get-blockset-free-lists-top (local.get $blockset)))

  (func $get-blockset-free-space (export "get-blockset-free-space")
    (param $blockset i32)
    (result i32)
    (%get-blockset-free-space (local.get $blockset)))

  (func $get-blockset-unused-count (export "get-blockset-unused-count")
    (param $blockset i32)
    (result i32)
    (%get-blockset-unused-count (local.get $blockset)))

  (func $set-blockset-block-count (export "set-blockset-block-count")
    (param $blockset i32)
    (param $block-count i32)
    (%set-blockset-block-count (local.get $blockset) (local.get $block-count)))

  (func $set-blockset-block-list (export "set-blockset-block-list")
    (param $blockset i32)
    (param $block-list i32)
    (%set-blockset-block-list (local.get $blockset) (local.get $block-list)))

  (func $set-blockset-last-free-list (export "set-blockset-last-free-list")
    (param $blockset i32)
    (param $last-free-list i32)
    (%set-blockset-last-free-list (local.get $blockset) (local.get $last-free-list)))

  (func $set-blockset-end-block (export "set-blockset-end-block")
    (param $blockset i32)
    (param $end-block i32)
    (%set-blockset-end-block (local.get $blockset) (local.get $end-block))))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Blockset Utilities
 ;;

 (func $decr-blockset-fragment-count (debug (export "decr-blockset-fragment-count"))
   (param $blockset i32)
   (param $size i32)
   (local $addr i32)

   (local.set $addr (i32.add (local.get $blockset) (global.get $blockset-fragment-count)))
   (i32.store (local.get $addr) (i32.sub (i32.load (local.get $addr)) (i32.const 1)))

   (local.set $addr (i32.add (%get-blockset-fragment-counts-base (local.get $blockset))
                             (i32.shl (local.get $size)
                                      (global.get $value-size-bits))))

   (i32.store (local.get $addr) (i32.sub (i32.load (local.get $addr)) (i32.const 1))))

 (func $incr-blockset-fragment-count (debug (export "incr-blockset-fragment-count"))
   (param $blockset i32)
   (param $size i32)
   (local $addr i32)
   (local.set $addr (i32.add (local.get $blockset) (global.get $blockset-fragment-count)))
   (i32.store (local.get $addr) (i32.add (i32.load (local.get $addr)) (i32.const 1)))

   (local.set $addr (i32.add (%get-blockset-fragment-counts-base (local.get $blockset))
                             (i32.shl (local.get $size)
                                      (global.get $value-size-bits))))

   (i32.store (local.get $addr) (i32.add (i32.load (local.get $addr)) (i32.const 1))))

 (debug
  (func $decr-blockset-block-count (debug (export "decr-blockset-block-count"))
    (param $blockset i32)
    (local $addr i32)
    (local.set $addr (i32.add (local.get $blockset) (global.get $blockset-block-count)))
    (i32.store (local.get $addr) (i32.sub (i32.load (local.get $addr)) (i32.const 1))))

  (func $decr-blockset-free-count (debug (export "decr-blockset-free-count"))
    (param $blockset i32)
    (local $addr i32)
    (local.set $addr (i32.add (local.get $blockset) (global.get $blockset-free-count)))
    (i32.store (local.get $addr) (i32.sub (i32.load (local.get $addr)) (i32.const 1))))

  (func $decr-blockset-unused-count (debug (export "decr-blockset-unused-count"))
    (param $blockset i32)
    (local $addr i32)
    (local.set $addr (i32.add (local.get $blockset) (global.get $blockset-unused-count)))
    (i32.store (local.get $addr) (i32.sub (i32.load (local.get $addr)) (i32.const 1))))

  (func $incr-blockset-block-count (debug (export "incr-blockset-block-count"))
    (param $blockset i32)
    (local $addr i32)
    (local.set $addr (i32.add (local.get $blockset) (global.get $blockset-block-count)))
    (i32.store (local.get $addr) (i32.add (i32.load (local.get $addr)) (i32.const 1))))

  (func $incr-blockset-free-count (debug (export "incr-blockset-free-count"))
    (param $blockset i32)
    (local $addr i32)
    (local.set $addr (i32.add (local.get $blockset) (global.get $blockset-free-count)))
    (i32.store (local.get $addr) (i32.add (i32.load (local.get $addr)) (i32.const 1))))

  (func $incr-blockset-unused-count (debug (export "incr-blockset-unused-count"))
    (param $blockset i32)
    (local $addr i32)
    (local.set $addr (i32.add (local.get $blockset) (global.get $blockset-unused-count)))
    (i32.store (local.get $addr) (i32.add (i32.load (local.get $addr)) (i32.const 1)))))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; List Items
 ;;
 ;;

 (func $link-refs (debug (export "link-refs"))

   ;; Links the two block refs. If $a is null, then it implicitly references
   ;; the blockset's block list head; similarly if $b is null, the end block
   ;; ref is updated.

   (param $blockset i32)
   (param $a i32)
   (param $b i32)

   (if (i32.eq (local.get $a) (global.get $null))
       (then
        (%set-blockset-block-list (local.get $blockset) (local.get $b)))
     (else
      (%set-next-block (local.get $a) (local.get $b))))

   (if (i32.eq (local.get $b) (global.get $null))
       (then
        (%set-blockset-end-block (local.get $blockset) (local.get $a)))
     (else
      (%set-previous-block (local.get $b) (local.get $a)))))

 (macro %calc-fragment-counts-area-base
   (i32.mul (global.get $blockset-size) (global.get $blockset-count)))

 (macro %calc-blockset-fragment-counts-area-size
   (i32.shl (global.get $fragment-size)
            (global.get $value-size-bits)))

 (macro %calc-free-lists-area-base
   (i32.add (%calc-fragment-counts-area-base)
            (i32.mul (global.get $blockset-count)
                     (%calc-blockset-fragment-counts-area-size))))

 (macro %calc-blockset-free-lists-area-size
   (i32.shl (i32.const 30)
            (i32.add (global.get $alloc-precision-bits)
                     (global.get $value-size-bits))))

 (macro %calc-initial-refs-top
   (i32.add (%calc-free-lists-area-base)
            (i32.mul (global.get $blockset-count)
                     (%calc-blockset-free-lists-area-size))))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Module Initialization
 ;;
 ;;

 (start $init-blockset-manager)
 (func $init-blockset-manager (debug (export "init-blockset-manager"))
   (global.set $refs-top (%calc-initial-refs-top))
   (global.set $ref-count (i32.const 0))
   (global.set $ref-free-list (global.get $null)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Blockset Initialization
 ;;
 ;;

 (func $init-blockset (export "init-blockset")
   (param $blockset i32)
   (param $relocation-size-limit i32)

   (local $blockset-id i32)
   (local $fragment-counts-base i32)
   (local $fragment-counts-size i32)
   (local $fragment-counts-top i32)
   (local $free-lists-base i32)
   (local $free-lists-size i32)
   (local $free-lists-top i32)

   (local.set $blockset-id (%get-blockset-id (local.get $blockset)))

   (%set-blockset-relocation-size-limit (local.get $blockset) (local.get $relocation-size-limit))

   (%set-blockset-block-list     (local.get $blockset) (global.get $null))
   (%set-blockset-end-block      (local.get $blockset) (global.get $null))
   (%set-blockset-fragment-count (local.get $blockset) (i32.const 0))
   (%set-blockset-total-size     (local.get $blockset) (i32.const 0))
   (%set-blockset-unused-count   (local.get $blockset) (i32.const 0))

   (debug
    (%set-blockset-block-count    (local.get $blockset) (i32.const 0))
    (%set-blockset-free-count     (local.get $blockset) (i32.const 0))
    (%set-blockset-free-space     (local.get $blockset) (i32.const 0)))

   (local.set $fragment-counts-size (%calc-blockset-fragment-counts-area-size))

   (local.set $fragment-counts-base
              (i32.add (%calc-fragment-counts-area-base)
                       (i32.mul (local.get $blockset-id)
                                (local.get $fragment-counts-size))))

   (local.set $fragment-counts-top
              (i32.add (local.get $fragment-counts-base)
                       (local.get $fragment-counts-size)))

   (%set-blockset-fragment-counts-base (local.get $blockset) (local.get $fragment-counts-base))
   (%set-blockset-fragment-counts-top (local.get $blockset) (local.get $fragment-counts-top))

   (memory.fill (local.get $fragment-counts-base) (i32.const 0) (local.get $fragment-counts-size))

   (local.set $free-lists-size (%calc-blockset-free-lists-area-size))

   (local.set $free-lists-base
              (i32.add (%calc-free-lists-area-base)
                       (i32.mul (local.get $blockset-id)
                                (local.get $free-lists-size))))

   (local.set $free-lists-top
              (i32.add (local.get $free-lists-base)
                       (local.get $free-lists-size)))

   (%set-blockset-free-lists-base (local.get $blockset) (local.get $free-lists-base))
   (%set-blockset-free-lists-top (local.get $blockset) (local.get $free-lists-top))
   (%set-blockset-last-free-list (local.get $blockset) (local.get $free-lists-base))
   (%set-blockset-sweep-cursor (local.get $blockset) (local.get $free-lists-base))

   (memory.fill (local.get $free-lists-base) (global.get $null) (local.get $free-lists-size)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Block Refs
 ;;
 ;; This is essentially just a copy of the functionality in the pairs module.
 ;; It could probably be abstracted into a macro or set of macros, though
 ;; that might just make it more difficult to understand.

 (func $make-ref (export "make-ref")
   (param $addr i32)
   (param $size i32)
   (result i32)

   (local $ref-addr i32)

   (if (i32.eq (global.get $ref-free-list) (global.get $null))
       (then
        (call $provision-block-refs (global.get $provision-block-ref-count))))

   (debug
    (%global.incr i32 $ref-count))

   (local.set $ref-addr (global.get $ref-free-list))
   (global.set $ref-free-list (i32.load (global.get $ref-free-list)))

   (%set-block-addr (local.get $ref-addr) (local.get $addr))
   (%set-block-size (local.get $ref-addr) (local.get $size))

   (local.get $ref-addr))

 (func $provision-block-refs (debug (export "provision-block-refs"))
   (param $count i32)

   (local $bytes-required i32)
   (local $new-top i32)
   (local $pages-required i32)

   (local.set $new-top (i32.add (global.get $refs-top)
                                (i32.shl (local.get $count)
                                         (global.get $ref-size-bits))))

   (local.set $bytes-required (i32.sub (local.get $new-top)
                                       (i32.shl (memory.size)
                                                (global.get $page-size-bits))))

   (if (i32.gt_s (local.get $bytes-required) (i32.const 0))
       (then
        (local.set $pages-required (i32.add (i32.shr_u (i32.sub (local.get $bytes-required)
                                                                (i32.const 1))
                                                       (global.get $page-size-bits))
                                            (i32.const 1)))

        (drop (memory.grow (local.get $pages-required)))))

   (call $fill-ref-free-list (local.get $count)))

 (func $fill-ref-free-list (debug (export "fill-ref-free-list"))
   (param $count i32)

   (local $next-ref i32)
   (local $ref i32)
   (local $top i32)

   (local.set $ref (global.get $refs-top))

   (local.set $top (i32.add (i32.shl (local.get $count)
                                     (global.get $ref-size-bits))
                            (global.get $refs-top)))

   (loop $again
     (local.set $next-ref (i32.add (local.get $ref) (global.get $ref-size)))
     (if (i32.lt_u (local.get $next-ref) (local.get $top))
         (then
          (%set-block-addr (local.get $ref) (local.get $next-ref))
          (debug
           ;; Mark freshly-initialized refs with a distinctive bit pattern
           (%set-block-size (local.get $ref) (i32.const 0x0badce11)))
          (local.set $ref (local.get $next-ref))
          (br $again))
       (else
        (i32.store (local.get $ref) (global.get $ref-free-list)))))

   (global.set $ref-free-list (global.get $refs-top))
   (global.set $refs-top (local.get $top)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Ref Deallocation
 ;;

 (func $dealloc-ref (export "dealloc-ref")
   (param $ref i32)

   (%set-block-addr (local.get $ref) (global.get $ref-free-list))

   (debug
    ;; Mark deallocated refs with a distinctive bit pattern
    (%set-block-size (local.get $ref) (i32.const 0x0badce11))
    (%global.decr i32 $ref-count))

   (global.set $ref-free-list (local.get $ref)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Allocation
 ;;

 ;; This is used in test/test_block_mgr.py::test_stochastic.  The average of
 ;; many calls to this stub should account for the overhead of calling
 ;; alloc-block so that the performance of alloc-block's internals can be more
 ;; precisely measured.

 (func $stub-alloc-block (export "stub-alloc-block")
   (param $blockset i32)
   (param $size i32)
   (result i32)
   (global.get $null))

 (macro %select-blockset-free-list
   (expr ,blockset)
   (expr ,size)
   (i32.add (%get-blockset-free-lists-base ,blockset)
            (call $calc-free-list-offset ,size)))

 (debug
  (func $select-blockset-free-list (export "select-blockset-free-list")
    (param $blockset i32)
    (param $size i32)
    (result i32)
    (%select-blockset-free-list (local.get $blockset) (local.get $size)))

  (func $get-free-list-head (export "get-free-list-head")
    (param $free-list i32)
    (result i32)
    (i32.load (local.get $free-list))))

 (func $alloc-block (export "alloc-block")
   (param $blockset i32)
   (param $size i32)
   (result i32)

   (local $base-free-list i32)
   (local $block i32)
   (local $free-block-size i32)
   (local $free-list i32)
   (local $new-block i32)

   (debug
    (if (i32.eqz (local.get $size))
        (then
         (return (global.get $null)))))

   ;; $quantize-size is used here to round up the requested size to the next
   ;; larger free list.  This ensures that every block in the selected free list
   ;; is big enough to satisfy the allocation.

   (local.set $free-list (%select-blockset-free-list (local.get $blockset)
                                                     (call $quantize-size (local.get $size))))

   ;; Returns the first block in the free list, or null if the list was empty.

   (local.set $block (call $pop-free-block (local.get $blockset) (local.get $free-list)))

   (if (i32.eq (local.get $block) (global.get $null))
       (then

        ;; The selected free list was empty.  Search for a large block to split a
        ;; piece off of.  Most of the larger free lists, for sizes 2^24 and up are
        ;; probably going to be empty most of the time, so we start from the last
        ;; free list where a large block was retrieved from.

        (local.set $base-free-list (local.get $free-list))
        (local.set $free-list (%get-blockset-last-free-list (local.get $blockset)))
        ;; (local.set $free-list (i32.sub (%get-blockset-free-lists-top (local.get $blockset))
        ;;                                (global.get $value-size)))

        (loop $again
          (if (i32.gt_u (local.get $free-list) (local.get $base-free-list))
              (then
               (local.set $block
                          (call $pop-free-block (local.get $blockset) (local.get $free-list)))
               (if (i32.eq (local.get $block) (global.get $null))
                   (then
                    ;; List empty, try the next lower size.
                    (%decr-n i32 $free-list #value-size)
                    (br $again))))))

        ;; A block was found, update the last free list so the next time this
        ;; code is encountered, we're likely to only run through the loop once.
        (if (i32.ne (local.get $block) (global.get $null))
            (then
             (%set-blockset-last-free-list (local.get $blockset) (local.get $free-list))))))

   (if (i32.eq (local.get $block) (global.get $null))
       (then
        ;; The free lists do not contain a block big enough to satisfy the
        ;; request, so create a new large free block out of one or more
        ;; additional memory pages.
        (local.set $block (call $provision-free-block (local.get $blockset) (local.get $size)))))

   ;; If the block is more than just a little too big, split it and put the
   ;; remainder into the appropriate free list.

   (local.set $free-block-size (%get-block-size (local.get $block)))

   (if (i32.ne (local.get $size) (local.get $free-block-size))
       (then
        (if (i32.or (i32.lt_u (local.get $size) (global.get $fragment-size))
                    (i32.ge_u (i32.sub (local.get $size) (local.get $free-block-size))
                              (global.get $fragment-size)))
            (then
             (call $split-free-block (local.get $blockset) (local.get $block) (local.get $size))))))

   ;; Update the block's status.
   (call $mark-block-allocated (local.get $block))

   (debug
    ;; A little bit of accounting.
    (%set-blockset-free-space (local.get $blockset)
                              (i32.sub (%get-blockset-free-space (local.get $blockset))
                                       (local.get $size))))

   (local.get $block))

 (func $quantize-size (debug (export "quantize-size"))

   ;; todo reword

   ;; One of the memory efficiency versus CPU efficiency trade-offs that can be
   ;; made is either to allocate precisely the amount requested and have a
   ;; longer free list, and therefore increased search and maintenance time, or
   ;; to allocate approximately and have a smaller free list.  This function is
   ;; part of the latter approach.  Essentially, it reduces the precision of the
   ;; requested size, so that for example, a request for 207 bytes would be
   ;; rounded up to 208 since 207 = 0xcf = 0b11001111, and below we only
   ;; use 4 bits of precision, so that gives 0b11010000 = 0xd0 = 208.  If only
   ;; 3 bits were used, then we would have rounded up to 0b11100000 = 0xe0 = 224.

   (param $size i32)
   (result i32)

   (local $mask i32)
   (local $rank i32)

   (local.set $rank (%rank i32 (local.get $size)))

   (if (i32.le_u (local.get $rank) (global.get $alloc-precision-bits))
       (then
        (local.set $mask (i32.const 0)))
     (else
      (local.set $mask (i32.sub (i32.shl (i32.const 1)
                                         (i32.sub (local.get $rank)
                                                  (global.get $alloc-precision-bits)))
                                (i32.const 1)))))

   (i32.and (i32.add (local.get $size) (local.get $mask))
            (i32.xor (local.get $mask) (i32.const -1))))

 (func $calc-free-list-offset (debug (export "calc-free-list-offset"))
   (param $size i32)
   (result i32)

   (local $rank i32)
   (local $rank-shift i32)

   (local.set $rank (%rank i32 (local.get $size)))

   (if (i32.le_u (local.get $rank) (global.get $alloc-precision-bits))
       (then
        (local.set $rank-shift (i32.const 0)))
     (else
      (local.set $rank-shift (i32.sub (local.get $rank)
                                      (global.get $alloc-precision-bits)))))

   (i32.shl (i32.add (i32.shr_u (local.get $size)
                                (local.get $rank-shift))
                     (i32.shl (local.get $rank-shift)
                              (i32.sub (global.get $alloc-precision-bits)
                                       (i32.const 1))))
            (global.get $value-size-bits)))

 (func $pop-free-block (debug (export "pop-free-block"))
   (param $blockset i32)
   (param $free-list i32)
   (result i32)

   (local $block i32)
   (local $head i32)
   (local $next i32)

   (local.set $block (global.get $null))
   (local.set $head (i32.load (local.get $free-list)))

   (loop $again
     (if (i32.ne (local.get $head) (global.get $null))
         (then
          (local.set $block (call $get-pair-car (local.get $head)))
          (local.set $next (call $get-pair-cdr (local.get $head)))

          (call $dealloc-pair (local.get $head))
          (local.set $head (local.get $next))

          (if (%is-unused-block (local.get $block))
              (then
               (call $dealloc-ref (local.get $block))
               (local.set $block (global.get $null))

               (call $decr-blockset-unused-count (local.get $blockset))

               (br $again))))))

   (i32.store (local.get $free-list) (local.get $head))

   (if (i32.ne (local.get $block) (global.get $null))
       (then

        (debug
         (call $decr-blockset-free-count (local.get $blockset)))

        (if (%is-fragment (local.get $block))
            (then
             (call $decr-blockset-fragment-count
                   (local.get $blockset)
                   (%get-block-size (local.get $block)))))))

   (local.get $block))

 (func $provision-free-block (debug (export "provision-free-block"))
   (param $blockset i32)
   (param $size i32)
   (result i32)

   (local $block i32)
   (local $block-addr i32)
   (local $blockset-id i32)
   (local $end-block i32)
   (local $end-page i32)
   (local $free-pages i32)
   (local $free-size i32)
   (local $page-count i32)
   (local $total-pages i32)

   (local.set $blockset-id (%get-blockset-id (local.get $blockset)))

   (local.set $page-count (i32.add (i32.shr_u (i32.sub (local.get $size)
                                                       (i32.const 1))
                                              (global.get $page-size-bits))
                                   (i32.const 1)))

   (local.set $total-pages (call_indirect
                            $memory-size
                            (type $memory-size-sig)
                            (local.get $blockset-id)))

   (local.set $end-block (%get-blockset-end-block (local.get $blockset)))

   (if (i32.eq (local.get $end-block) (global.get $null))
       (then
        (local.set $free-pages (local.get $total-pages))
        (local.set $block-addr (i32.const 0)))

     (else
      (local.set $end-page (i32.shr_u (%get-next-block-addr (local.get $end-block))
                                      (global.get $page-size-bits)))

      (local.set $free-pages (i32.sub (local.get $total-pages) (local.get $end-page)))

      (local.set $block-addr (%get-next-block-addr (local.get $end-block)))))

   (if (i32.lt_u (local.get $free-pages) (local.get $page-count))
       (then
        (drop (call_indirect $memory-grow
                             (type $memory-grow-sig)
                             (i32.sub (local.get $page-count)
                                      (local.get $free-pages))
                             (local.get $blockset-id)))))

   (local.set $free-size (i32.shl (local.get $page-count)
                                  (global.get $page-size-bits)))

   (local.set $block (call $make-ref
                           (local.get $block-addr)
                           (local.get $free-size)))

   (call $link-refs (local.get $blockset) (local.get $end-block) (local.get $block))
   (call $link-refs (local.get $blockset) (local.get $block) (global.get $null))

   (debug
    (call $incr-blockset-block-count (local.get $blockset))

    (%set-blockset-free-space (local.get $blockset)
                              (i32.add (%get-blockset-free-space (local.get $blockset))
                                       (local.get $free-size))))

   (%set-blockset-total-size (local.get $blockset)
                             (i32.add (%get-blockset-total-size (local.get $blockset))
                                      (local.get $free-size)))
   (local.get $block))

 (func $split-free-block (debug (export "split-free-block"))
   (param $blockset i32)
   (param $block i32)
   (param $split-size i32)

   (local $free-size i32)
   (local $new-block i32)
   (local $next-block i32)
   (local $remainder-size i32)

   (local.set $free-size (%get-block-size (local.get $block)))

   (local.set $remainder-size
              (i32.sub (local.get $free-size) (local.get $split-size)))

   (local.set $next-block (%get-next-block (local.get $block)))

   (local.set $new-block (call $make-ref
                               (i32.add (%get-block-addr (local.get $block))
                                        (local.get $split-size))
                               (local.get $remainder-size)))

   (%set-block-size (local.get $block) (local.get $split-size))

   (call $link-refs (local.get $blockset) (local.get $block) (local.get $new-block))
   (call $link-refs (local.get $blockset) (local.get $new-block) (local.get $next-block))

   (debug
    (call $incr-blockset-block-count (local.get $blockset)))

   (call $add-free-block (local.get $blockset) (local.get $new-block)))


 ;;-----------------------------------------------------------------------------
 ;;
 ;; Resize Block
 ;;

 (func $resize-block (export "resize-block")
   (param $blockset i32)
   (param $block i32)
   (param $new-size i32)
   (result i32)

   (local $new-block i32)
   (local $old-size i32)
   (local $size i32)

   (local.set $new-block (call $alloc-block (local.get $blockset) (local.get $new-size)))

   (local.set $old-size (%get-block-size (local.get $block)))

   (local.set $size (if (result i32) (i32.gt_u (local.get $new-size) (local.get $old-size))
                      (then (local.get $old-size))
                      (else (local.get $new-size))))

   (call_indirect $memory-copy
                  (type $memory-copy-sig)
                  (%get-block-addr (local.get $new-block))
                  (%get-block-addr (local.get $block))
                  (local.get $size)
                  (local.get $blockset))

   (call $dealloc-block (local.get $blockset) (local.get $block))

   (local.get $new-block))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Deallocation
 ;;

 ;; This is used in test/test_block_mgr.py::test_stochastic.  The average of
 ;; many calls to this stub should account for the overhead of calling
 ;; dealloc-block so that the performance of dealloc-block's internals can be
 ;; more precisely measured.

 (func $stub-dealloc-block (export "stub-dealloc-block")
   (param $blockset i32)
   (param $block i32))

 (func $dealloc-block (export "dealloc-block")
   (param $blockset i32)
   (param $block i32)

   (local $size i32)

   (debug
    (if (i32.eq (local.get $block) (global.get $null))
        (then
         (return))))

   (local.set $size (%get-block-size (local.get $block)))

   (call $add-free-block (local.get $blockset) (local.get $block))

   (debug
    (%set-blockset-free-space (local.get $blockset)
                              (i32.add (%get-blockset-free-space (local.get $blockset))
                                       (local.get $size))))

   ;; If the number of fragments times the relocation size limit is greater than
   ;; the total amount of memory managed by this blockset, then each time a
   ;; fragment is relocated, it will very likely be able to be merged into a
   ;; nearby free block, thus eliminating the fragment.

   (if (i32.gt_u (i32.mul (%get-blockset-fragment-count (local.get $blockset))
                          (%get-blockset-relocation-size-limit (local.get $blockset)))
                 (%get-blockset-total-size (local.get $blockset)))
       (then
        (call $step-defragment-blockset (local.get $blockset))
        (if (i32.gt_u (%get-blockset-unused-count (local.get $blockset))
                      (%get-blockset-free-count (local.get $blockset)))
            (call $step-clean-free-lists (local.get $blockset))))))

 (func $add-free-block (debug (export "add-free-block"))

   ;; Adds the block to the appropriate free list, based on the block's size.

   (param $blockset i32)
   (param $block i32)

   (local $free-list i32)
   (local $last-free-list i32)
   (local $size i32)

   (local.set $size (%get-block-size (local.get $block)))

   (local.set $free-list (%select-blockset-free-list (local.get $blockset) (local.get $size)))

   (i32.store (local.get $free-list)
              (call $make-pair
                    (local.get $block)
                    (i32.load (local.get $free-list))))

   (call $mark-block-free (local.get $block))

   (debug
    (call $incr-blockset-free-count (local.get $blockset)))

   (if (i32.lt_u (local.get $size) (global.get $fragment-size))
       (then
        (call $incr-blockset-fragment-count (local.get $blockset) (local.get $size))))

   (local.set $last-free-list (%get-blockset-last-free-list (local.get $blockset)))

   (if (i32.gt_u (local.get $free-list) (local.get $last-free-list))
       (then
        (%set-blockset-last-free-list (local.get $blockset) (local.get $free-list)))))

 (func $step-defragment-blockset (debug (export "step-defragment-blockset"))

   ;; Makes one step of incremental defragmentation. That consists of taking the
   ;; first item from each free list which contains a fragment, and attempting
   ;; to merge it with some block or blocks within the relocation size limit
   ;; above it.  It pops one free block from each list to distribute the
   ;; activity across block sizes, otherwise, one free list might become empty,
   ;; causing unnecessary block splits (and block splits are computationally
   ;; more expensive than reuse).

   (param $blockset i32)

   (local $average i32)
   (local $count-addr i32)
   (local $free-list i32)
   (local $half-average i32)
   (local $size i32)

   (local.set $average (i32.shr_u (%get-blockset-fragment-count (local.get $blockset))
                                  (global.get $fragment-size-bits)))

   (local.set $count-addr (i32.add (%get-blockset-fragment-counts-base (local.get $blockset))
                                   (global.get $value-size)))

   (local.set $free-list (i32.add (%get-blockset-free-lists-base (local.get $blockset))
                                  (global.get $value-size)))

   (local.set $half-average (i32.shr_u (local.get $average) (i32.const 1)))

   (local.set $size (i32.const 1))

   (loop $again

     (call $defragment-free-list
           (local.get $blockset)
           (local.get $free-list)
           (i32.add (i32.load (local.get $count-addr)) (local.get $half-average))
           (local.get $average))

     (if (i32.lt_u (local.get $size) (global.get $fragment-size))
         (then
          (%incr-n i32 $free-list #value-size)
          (%incr-n i32 $count-addr #value-size)
          (%incr i32 $size)
          (br $again)))))


 (func $defragment-free-list (debug (export "defragment-free-list"))

   ;; Pops floor(count/average) free blocks from the given free list.  Unused
   ;; blocks are deallocated without being part of the count.  Each block will
   ;; be merged with any immediately following free blocks, and if the after that
   ;; the block is still a fragment, then it will be moved upward in memory
   ;; any for each coalescing it with any free neighbors, e

   (param $blockset i32)
   (param $free-list i32)
   (param $count i32)
   (param $average i32)

   (local $block i32)
   (local $next i32)
   (local $relocated i32)

   (local.set $relocated (global.get $null))

   (loop $relocate
     (if (i32.ge_u (local.get $count) (local.get $average))
         (then
          (local.set $block (call $pop-free-block (local.get $blockset) (local.get $free-list)))
          (if (i32.ne (local.get $block) (global.get $null))
              (then

               ;; Join the free block with any adjacent free blocks above it

               (call $coalesce-free-blocks (local.get $blockset) (local.get $block))

               ;; Coalesce may have made the free block larger; only relocate blocks
               ;; if it's still a fragment.

               (if (%is-fragment (local.get $block))
                   (then
                    (call $relocate-free-block (local.get $blockset) (local.get $block))))

               ;; The block has likely increased in size or moved upwards in memory,
               ;; but it is possible that it has come up against a block that cannot
               ;; be moved.  To handle this, free blocks are held in a list until
               ;; required number have been relocated, and only then are they added
               ;; back into the free lists.

               (local.set $relocated (call $make-pair (local.get $block) (local.get $relocated)))

               (local.set $count (i32.sub (local.get $count) (local.get $average)))
               (br $relocate))))))


   (loop $add-free
     (if (i32.ne (local.get $relocated) (global.get $null))
         (then

          ;; Add it back to the free block here, when its final size is known,
          ;; otherwise a large block might get stranded in a free list for much
          ;; smaller blocks.

          (call $add-free-block (local.get $blockset) (call $get-pair-car (local.get $relocated)))

          (local.set $next (call $get-pair-cdr (local.get $relocated)))
          (call $dealloc-pair (local.get $relocated))

          (local.set $relocated (local.get $next))
          (br $add-free)))))

 (func $relocate-free-block (debug (export "relocate-free-block"))
   (param $blockset i32)
   (param $free-block i32)

   (local $relo-end i32)
   (local $relo-last i32)
   (local $relo-start i32)

   (local.set $relo-start (%get-next-block (local.get $free-block)))

   (if (i32.eq (local.get $relo-start) (global.get $null))
       (then
        (return)))

   ;; Scan from free block upward for allocated blocks, stopping when
   ;; we've found the limit that we can move or the next free block.
   (local.set $relo-last
              (call $scan-relocatable-blocks
                    (local.get $relo-start)
                    (%get-blockset-relocation-size-limit (local.get $blockset))))

   (local.set $relo-end (%get-next-block (local.get $relo-last)))

   (if (i32.or (i32.eq (local.get $relo-start) (local.get $relo-last))
               (i32.eq (local.get $relo-end) (global.get $null)))
       (then
        ;; The block after $free-block is too big to move, or $free-block is the
        ;; last free block in the block list, and there's not much point in
        ;; relocating it.
        (return)))

   ;; Shift the blocks down in memory, adjusting their addresses.
   (call $relocate-blocks
         (local.get $blockset)
         (%get-block-addr (local.get $free-block))
         (local.get $relo-start)
         (local.get $relo-end))

   ;; Move free block up in memory
   (%set-block-addr (local.get $free-block) (%get-next-block-addr (local.get $relo-last)))

   ;; Remove free-block from before relo-start.
   (call $link-refs
         (local.get $blockset)
         (%get-previous-block (local.get $free-block))
         (local.get $relo-start))

   ;; Insert it after the relocated blocks.
   (call $link-refs (local.get $blockset) (local.get $relo-last) (local.get $free-block))
   (call $link-refs (local.get $blockset) (local.get $free-block) (local.get $relo-end))

   ;; In case the free block is now adjacent to another free block, merge them.
   (call $coalesce-free-blocks (local.get $blockset) (local.get $free-block)))

 (func $coalesce-free-blocks (debug (export "coalesce-free-blocks"))

   ;; Merges any free blocks immediately after $block into $block.

   (param $blockset i32)
   (param $block i32)

   (local $next i32)
   (local $next-size i32)

   (loop $again
     (local.set $next (%get-next-block (local.get $block)))
     (if (i32.ne (local.get $next) (global.get $null))
         (then
          (if (%is-free-block (local.get $next))
              (then

               ;; Check that the combined block is not too big to be
               ;; represented (size < 2^30).

               (if (call $can-merge-blocks (local.get $block) (local.get $next))
                   (then
                    (local.set $next-size (%get-block-size (local.get $next)))

                    (call $incr-block-size (local.get $block) (local.get $next-size))

                    (if (i32.lt_u (local.get $next-size) (global.get $fragment-size))
                        (then
                         (call $decr-blockset-fragment-count
                               (local.get $blockset)
                               (local.get $next-size))))

                    (call $link-refs
                          (local.get $blockset)
                          (local.get $block)
                          (%get-next-block (local.get $next)))

                    ;; The next block has been absorbed into $block.  Marking it
                    ;; unused lets $pop-free-block know to discard the block when
                    ;; it encounters it.

                    (call $mark-block-unused (local.get $next))

                    (call $incr-blockset-unused-count (local.get $blockset))

                    (debug
                     (call $decr-blockset-block-count (local.get $blockset))
                     (call $decr-blockset-free-count (local.get $blockset)))

                    (br $again)))))))))

 (func $incr-block-size (debug (export "incr-block-size"))

   ;; Increases the size of $block by $size, preserving the flags stored with
   ;; the block size, and checking for size overflow.

   (param $block i32)
   (param $size i32)

   (local $addr i32)
   (local $new-size i32)
   (local $size-flags i32)

   (local.set $addr (%get-block-size-addr (local.get $block)))
   (local.set $size-flags (i32.load (local.get $addr)))

   (local.set $new-size (i32.add (i32.and (local.get $size-flags)
                                          (global.get $block-size-mask))
                                 (local.get $size)))

   (if (i32.gt_u (local.get $new-size) (global.get $block-size-mask))
       (then
        (unreachable)))

   (i32.store (local.get $addr)
              (i32.or (i32.and (local.get $size-flags)
                               (global.get $block-flags-mask))
                      (local.get $new-size))))

 (func $can-merge-blocks (debug (export "can-merge-blocks"))

   ;; Returns false if the sum of the sizes of the blocks would be too large to
   ;; represent, ie. one whose size would trample the flag bits.  This is used

   (param $block i32)
   (param $next i32)
   (result i32)
   (i32.le_u (i32.add (%get-block-size (local.get $block))
                      (%get-block-size (local.get $next)))
             (global.get $block-size-mask)))

 (func $scan-relocatable-blocks (debug (export "scan-relocatable-blocks"))

   ;; Scans upward in memory from $start-block stopping when it finds a free
   ;; block, or when it has found one or more allocated blocks less than
   ;; $size-limit, or if free block is followed by a single block
   ;; larger than $size-limit, but less than $single-block-size-limit.

   (param $start-block i32)
   (param $size-limit i32)
   (result i32)

   (local $block i32)
   (local $last-block i32)
   (local $size i32)
   (local $size-remaining i32)

   (local.set $last-block (local.get $start-block))
   (local.set $block (local.get $start-block))
   (local.set $size-remaining (local.get $size-limit))

   ;; The logic is simpler to start with the total number of bytes that can be
   ;; moved and subtract from it the size of each block that will be moved.

   (loop $again
     (if (%is-allocated-block (local.get $block))
         (then
          (local.set $size (%get-block-size (local.get $block)))
          (if (i32.le_s (local.get $size) (local.get $size-remaining))
              (then
               ;; The current block will fit with the remaining bytes available.
               (local.set $size-remaining (i32.sub (local.get $size-remaining)
                                                   (local.get $size)))
               (local.set $last-block (local.get $block))
               (local.set $block (%get-next-block (local.get $block)))
               (if (i32.ne (local.get $block) (global.get $null))
                   (then
                    (br $again))))))))

   (local.get $last-block))

 (func $relocate-blocks (debug (export "relocate-blocks"))

   ;; Copies the data and updates the address fields of the blocks from
   ;; $start-block to $end-block.  $start-block is moved to $dest-addr, and the
   ;; rest of the addresses follow from there.

   (param $blockset i32)
   (param $dest-addr i32)
   (param $start-block i32)
   (param $end-block i32)

   (local $block i32)
   (local $offset i32)
   (local $source-addr i32)

   (local.set $source-addr (%get-block-addr (local.get $start-block)))

   (call_indirect $memory-copy
                  (type $memory-copy-sig)
                  (local.get $dest-addr)
                  (local.get $source-addr)
                  (i32.sub (%get-block-addr (local.get $end-block))
                           (%get-block-addr (local.get $start-block)))
                  (%get-blockset-id (local.get $blockset)))

   (local.set $block (local.get $start-block))
   (local.set $offset (i32.sub (local.get $source-addr) (local.get $dest-addr)))

   (loop $again
     (if (i32.ne (local.get $block) (local.get $end-block))
         (then
          (%set-block-addr
           (local.get $block)
           (i32.sub (%get-block-addr (local.get $block))
                    (local.get $offset)))
          (local.set $block (%get-next-block (local.get $block)))
          (br $again)))))

 (func $step-clean-free-lists (debug (export "step-clean-free-lists"))

   ;; Finds the next non-empty free list and recreates it, omitting any unused
   ;; blocks.  The blockset sweep cursor is used to track what "next" free
   ;; list means between invocations of this function.

   (param $blockset i32)

   (local $base-free-list i32)
   (local $free-list i32)
   (local $head i32)

   (local.set $base-free-list (%get-blockset-free-lists-base (local.get $blockset)))
   (local.set $free-list (%get-blockset-sweep-cursor (local.get $blockset)))

   (loop $again
     (if (i32.ge_u (local.get $free-list) (local.get $base-free-list))
         (then
          (local.set $head (i32.load (local.get $free-list)))
          (if (i32.eq (local.get $head) (global.get $null))
              (then
               (%decr-n i32 $free-list #value-size)
               (br $again))
            (else
             (call $rebuild-free-list (local.get $blockset) (local.get $head))
             (%decr-n i32 $free-list #value-size))))
       (else

        ;; The search reached the bottom. Reset to the top for the next run.
        (local.set $free-list (%get-blockset-last-free-list (local.get $blockset))))))

   ;; Update the cursor for the next invocation.
   (%set-blockset-sweep-cursor (local.get $blockset) (local.get $free-list)))

 (func $rebuild-free-list (debug (export "rebuild-free-list"))

   ;; Filters a free list to omit unused blocks, deallocating block refs and
   ;; pairs as needed.  This also adjusts the blockset's unused block count.

   (param $blockset i32)
   (param $head i32)

   (local $block i32)
   (local $next i32)
   (local $unused i32)
   (local $unused-count i32)

   (local.set $next (call $get-pair-cdr (local.get $head)))
   (local.set $unused-count (i32.const 0))

   (loop $again
     (if (i32.ne (local.get $next) (global.get $null))
         (then
          (local.set $block (call $get-pair-car (local.get $next)))

          (if (%is-unused-block (local.get $block))
              (then
               ;; Unlink from the list and deallocate the block ref and the pair

               (local.set $unused (local.get $next))
               (local.set $next (call $get-pair-cdr (local.get $next)))
               (call $set-pair-cdr (local.get $head) (local.get $next))

               (call $dealloc-ref (local.get $block))
               (call $dealloc-pair (local.get $unused))
               (%incr i32 $unused-count))
            (else
             (local.set $head (local.get $next))
             (local.set $next (call $get-pair-cdr (local.get $head)))))

          (br $again))))

   ;; It's much faster to accumulate the number of unused blocks that were
   ;; deallocated and subtract them at the end than to do so incrementally.

   (%set-blockset-unused-count (local.get $blockset)
                               (i32.sub (%get-blockset-unused-count (local.get $blockset))
                                        (local.get $unused-count))))

 ;; end of module
 )

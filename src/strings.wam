(module

 ;; Strings are boxed blocks which contain utf-8 encoded text.
 ;;
 ;; Under the assumption that most strings will be short, and most of those will
 ;; be entirely ASCII, there are four representation of strings: a simple string
 ;; for entirely ASCII text that is less than 256 characters, a short string
 ;; that occupies less than 256 bytes and includes at least one multibyte
 ;; character, a medium string that occupies less than 65536 bytes, and finally
 ;; a large string whose text and metadata together are up to 4GB, the
 ;; addressing limit of this module.

 (import "block-mgr" "alloc-block"     (func $alloc-block         (param i32 i32) (result i32)))
 (import "block-mgr" "dealloc-block"   (func $dealloc-block       (param i32 i32)))
 (import "block-mgr" "get-block-addr"  (func $get-block-addr      (param i32)     (result i32)))
 (import "block-mgr" "init-blockset"   (func $init-blockset       (param i32 i32)))
 (import "chars" "calc-char-width"     (func $calc-char-width     (param i32)     (result i32)))
 (import "chars" "calc-encoded-length" (func $calc-encoded-length (param i32)     (result i32)))
 (import "chars" "encode-char"         (func $encode-char         (param i32)     (result i32)))
 (import "pairs" "get-pair-car"        (func $get-pair-car        (param i32)     (result i32)))
 (import "pairs" "get-pair-cdr"        (func $get-pair-cdr        (param i32)     (result i32)))
 (import "pairs" "make-pair"           (func $make-pair           (param i32 i32) (result i32)))
 (import "pairs" "dealloc-pair"        (func $dealloc-pair        (param i32)))

 (include "./block-mgr-memory-proxy-imports.wam")

 (include "./globals.wam")
 (include "./boxes.wam")
 (include "./values.wam")
 (include "./block-mgr-memory-proxies.wam")

 (memory $memory (debug (export "memory")) 1)

 ;; The string type constants not only identify the kind of string, but also
 ;; encode key bits of information which enables the code below to determine the
 ;; memory layout of the string's data block using just the box tag field.  The
 ;; table below describes this encoding.
 ;;
 ;;                                  ii iiii dddd  lll tttt tttt
 ;;     simple           xxxx xxxx xx10 0000 0001 x001 0000 0010
 ;;     small            xxxx xxxx xx00 0100 0010 x001 0000 0010
 ;;     medium           xxxx xxxx xx00 0101 0100 x010 0000 0010
 ;;     large            xxxx xxxx xx00 0110 1000 x100 0000 0010
 ;;
 ;; where
 ;;
 ;;   "ii iiii" is the right shift to calculate index length from string size
 ;;
 ;;   "dddd" is the length in bytes of the size and length fields/offset to
 ;;          string data
 ;;
 ;;   "lll" is the length in bytes of the size field/offset to the length field
 ;;
 ;;   "tttt tttt" is the box type for a string
 ;;
 ;;   "x" is unused
 ;;
 ;; The memory layout of the string within its block starts with 1, 2 or 4 bytes
 ;; for the size of the string in bytes, then 0, 1, 2, or 4 bytes for the length
 ;; of the string in characters, followed by the data section holding bytes of
 ;; the string.  Finally, after the data section is the optional index section,
 ;; containing a sequence of 1, 2, or 4 byte offsets into the string
 ;; corresponding to every 16th, 32nd, or 64th character, respectively.
 ;;
 ;; Concretely, a simple string has a single byte for the size.  It has no
 ;; length field since all of its characters are single byte, and for the same
 ;; reason, it has no index section.  It's just an ordinary length-prefixed
 ;; string.  A small string has a single byte for the size, followed by a single
 ;; byte for the length of the string. After that will be the characters of the
 ;; string.  After the string data, there will be up to 15 bytes of offsets into
 ;; the string data section for the characters at position 16, 32, 48, ..., 224,
 ;; and 240.  A medium string is similar to a small string, but the size,
 ;; length, and offsets are 2 byte values, and the offsets are recorded at
 ;; positions 32, 64, ..., 65504.  A large string has 4 byte size, length, and
 ;; offset values, and records index entries every 64th character.
 ;;

 (define _string-type-length-field-offset-mask       (i32.const 0x00000700))
 (define _string-type-data-offset-mask               (i32.const 0x0000f000))
 (define _string-type-index-shift-mask               (i32.const 0x003f0000))

 (define _string-type-length-field-offset-shift-bits (i32.const 8))
 (define _string-type-data-offset-shift-bits         (i32.const 12))
 (define _string-type-idx-mask-shift-bits            (i32.const 5))
 (define _string-type-index-shift-shift-bits         (i32.const 16))

 (define _string-type-simple                         (i32.const 0x00201102))
 (define _string-type-small                          (i32.const 0x00042102))
 (define _string-type-medium                         (i32.const 0x00054202))
 (define _string-type-large                          (i32.const 0x00068402))
 (define _string-type-mask                           (i32.const 0x003ff7ff))

 ;; These constants are used in hash-string to mix up the bits of the string.  See the
 ;; comment at the start of the function for an explanation.
 (define _string-hash-shift-bits                     (i32.const 5))
 (define _string-hash-coefficient                    (i32.const 3486784401)) ;; 3^20,
 (define _string-hash-constant                       (i32.const 1518500249)) ;; floor(2^30 * sqrt(2))

 (debug
  (global $string-type-length-field-offset-mask       (export "string-type-length-field-offset-mask")       i32 _string-type-length-field-offset-mask)
  (global $string-type-data-offset-mask               (export "string-type-data-offset-mask")               i32 _string-type-data-offset-mask)
  (global $string-type-index-shift-mask               (export "string-type-index-shift-mask")               i32 _string-type-index-shift-mask)

  (global $string-type-length-field-offset-shift-bits (export "string-type-length-field-offset-shift-bits") i32 _string-type-length-field-offset-shift-bits)
  (global $string-type-data-offset-shift-bits         (export "string-type-data-offset-shift-bits")         i32 _string-type-data-offset-shift-bits)
  (global $string-type-idx-mask-shift-bits            (export "string-type-idx-mask-shift-bits")            i32 _string-type-idx-mask-shift-bits)
  (global $string-type-index-shift-shift-bits         (export "string-type-index-shift-shift-bits")         i32 _string-type-index-shift-shift-bits)

  (global $string-type-simple                         (export "type-string-simple")                         i32 _string-type-simple)
  (global $string-type-small                          (export "type-string-small")                          i32 _string-type-small)
  (global $string-type-medium                         (export "type-string-medium")                         i32 _string-type-medium)
  (global $string-type-large                          (export "type-string-large")                          i32 _string-type-large)
  (global $string-type-mask                           (export "type-string-mask")                           i32 _string-type-mask)

  (global $string-hash-shift-bits                     (export "string-hash-shift-bits")                     i32 _string-hash-shift-bits)
  (global $string-hash-coefficient                    (export "string-hash-coefficient")                    i32 _string-hash-coefficient)
  (global $string-hash-constant                       (export "string-hash-constant")                       i32 _string-hash-constant))

 (macro %calc-idx-mask
   (expr ,type)
   (i32.wrap_i64
    (i64.sub (i64.shl (i64.const 1)
                      (i64.extend_i32_u
                       (i32.shr_u (i32.and ,type _string-type-length-field-offset-mask)
                                  _string-type-idx-mask-shift-bits)))
             (i64.const 1))))

 (macro %calc-length-field-offset
   (expr ,type)
   (i32.shr_u (i32.and ,type _string-type-length-field-offset-mask)
              _string-type-length-field-offset-shift-bits))

 (macro %calc-data-offset
   (expr ,type)
   (i32.shr_u (i32.and ,type _string-type-data-offset-mask)
              _string-type-data-offset-shift-bits))

 (macro %calc-index-size-shift-bits
   (expr ,type)
   (i32.shr_u (i32.and ,type _string-type-index-shift-mask)
              _string-type-index-shift-shift-bits))

 (macro %calc-index-size
   (expr ,type)
   (expr ,length)
   (i32.shr_u ,length (%calc-index-size-shift-bits ,type)))

 (debug
  (func $calc-idx-mask (export "calc-idx-mask")
    (param $type i32)
    (result i32)
    (%calc-idx-mask $type))

  (func $calc-length-field-offset (export "calc-length-field-offset")
    (param $type i32)
    (result i32)
    (%calc-length-field-offset $type))

  (func $calc-data-offset (export "calc-data-offset")
    (param $type i32)
    (result i32)
    (%calc-data-offset $type))

  (func $calc-index-size-shift-bits (export "calc-index-size-shift-bits")
    (param $type i32)
    (result i32)
    (%calc-index-size-shift-bits $type))

  (func $calc-index-size (export "calc-index-size")
    (param $type i32)
    (param $length i32)
    (result i32)
    (%calc-index-size $type $length)))

 (macro %get-string-type
   (expr ,s)
   (i32.and (%get-box-type ,s) _string-type-mask))

 (macro %get-string-block-addr
   (expr ,s)
   ($get-block-addr (%get-box-value ,s)))

 (macro %get-string-length
   (label $type)
   (label $addr)

   (if (result i32) (i32.eq $type _string-type-simple)
     (then
      (i32.load8_u $addr))
     (else
      (if (result i32) (i32.eq $type _string-type-small)
        (then
         ;; skip over the byte for size
         (i32.load8_u (i32.add $addr (i32.const 1))))
        (else
         (if (result i32) (i32.eq $type _string-type-medium)
           (then
            ;; skip over the 2 bytes for size
            (i32.load16_u (i32.add $addr (i32.const 2))))
           (else
            ;; skip over the 4 bytes for size
            (i32.load (i32.add $addr (i32.const 4))))))))))

 (macro %get-string-size
   (label $type)
   (label $addr)

   (if (result i32) (i32.eq $type _string-type-simple)
     (then
      (i32.load8_u $addr))
     (else
      (if (result i32) (i32.eq $type _string-type-small)
        (then
         (i32.load8_u $addr))
        (else
         (if (result i32) (i32.eq $type _string-type-medium)
           (then
            (i32.load16_u $addr))
           (else
            (i32.load $addr))))))))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Initialization
 ;;

 (start $init-strings)
 (func $init-strings (export "init-strings")
   ($init-blockset _strings-blockset (i32.const 0x400))

   ;; defined in block-mgr-memory-proxies.wam
   ($init-blockset-memory-proxies _strings-blockset))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Allocation
 ;;

 (func $alloc-string (export "alloc-string")
   (param $length i32)
   (param $size i32)
   (result i32)

   (local $addr i32)
   (local $block i32)
   (local $header-size i32)
   (local $index-size i32)
   (local $type i32)

   (set! $type ($make-string-type $length $size))
   (set! $header-size (%calc-data-offset $type))
   (set! $index-size (%calc-index-size $type $length))

   (set! $block ($alloc-block
                      _strings-blockset
                      (i32.add $header-size (i32.add $size $index-size))))

   (set! $addr ($get-block-addr $block))

   (if (i32.eq $type _string-type-simple)
       (then
        (i32.store8 $addr $length))

     (else
      (if (i32.eq $type _string-type-small)
          (then
           (i32.store8 $addr $size)
           (i32.store8 (i32.add $addr (i32.const 1)) $length))

        (else
         (if (i32.eq $type _string-type-medium)
             (then
              (i32.store16 $addr $size)
              (i32.store16 (i32.add $addr (i32.const 2)) $length))

           (else ;; $string-type-large
            (i32.store $addr $size)
            (i32.store (i32.add $addr (i32.const 4)) $length)))))))

   (%make-box $type $block))

 (func $make-string-type (debug (export "make-string-type"))
   (param $length i32)
   (param $size i32)
   (result i32)

   (if (result i32) (i32.and (i32.lt_u $size (i32.const 0x100))
                             (i32.eq $size $length))
     (then
      _string-type-simple)
     (else
      (if (result i32) (i32.lt_u $size (i32.const 0x100))
        (then
         _string-type-small)
        (else
         (if (result i32) (i32.lt_u $size (i32.const 0x10000))
           (then
            _string-type-medium)
           (else
            _string-type-large)))))))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Deallocation
 ;;

 (func $dealloc-string (export "dealloc-string")
   (param $s i32)

   ($dealloc-block _strings-blockset (%get-box-value $s))

   (%dealloc-box $s))

 (func $get-string-addr (export "get-string-addr")
   (param $s i32)
   (result i32)

   (local $type i32)
   (set! $type (%get-string-type $s))

   (i32.add (%get-string-block-addr $s) (%calc-data-offset $type)))

 (func $get-string-index-addr
   (param $s i32)
   (result i32)

   (local $addr i32)
   (local $length i32)
   (local $type i32)

   (set! $type (%get-string-type $s))
   (set! $addr (%get-string-block-addr $s))

   (i32.add $addr (i32.add (%calc-data-offset $type) (%get-string-size $type $addr))))

 (func $get-string-length (export "get-string-length")
   (param $s i32)
   (result i32)

   (local $addr i32)
   (local $type i32)

   (set! $type (%get-string-type $s))
   (set! $addr (%get-string-block-addr $s))

   (%get-string-length $type $addr))

 (func $get-string-size (export "get-string-size")
   (param $s i32)
   (result i32)

   (local $addr i32)
   (local $type i32)

   (set! $type (%get-string-type $s))
   (set! $addr (%get-string-block-addr $s))

   (%get-string-size $type $addr))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Indexes
 ;;

 (func $build-string-index (export "build-string-index")
   (param $s i32)

   (local $string-type i32)

   (if (i32.eq $string-type _string-type-small)
       (then
        ($build-small-string-index $s))
     (else
      (if (i32.eq $string-type _string-type-medium)
          (then
           ($build-medium-string-index $s))
        (else
         ($build-large-string-index $s))))))

 (func $build-small-string-index (export "build-small-string-index")
   (param $s i32)

   (local $addr i32)
   (local $char-addr i32)
   (local $count i32)
   (local $idx-addr i32)
   (local $length i32)

   (set! $addr ($get-string-addr $s))
   (set! $char-addr $addr)
   (set! $idx-addr ($get-string-index-addr $s))

   (set! $count (i32.const 0))
   (set! $length ($get-string-length $s))

   (loop $again
     (if (i32.lt_u $count $length)
         (then
          (set! $char-addr ($get-next-char-addr $char-addr))
          (%incr i32 $count)

          ;; count % 16 == 0
          (if (i32.eqz (i32.and $count (i32.const 0xf)))
              (then
               (i32.store8 $idx-addr (i32.sub $char-addr $addr))
               (%incr i32 $idx-addr)))
          (br $again)))))

 (func $build-medium-string-index (export "build-medium-string-index")
   (param $s i32)

   (local $addr i32)
   (local $char-addr i32)
   (local $count i32)
   (local $idx-addr i32)
   (local $length i32)

   (set! $addr ($get-string-addr $s))
   (set! $char-addr $addr)
   (set! $idx-addr ($get-string-index-addr $s))

   (set! $count (i32.const 0))
   (set! $length ($get-string-length $s))

   (loop $again
     (if (i32.lt_u $count $length)
         (then
          (set! $char-addr ($get-next-char-addr $char-addr))
          (%incr i32 $count)

          ;; count % 32 == 0
          (if (i32.eqz (i32.and $count (i32.const 0x1f)))
              (then
               (i32.store16 $idx-addr (i32.sub $char-addr $addr))
               (%incr-n i32 $idx-addr 2)))
          (br $again)))))

 (func $build-large-string-index (export "build-large-string-index")
   (param $s i32)

   (local $addr i32)
   (local $char-addr i32)
   (local $count i32)
   (local $idx-addr i32)
   (local $length i32)

   (set! $addr ($get-string-addr $s))
   (set! $char-addr $addr)
   (set! $idx-addr ($get-string-index-addr $s))

   (set! $count (i32.const 0))
   (set! $length ($get-string-length $s))

   (loop $again
     (if (i32.lt_u $count $length)
         (then
          (set! $char-addr ($get-next-char-addr $char-addr))
          (%incr i32 $count)

          ;; count % 64 == 0
          (if (i32.eqz (i32.and $count (i32.const 0x3f)))
              (then
               (i32.store $idx-addr (i32.sub $char-addr $addr))
               (%incr-n i32 $idx-addr 4)))
          (br $again)))))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Data Access
 ;;

 (func $get-next-char-addr (export "get-next-char-addr")
   (param $addr i32)
   (result i32)

   (local $encoded-length i32)

   (set! $encoded-length ($calc-encoded-length (i32.load8_u $addr)))

   (if (i32.eq $encoded-length (i32.const -1))
       (then
        (unreachable)))

   (i32.add $addr $encoded-length))

 (func $set-string-bytes (debug (export "set-string-bytes"))
   (param $addr i32)
   (param $data i32)
   (param $length i32)

   (if (i32.eq $length (i32.const 1))
       (then
        (i32.store8 $addr $data))
     (else
      (if (i32.eq $length (i32.const 2))
          (then
           (i32.store16 $addr $data))
        (else
         (if (i32.eq $length (i32.const 3))
             (then
              (i32.store16 $addr $data)
              (i32.store8 (i32.add $addr (i32.const 2))
                          (i32.shr_u $data (i32.const 16))))
           (else
            (i32.store $addr $data))))))))

 (func $get-string-bytes (debug (export "get-string-bytes"))
   (param $addr i32)
   (param $length i32)
   (result i32)

   (if (result i32) (i32.eq $length (i32.const 1))
     (then
      (i32.load8_u $addr))
     (else
      (if (result i32) (i32.eq $length (i32.const 2))
        (then
         (i32.load16_u $addr))
        (else
         (if (result i32) (i32.eq $length (i32.const 3))
           (then
            (i32.and (i32.load $addr) (i32.const 0xffffff)))
           (else
            (i32.load $addr))))))))

 (func $get-string-char (export "get-string-char")
   (param $addr i32)
   (result i32)

   (local $length i32)
   (local $mask i32)
   (local $x i32)

   (set! $x (i32.load $x))
   (set! $length ($calc-encoded-length $x))
   (set! $mask (i32.sub (i32.shl (i32.const 1)
                                 (i32.shl $length (i32.const 3)))
                        (i32.const 1)))

   (if (result i32) $mask
     (then (i32.and $x $mask))
     (else $x)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Symbols module support
 ;;
 ;; The hash-string and string-equal functions provide the symbols module with
 ;; the primitives it needs to implement a hash table which maps strings to
 ;; symbols.
 ;;

 (func $hash-string (export "hash-string")

   ;; hash-string accumulates the bits of the characters in the string using a
   ;; combination of xor and rotate.  Each 4-byte chunk is xor'd with the
   ;; current hash value and then rotated left 5 bit positions. Over longer
   ;; strings this will spread the influence of the bit position of any octet
   ;; throughout the hash value, and specifically the choice of 5 is due to the
   ;; fact that typically the lower 5 bits of the text have the highest entropy
   ;; (think ASCII here).  The final step is to add a number between 2^30 and
   ;; 2^31 and then multiply by an odd number between 2^31 and 2^32.  This
   ;; distributes even short strings throughout the hash space.  The last two
   ;; values are arbitrary, the only things being important are the approximate
   ;; size of values, and the fact that the number used in the multiplication
   ;; is odd and not -1 or 1.
   ;;

   (param $s i32)
   (result i32)

   (local $addr i32)
   (local $count i32)
   (local $hash i32)

   (set! $addr ($get-string-addr $s))
   (set! $count ($get-string-size $s))
   (set! $hash (i32.const 0))

   (macro %update-hash
     (label $hash)
     (expr ,value)

     (set! $hash (i32.xor (i32.rotl $hash _string-hash-shift-bits)
                          ,value)))

   (loop $again
     (if (i32.ge_u $count (i32.const 4))
         (then
          (%update-hash $hash (i32.load $addr))
          (%decr-n i32 $count 4)
          (%incr-n i32 $addr 4)
          (br $again))))

   (if (i32.ge_u $count (i32.const 2))
       (then
        (%update-hash $hash (i32.load16_u $addr))
        (%decr-n i32 $count 2)
        (%incr-n i32 $addr 2)))

   (if $count
       (then
        (%update-hash $hash (i32.load8_u $addr))))

   (i32.mul (i32.add $hash _string-hash-constant) _string-hash-coefficient))

 (func $string-equal (export "string-equal")

   ;; Since this is designed expressly for the hash table use case of the
   ;; symbols module, it needs to be quick and do nothing more than required.
   ;; The more general collation-aware trinary (-1, 0, 1) string-compare
   ;; function (yet to be implemented) will likely have a significantly longer
   ;; runtime for the same inputs.

   (param $s1 i32)
   (param $s2 i32)
   (result i32)

   (local $addr1 i32)
   (local $addr2 i32)
   (local $count i32)

   (set! $count ($get-string-size $s1))

   (if (i32.ne $count ($get-string-size $s2))
       (then
        (return (i32.const 0))))

   (if (i32.ne ($get-string-length $s1)
               ($get-string-length $s2))
       (then
        (return (i32.const 0))))

   (set! $addr1 ($get-string-addr $s1))
   (set! $addr2 ($get-string-addr $s2))

   (loop $again
     (if (i32.ge_u $count (i32.const 8))
         (then
          (if (i64.ne (i64.load $addr1) (i64.load $addr2))
              (then
               (return (i32.const 0))))
          (%decr-n i32 $count 8)
          (%incr-n i32 $addr1 8)
          (%incr-n i32 $addr2 8)
          (br $again))))

   (if (i32.ge_u $count (i32.const 4))
       (then
        (if (i32.ne (i32.load $addr1) (i32.load $addr2))
            (then
             (return (i32.const 0))))
        (%decr-n i32 $count 4)
        (%incr-n i32 $addr1 4)
        (%incr-n i32 $addr2 4)))

   (if (i32.ge_u $count (i32.const 2))
       (then
        (if (i32.ne (i32.load16_u $addr1) (i32.load16_u $addr2))
            (then
             (return (i32.const 0))))
        (%decr-n i32 $count 2)
        (%incr-n i32 $addr1 2)
        (%incr-n i32 $addr2 2)))

   (if (i32.eq $count (i32.const 1))
       (then
        (if (i32.ne (i32.load8_u $addr1) (i32.load8_u $addr2))
            (then
             (return (i32.const 0))))))

   (i32.const 1))

 ;; end of module
 )

(module

 (import "lex" "lex-match-any-char"                      (func $lex-match-any-char                      (param i32 i32 i32)                 (result i32 i32)))
 (import "lex" "lex-match-char"                          (func $lex-match-char                          (param i32 i32 i32 i32)             (result i32 i32)))
 (import "lex" "lex-match-char-complement/set-of-2"      (func $lex-match-char-complement/set-of-2      (param i32 i32 i32 i32 i32)         (result i32 i32)))
 (import "lex" "lex-match-char-range/ascii"              (func $lex-match-char-range/ascii              (param i32 i32 i32 i32 i32)         (result i32 i32)))
 (import "lex" "lex-match-char/ascii-ci"                 (func $lex-match-char/ascii-ci                 (param i32 i32 i32 i32)             (result i32 i32)))
 (import "lex" "lex-match-charset/ascii"                 (func $lex-match-charset/ascii                 (param i32 i32 i32 i32)             (result i32 i32)))
 (import "lex" "lex-match-rule/one-or-more"              (func $lex-match-rule/one-or-more              (param i32 i32 i32 i32)             (result i32 i32)))
 (import "lex" "lex-match-rule/zero-or-more"             (func $lex-match-rule/zero-or-more             (param i32 i32 i32 i32)             (result i32 i32)))
 (import "lex" "lex-match-rule?"                         (func $lex-match-rule?                         (param i32 i32 i32 i32)             (result i32 i32)))
 (import "lex" "lex-match-rules/longest-of-2"            (func $lex-match-rules/longest-of-2            (param i32 i32 i32 i32 i32)         (result i32 i32)))
 (import "lex" "lex-match-rules/longest-of-3"            (func $lex-match-rules/longest-of-3            (param i32 i32 i32 i32 i32 i32)     (result i32 i32)))
 (import "lex" "lex-match-rules/longest-of-4"            (func $lex-match-rules/longest-of-4            (param i32 i32 i32 i32 i32 i32 i32) (result i32 i32)))
 (import "lex" "lex-match-rules/sequence-of-2"           (func $lex-match-rules/sequence-of-2           (param i32 i32 i32 i32 i32)         (result i32 i32)))
 (import "lex" "lex-match-rules/sequence-of-3"           (func $lex-match-rules/sequence-of-3           (param i32 i32 i32 i32 i32 i32)     (result i32 i32)))
 (import "lex" "lex-match-rules/sequence-of-4"           (func $lex-match-rules/sequence-of-4           (param i32 i32 i32 i32 i32 i32 i32) (result i32 i32)))
 (import "lex" "lex-match-rules/set-of-2"                (func $lex-match-rules/set-of-2                (param i32 i32 i32 i32 i32)         (result i32 i32)))
 (import "lex" "lex-match-string"                        (func $lex-match-string                        (param i32 i32 i32 i32)             (result i32 i32)))
 (import "lex" "lex-match-string/ascii-ci"               (func $lex-match-string/ascii-ci               (param i32 i32 i32 i32)             (result i32 i32)))
 (import "lex" "lex-match-strings/ascii-ci/longest-of-2" (func $lex-match-strings/ascii-ci/longest-of-2 (param i32 i32 i32 i32 i32)         (result i32 i32)))
 (import "lex" "lex-match-strings/ascii-ci/longest-of-3" (func $lex-match-strings/ascii-ci/longest-of-3 (param i32 i32 i32 i32 i32 i32)     (result i32 i32)))
 (import "lex" "lex-match-strings/ascii-ci/one-of-2"     (func $lex-match-strings/ascii-ci/one-of-2     (param i32 i32 i32 i32 i32)         (result i32 i32)))
 (import "lex" "lex-match-strings/longest-of-4"          (func $lex-match-strings/longest-of-4          (param i32 i32 i32 i32 i32 i32 i32) (result i32 i32)))
 (import "lex" "lex-match-strings/one-of-2"              (func $lex-match-strings/one-of-2              (param i32 i32 i32 i32 i32)         (result i32 i32)))
 (import "lex" "lex-match-strings/one-of-3"              (func $lex-match-strings/one-of-3              (param i32 i32 i32 i32 i32 i32)     (result i32 i32)))
 (import "lex" "lex-match-until-rule"                    (func $lex-match-until-rule                    (param i32 i32 i32 i32)             (result i32 i32)))
 (import "strings" "alloc-string"                        (func $alloc-string                            (param i32 i32)                     (result i32)))
 (import "strings" "get-string-addr"                     (func $get-string-addr                         (param i32)                         (result i32)))
 (import "strings" "set-string-bytes"                    (func $set-string-bytes                        (param i32 i32 i32)))

 (include "./constants.wam")

 (import "lex" "lexical-rules"  (table $lexical-rules #max-lexical-rules funcref))

 (include "./globals.wam")
 (include "./ascii.wam")
 (include "./lex-r7rs-rule-ids.wam")
 (include "./string-loader.wam")

 (memory (debug (export "memory")) 1)

 ;; <token> -> <identifier> | <boolean> | <number>
 ;;            | <character> | <string>
 ;;            | ( | ) | # ( | #u8( | â€™ | ` | , | ,@ | .

 (global $string-paren-charset              (export "string-paren-charset")              (mut i32) (i32.const 0))
 (global $string-token-charset              (export "string-token-charset")              (mut i32) (i32.const 0))
 (global $string-begin-vector               (export "string-begin-vector")               (mut i32) (i32.const 0))
 (global $string-begin-bytevector           (export "string-begin-bytevector")           (mut i32) (i32.const 0))
 (global $string-unquote-splicing           (export "string-unquote-splicing")           (mut i32) (i32.const 0))
 (global $string-delimiter-charset          (export "string-delimiter-charset")          (mut i32) (i32.const 0))
 (global $string-intraline-whitespace       (export "string-intraline-whitespace")       (mut i32) (i32.const 0))
 (global $string-line-ending-charset        (export "string-line-ending-charset")        (mut i32) (i32.const 0))
 (global $string-dos-line-ending            (export "string-dos-line-ending")            (mut i32) (i32.const 0))
 (global $string-begin-datum-comment        (export "string-begin-datum-comment")        (mut i32) (i32.const 0))
 (global $string-begin-nested-comment       (export "string-begin-nested-comment")       (mut i32) (i32.const 0))
 (global $string-end-nested-comment         (export "string-end-nested-comment")         (mut i32) (i32.const 0))
 (global $string-directive-fold-case        (export "string-directive-fold-case")        (mut i32) (i32.const 0))
 (global $string-directive-no-fold-case     (export "string-directive-no-fold-case")     (mut i32) (i32.const 0))
 (global $string-special-initials           (export "string-special-initials")           (mut i32) (i32.const 0))
 (global $string-explicit-sign-charset      (export "string-explicit-sign-charset")      (mut i32) (i32.const 0))
 (global $string-special-subsequent-charset (export "string-special-subsequent-charset") (mut i32) (i32.const 0))
 (global $string-inline-escape-prefix       (export "string-inline-escape-prefix")       (mut i32) (i32.const 0))
 (global $string-mnemonic-escapes           (export "string-mnemonic-escapes")           (mut i32) (i32.const 0))
 (global $string-boolean-t                  (export "string-boolean-t")                  (mut i32) (i32.const 0))
 (global $string-boolean-f                  (export "string-boolean-f")                  (mut i32) (i32.const 0))
 (global $string-boolean-true               (export "string-boolean-true")               (mut i32) (i32.const 0))
 (global $string-boolean-false              (export "string-boolean-false")              (mut i32) (i32.const 0))
 (global $string-character-prefix           (export "string-character-prefix")           (mut i32) (i32.const 0))
 (global $string-character-hex-prefix       (export "string-character-hex-prefix")       (mut i32) (i32.const 0))
 (global $string-alarm                      (export "string-alarm")                      (mut i32) (i32.const 0))
 (global $string-backspace                  (export "string-backspace")                  (mut i32) (i32.const 0))
 (global $string-delete                     (export "string-delete")                     (mut i32) (i32.const 0))
 (global $string-escape                     (export "string-escape")                     (mut i32) (i32.const 0))
 (global $string-newline                    (export "string-newline")                    (mut i32) (i32.const 0))
 (global $string-null                       (export "string-null")                       (mut i32) (i32.const 0))
 (global $string-return                     (export "string-return")                     (mut i32) (i32.const 0))
 (global $string-space                      (export "string-space")                      (mut i32) (i32.const 0))
 (global $string-tab                        (export "string-tab")                        (mut i32) (i32.const 0))
 (global $string-inf                        (export "string-inf")                        (mut i32) (i32.const 0))
 (global $string-nan                        (export "string-nan")                        (mut i32) (i32.const 0))
 (global $string-empty                      (export "string-empty")                      (mut i32) (i32.const 0))
 (global $string-exact-prefix               (export "string-exact-prefix")               (mut i32) (i32.const 0))
 (global $string-inexact-prefix             (export "string-inexact-prefix")             (mut i32) (i32.const 0))
 (global $string-radix-2                    (export "string-radix-2")                    (mut i32) (i32.const 0))
 (global $string-radix-8                    (export "string-radix-8")                    (mut i32) (i32.const 0))
 (global $string-radix-10                   (export "string-radix-10")                   (mut i32) (i32.const 0))
 (global $string-radix-16                   (export "string-radix-16")                   (mut i32) (i32.const 0))

 (string _string-paren-charset-data              (export "string-paren-charset-data")               "()")
 (string _string-token-charset-data              (export "string-token-charset-data")               "'`,.")
 (string _string-begin-vector-data               (export "string-begin-vector-data")                "#(")
 (string _string-begin-bytevector-data           (export "string-begin-bytevector-data")            "#u8(")
 (string _string-unquote-splicing-data           (export "string-unquote-splicing-data")            ",@")
 (string _string-delimiter-charset-data          (export "string-delimiter-charset-data")           "\n\t\r |()\";")
 (string _string-intraline-whitespace-data       (export "string-intraline-whitespace-data")        " \t")
 (string _string-line-ending-charset-data        (export "string-line-ending-charset-data")         "\r\n")
 (string _string-dos-line-ending-data            (export "string-dos-line-ending-data")             "\r\n")
 (string _string-begin-datum-comment-data        (export "string-begin-datum-comment-data")         "#;")
 (string _string-begin-nested-comment-data       (export "string-begin-nested-comment-data")        "#|")
 (string _string-end-nested-comment-data         (export "string-end-nested-comment-data")          "|#")
 (string _string-directive-fold-case-data        (export "string-directive-fold-case-data")         "#!fold-case")
 (string _string-directive-no-fold-case-data     (export "string-directive-no-fold-case-data")      "#!no-fold-case")
 (string _string-special-initials-data           (export "string-special-initials-data")            "!$%&*/:<=>?^_~")
 (string _string-explicit-sign-charset-data      (export "string-explicit-sign-charset-data")       "+-")
 (string _string-special-subsequent-charset-data (export "string-special-subsequent-charset-data")  "+-.@")
 (string _string-inline-escape-prefix-data       (export "string-inline-escape-prefix-data")        "\\x")
 (string _string-mnemonic-escapes-data           (export "string-mnemonic-escapes-data")            "abnrt")
 (string _string-boolean-t-data                  (export "string-boolean-t-data")                   "#t")
 (string _string-boolean-f-data                  (export "string-boolean-f-data")                   "#f")
 (string _string-boolean-true-data               (export "string-boolean-true-data")                "#true")
 (string _string-boolean-false-data              (export "string-boolean-false-data")               "#false")
 (string _string-character-prefix-data           (export "string-character-prefix-data")            "#\\")
 (string _string-character-hex-prefix-data       (export "string-character-hex-prefix-data")        "#\\x")
 (string _string-alarm-data                      (export "string-alarm-data")                       "alarm")
 (string _string-backspace-data                  (export "string-backspace-data")                   "backspace")
 (string _string-delete-data                     (export "string-delete-data")                      "delete")
 (string _string-escape-data                     (export "string-escape-data")                      "escape")
 (string _string-newline-data                    (export "string-newline-data")                     "newline")
 (string _string-null-data                       (export "string-null-data")                        "null")
 (string _string-return-data                     (export "string-return-data")                      "return")
 (string _string-space-data                      (export "string-space-data")                       "space")
 (string _string-tab-data                        (export "string-tab-data")                         "tab")
 (string _string-inf-data                        (export "string-inf-data")                         "inf.0")
 (string _string-nan-data                        (export "string-nan-data")                         "nan.0")
 (string _string-empty-data                      (export "string-empty-data")                       "")
 (string _string-exact-prefix-data               (export "string-exact-prefix-data")                "#e")
 (string _string-inexact-prefix-data             (export "string-inexact-prefix-data")              "#i")
 (string _string-radix-2-data                    (export "string-radix-2-data")                     "#b")
 (string _string-radix-8-data                    (export "string-radix-8-data")                     "#o")
 (string _string-radix-10-data                   (export "string-radix-10-data")                    "#d")
 (string _string-radix-16-data                   (export "string-radix-16-data")                    "#x")

 (start $init-lex-r7rs)
 (func $init-lex-r7rs (debug (export "init-lex-r7rs"))

   (global.set $string-paren-charset              ($load-string _string-paren-charset-data))
   (global.set $string-token-charset              ($load-string _string-token-charset-data))
   (global.set $string-begin-vector               ($load-string _string-begin-vector-data))
   (global.set $string-begin-bytevector           ($load-string _string-begin-bytevector-data))
   (global.set $string-unquote-splicing           ($load-string _string-unquote-splicing-data))
   (global.set $string-delimiter-charset          ($load-string _string-delimiter-charset-data))
   (global.set $string-intraline-whitespace       ($load-string _string-intraline-whitespace-data))
   (global.set $string-line-ending-charset        ($load-string _string-line-ending-charset-data))
   (global.set $string-dos-line-ending            ($load-string _string-dos-line-ending-data))
   (global.set $string-begin-datum-comment        ($load-string _string-begin-datum-comment-data))
   (global.set $string-begin-nested-comment       ($load-string _string-begin-nested-comment-data))
   (global.set $string-end-nested-comment         ($load-string _string-end-nested-comment-data))
   (global.set $string-directive-fold-case        ($load-string _string-directive-fold-case-data))
   (global.set $string-directive-no-fold-case     ($load-string _string-directive-no-fold-case-data))
   (global.set $string-special-initials           ($load-string _string-special-initials-data))
   (global.set $string-explicit-sign-charset      ($load-string _string-explicit-sign-charset-data))
   (global.set $string-special-subsequent-charset ($load-string _string-special-subsequent-charset-data))
   (global.set $string-inline-escape-prefix       ($load-string _string-inline-escape-prefix-data))
   (global.set $string-mnemonic-escapes           ($load-string _string-mnemonic-escapes-data))
   (global.set $string-boolean-t                  ($load-string _string-boolean-t-data))
   (global.set $string-boolean-f                  ($load-string _string-boolean-f-data))
   (global.set $string-boolean-true               ($load-string _string-boolean-true-data))
   (global.set $string-boolean-false              ($load-string _string-boolean-false-data))
   (global.set $string-character-prefix           ($load-string _string-character-prefix-data))
   (global.set $string-character-hex-prefix       ($load-string _string-character-hex-prefix-data))
   (global.set $string-alarm                      ($load-string _string-alarm-data))
   (global.set $string-backspace                  ($load-string _string-backspace-data))
   (global.set $string-delete                     ($load-string _string-delete-data))
   (global.set $string-escape                     ($load-string _string-escape-data))
   (global.set $string-newline                    ($load-string _string-newline-data))
   (global.set $string-null                       ($load-string _string-null-data))
   (global.set $string-return                     ($load-string _string-return-data))
   (global.set $string-space                      ($load-string _string-space-data))
   (global.set $string-tab                        ($load-string _string-tab-data))
   (global.set $string-inf                        ($load-string _string-inf-data))
   (global.set $string-nan                        ($load-string _string-nan-data))
   (global.set $string-empty                      ($load-string _string-empty-data))
   (global.set $string-exact-prefix               ($load-string _string-exact-prefix-data))
   (global.set $string-inexact-prefix             ($load-string _string-inexact-prefix-data))
   (global.set $string-radix-2                    ($load-string _string-radix-2-data))
   (global.set $string-radix-8                    ($load-string _string-radix-8-data))
   (global.set $string-radix-10                   ($load-string _string-radix-10-data))
   (global.set $string-radix-16                   ($load-string _string-radix-16-data))

   (table.set $lexical-rules _lex-rule-delimited-token                 (ref.func $lex-match-delimited-token))
   (table.set $lexical-rules _lex-rule-delimited-token-string          (ref.func $lex-match-delimited-token-string))
   (table.set $lexical-rules _lex-rule-unquote-splicing                (ref.func $lex-match-unquote-splicing))
   (table.set $lexical-rules _lex-rule-paren-char                      (ref.func $lex-match-paren-char))
   (table.set $lexical-rules _lex-rule-undelimited-token               (ref.func $lex-match-undelimited-token))
   (table.set $lexical-rules _lex-rule-token/group-1                   (ref.func $lex-match-token/group-1))
   (table.set $lexical-rules _lex-rule-token/group-2                   (ref.func $lex-match-token/group-2))
   (table.set $lexical-rules _lex-rule-token-char                      (ref.func $lex-match-token-char))
   (table.set $lexical-rules _lex-rule-delimiter                       (ref.func $lex-match-delimiter))
   (table.set $lexical-rules _lex-rule-intraline-whitespace            (ref.func $lex-match-intraline-whitespace))
   (table.set $lexical-rules _lex-rule-whitespace                      (ref.func $lex-match-whitespace))
   (table.set $lexical-rules _lex-rule-vertical-line                   (ref.func $lex-match-vertical-line))
   (table.set $lexical-rules _lex-rule-line-ending                     (ref.func $lex-match-line-ending))
   (table.set $lexical-rules _lex-rule-line-ending-char                (ref.func $lex-match-line-ending-char))
   (table.set $lexical-rules _lex-rule-dos-line-ending                 (ref.func $lex-match-dos-line-ending))
   (table.set $lexical-rules _lex-rule-comment                         (ref.func $lex-match-comment))
   (table.set $lexical-rules _lex-rule-simple-comment                  (ref.func $lex-match-simple-comment))
   (table.set $lexical-rules _lex-rule-semicolon                       (ref.func $lex-match-semicolon))
   (table.set $lexical-rules _lex-rule-simple-comment-continuation     (ref.func $lex-match-simple-comment-continuation))
   (table.set $lexical-rules _lex-rule-datum-comment                   (ref.func $lex-match-datum-comment))
   (table.set $lexical-rules _lex-rule-nested-comment                  (ref.func $lex-match-nested-comment))
   (table.set $lexical-rules _lex-rule-begin-nested-comment            (ref.func $lex-match-begin-nested-comment))
   (table.set $lexical-rules _lex-rule-comment-continuations           (ref.func $lex-match-comment-continuations))
   (table.set $lexical-rules _lex-rule-end-nested-comment              (ref.func $lex-match-end-nested-comment))
   (table.set $lexical-rules _lex-rule-comment-text                    (ref.func $lex-match-comment-text))
   (table.set $lexical-rules _lex-rule-nested-comment-delimiters       (ref.func $lex-match-nested-comment-delimiters))
   (table.set $lexical-rules _lex-rule-comment-continuation            (ref.func $lex-match-comment-continuation))
   (table.set $lexical-rules _lex-rule-directive                       (ref.func $lex-match-directive))
   (table.set $lexical-rules _lex-rule-atmosphere                      (ref.func $lex-match-atmosphere))
   (table.set $lexical-rules _lex-rule-identifier                      (ref.func $lex-match-identifier))
   (table.set $lexical-rules _lex-rule-ordinary-identifier             (ref.func $lex-match-ordinary-identifier))
   (table.set $lexical-rules _lex-rule-subsequents                     (ref.func $lex-match-subsequents))
   (table.set $lexical-rules _lex-rule-vertical-line-quoted-symbol     (ref.func $lex-match-vertical-line-quoted-symbol))
   (table.set $lexical-rules _lex-rule-symbol-elements                 (ref.func $lex-match-symbol-elements))
   (table.set $lexical-rules _lex-rule-initial                         (ref.func $lex-match-initial))
   (table.set $lexical-rules _lex-rule-letter                          (ref.func $lex-match-letter))
   (table.set $lexical-rules _lex-rule-lowercase-letter                (ref.func $lex-match-lowercase-letter))
   (table.set $lexical-rules _lex-rule-uppercase-letter                (ref.func $lex-match-uppercase-letter))
   (table.set $lexical-rules _lex-rule-special-initial                 (ref.func $lex-match-special-initial))
   (table.set $lexical-rules _lex-rule-subsequent                      (ref.func $lex-match-subsequent))
   (table.set $lexical-rules _lex-rule-digit                           (ref.func $lex-match-digit))
   (table.set $lexical-rules _lex-rule-explicit-sign                   (ref.func $lex-match-explicit-sign))
   (table.set $lexical-rules _lex-rule-special-subsequent              (ref.func $lex-match-special-subsequent))
   (table.set $lexical-rules _lex-rule-inline-hex-escape               (ref.func $lex-match-inline-hex-escape))
   (table.set $lexical-rules _lex-rule-inline-hex-escape-prefix        (ref.func $lex-match-inline-hex-escape-prefix))
   (table.set $lexical-rules _lex-rule-hex-scalar-value                (ref.func $lex-match-hex-scalar-value))
   (table.set $lexical-rules _lex-rule-mnemonic-escape                 (ref.func $lex-match-mnemonic-escape))
   (table.set $lexical-rules _lex-rule-backslash                       (ref.func $lex-match-backslash))
   (table.set $lexical-rules _lex-rule-mnemonic-escape-character       (ref.func $lex-match-mnemonic-escape-character))
   (table.set $lexical-rules _lex-rule-peculiar-identifier             (ref.func $lex-match-peculiar-identifier))
   (table.set $lexical-rules _lex-rule-peculiar-identifier/form-1      (ref.func $lex-match-peculiar-identifier/form-1))
   (table.set $lexical-rules _lex-rule-peculiar-identifier/form-2      (ref.func $lex-match-peculiar-identifier/form-2))
   (table.set $lexical-rules _lex-rule-dot                             (ref.func $lex-match-dot))
   (table.set $lexical-rules _lex-rule-peculiar-identifier/form-3      (ref.func $lex-match-peculiar-identifier/form-3))
   (table.set $lexical-rules _lex-rule-dot-subsequent                  (ref.func $lex-match-dot-subsequent))
   (table.set $lexical-rules _lex-rule-sign-subsequent                 (ref.func $lex-match-sign-subsequent))
   (table.set $lexical-rules _lex-rule-at-sign                         (ref.func $lex-match-at-sign))
   (table.set $lexical-rules _lex-rule-symbol-element                  (ref.func $lex-match-symbol-element))
   (table.set $lexical-rules _lex-rule-symbol-element/character        (ref.func $lex-match-symbol-element/character))
   (table.set $lexical-rules _lex-rule-escaped-vertical-line           (ref.func $lex-match-escaped-vertical-line))
   (table.set $lexical-rules _lex-rule-boolean                         (ref.func $lex-match-boolean))
   (table.set $lexical-rules _lex-rule-character                       (ref.func $lex-match-character))
   (table.set $lexical-rules _lex-rule-escaped-character               (ref.func $lex-match-escaped-character))
   (table.set $lexical-rules _lex-rule-single-character                (ref.func $lex-match-single-character))
   (table.set $lexical-rules _lex-rule-character-prefix                (ref.func $lex-match-character-prefix))
   (table.set $lexical-rules _lex-rule-named-character                 (ref.func $lex-match-named-character))
   (table.set $lexical-rules _lex-rule-escaped-character-hex           (ref.func $lex-match-escaped-character-hex))
   (table.set $lexical-rules _lex-rule-character-hex-prefix            (ref.func $lex-match-character-hex-prefix))
   (table.set $lexical-rules _lex-rule-character-name                  (ref.func $lex-match-character-name))
   (table.set $lexical-rules _lex-rule-character-name/group-1          (ref.func $lex-match-character-name/group-1))
   (table.set $lexical-rules _lex-rule-character-name/group-2          (ref.func $lex-match-character-name/group-2))
   (table.set $lexical-rules _lex-rule-character-name/group-3          (ref.func $lex-match-character-name/group-3))
   (table.set $lexical-rules _lex-rule-quoted-string                   (ref.func $lex-match-quoted-string))
   (table.set $lexical-rules _lex-rule-double-quote                    (ref.func $lex-match-double-quote))
   (table.set $lexical-rules _lex-rule-string-elements                 (ref.func $lex-match-string-elements))
   (table.set $lexical-rules _lex-rule-string-element                  (ref.func $lex-match-string-element))
   (table.set $lexical-rules _lex-rule-string-element/character        (ref.func $lex-match-string-element/character))
   (table.set $lexical-rules _lex-rule-string-element/character-escape (ref.func $lex-match-string-element/character-escape))
   (table.set $lexical-rules _lex-rule-escaped-double-quote            (ref.func $lex-match-escaped-double-quote))
   (table.set $lexical-rules _lex-rule-escaped-backslash               (ref.func $lex-match-escaped-backslash))
   (table.set $lexical-rules _lex-rule-escaped-line-ending             (ref.func $lex-match-escaped-line-ending))
   (table.set $lexical-rules _lex-rule-some-intraline-whitespace       (ref.func $lex-match-some-intraline-whitespace))
   (table.set $lexical-rules _lex-rule-number                          (ref.func $lex-match-number))
   (table.set $lexical-rules _lex-rule-num-2                           (ref.func $lex-match-num-2))
   (table.set $lexical-rules _lex-rule-num-8                           (ref.func $lex-match-num-8))
   (table.set $lexical-rules _lex-rule-num-10                          (ref.func $lex-match-num-10))
   (table.set $lexical-rules _lex-rule-num-16                          (ref.func $lex-match-num-16))
   (table.set $lexical-rules _lex-rule-complex-16                      (ref.func $lex-match-complex-16))
   (table.set $lexical-rules _lex-rule-complex-10                      (ref.func $lex-match-complex-10))
   (table.set $lexical-rules _lex-rule-complex-8                       (ref.func $lex-match-complex-8))
   (table.set $lexical-rules _lex-rule-complex-2                       (ref.func $lex-match-complex-2))
   (table.set $lexical-rules _lex-rule-simple-im                       (ref.func $lex-match-simple-im))
   (table.set $lexical-rules _lex-rule-unit-im                         (ref.func $lex-match-unit-im))
   (table.set $lexical-rules _lex-rule-complex-i                       (ref.func $lex-match-complex-i))
   (table.set $lexical-rules _lex-rule-infnan-im                       (ref.func $lex-match-infnan-im))
   (table.set $lexical-rules _lex-rule-complex-16/group-1              (ref.func $lex-match-complex-16/group-1))
   (table.set $lexical-rules _lex-rule-complex-10/group-1              (ref.func $lex-match-complex-10/group-1))
   (table.set $lexical-rules _lex-rule-complex-8/group-1               (ref.func $lex-match-complex-8/group-1))
   (table.set $lexical-rules _lex-rule-complex-2/group-1               (ref.func $lex-match-complex-2/group-1))
   (table.set $lexical-rules _lex-rule-complex-polar-16                (ref.func $lex-match-complex-polar-16))
   (table.set $lexical-rules _lex-rule-complex-polar-10                (ref.func $lex-match-complex-polar-10))
   (table.set $lexical-rules _lex-rule-complex-polar-8                 (ref.func $lex-match-complex-polar-8))
   (table.set $lexical-rules _lex-rule-complex-polar-2                 (ref.func $lex-match-complex-polar-2))
   (table.set $lexical-rules _lex-rule-complex-infnan-im-16            (ref.func $lex-match-complex-infnan-im-16))
   (table.set $lexical-rules _lex-rule-complex-infnan-im-10            (ref.func $lex-match-complex-infnan-im-10))
   (table.set $lexical-rules _lex-rule-complex-infnan-im-8             (ref.func $lex-match-complex-infnan-im-8))
   (table.set $lexical-rules _lex-rule-complex-infnan-im-2             (ref.func $lex-match-complex-infnan-im-2))
   (table.set $lexical-rules _lex-rule-complex-16/group-2              (ref.func $lex-match-complex-16/group-2))
   (table.set $lexical-rules _lex-rule-complex-10/group-2              (ref.func $lex-match-complex-10/group-2))
   (table.set $lexical-rules _lex-rule-complex-8/group-2               (ref.func $lex-match-complex-8/group-2))
   (table.set $lexical-rules _lex-rule-complex-2/group-2               (ref.func $lex-match-complex-2/group-2))
   (table.set $lexical-rules _lex-rule-full-complex-16                 (ref.func $lex-match-full-complex-16))
   (table.set $lexical-rules _lex-rule-full-complex-10                 (ref.func $lex-match-full-complex-10))
   (table.set $lexical-rules _lex-rule-full-complex-8                  (ref.func $lex-match-full-complex-8))
   (table.set $lexical-rules _lex-rule-full-complex-2                  (ref.func $lex-match-full-complex-2))
   (table.set $lexical-rules _lex-rule-complex-unit-im-16              (ref.func $lex-match-complex-unit-im-16))
   (table.set $lexical-rules _lex-rule-complex-unit-im-10              (ref.func $lex-match-complex-unit-im-10))
   (table.set $lexical-rules _lex-rule-complex-unit-im-8               (ref.func $lex-match-complex-unit-im-8))
   (table.set $lexical-rules _lex-rule-complex-unit-im-2               (ref.func $lex-match-complex-unit-im-2))
   (table.set $lexical-rules _lex-rule-complex-im-only-16              (ref.func $lex-match-complex-im-only-16))
   (table.set $lexical-rules _lex-rule-complex-im-only-10              (ref.func $lex-match-complex-im-only-10))
   (table.set $lexical-rules _lex-rule-complex-im-only-8               (ref.func $lex-match-complex-im-only-8))
   (table.set $lexical-rules _lex-rule-complex-im-only-2               (ref.func $lex-match-complex-im-only-2))
   (table.set $lexical-rules _lex-rule-real-16                         (ref.func $lex-match-real-16))
   (table.set $lexical-rules _lex-rule-real-10                         (ref.func $lex-match-real-10))
   (table.set $lexical-rules _lex-rule-real-8                          (ref.func $lex-match-real-8))
   (table.set $lexical-rules _lex-rule-real-2                          (ref.func $lex-match-real-2))
   (table.set $lexical-rules _lex-rule-signed-real-16                  (ref.func $lex-match-signed-real-16))
   (table.set $lexical-rules _lex-rule-signed-real-10                  (ref.func $lex-match-signed-real-10))
   (table.set $lexical-rules _lex-rule-signed-real-8                   (ref.func $lex-match-signed-real-8))
   (table.set $lexical-rules _lex-rule-signed-real-2                   (ref.func $lex-match-signed-real-2))
   (table.set $lexical-rules _lex-rule-ureal-16                        (ref.func $lex-match-ureal-16))
   (table.set $lexical-rules _lex-rule-ureal-10                        (ref.func $lex-match-ureal-10))
   (table.set $lexical-rules _lex-rule-ureal-8                         (ref.func $lex-match-ureal-8))
   (table.set $lexical-rules _lex-rule-ureal-2                         (ref.func $lex-match-ureal-2))
   (table.set $lexical-rules _lex-rule-urational-16                    (ref.func $lex-match-urational-16))
   (table.set $lexical-rules _lex-rule-urational-10                    (ref.func $lex-match-urational-10))
   (table.set $lexical-rules _lex-rule-urational-8                     (ref.func $lex-match-urational-8))
   (table.set $lexical-rules _lex-rule-urational-2                     (ref.func $lex-match-urational-2))
   (table.set $lexical-rules _lex-rule-slash                           (ref.func $lex-match-slash))
   (table.set $lexical-rules _lex-rule-decimal-10                      (ref.func $lex-match-decimal-10))
   (table.set $lexical-rules _lex-rule-significand-forms               (ref.func $lex-match-significand-forms))
   (table.set $lexical-rules _lex-rule-dot-digits-10                   (ref.func $lex-match-dot-digits-10))
   (table.set $lexical-rules _lex-rule-digits-10                       (ref.func $lex-match-digits-10))
   (table.set $lexical-rules _lex-rule-digits-dot-digits-10            (ref.func $lex-match-digits-dot-digits-10))
   (table.set $lexical-rules _lex-rule-digits-10?                      (ref.func $lex-match-digits-10?))
   (table.set $lexical-rules _lex-rule-uinteger-16                     (ref.func $lex-match-uinteger-16))
   (table.set $lexical-rules _lex-rule-uinteger-10                     (ref.func $lex-match-uinteger-10))
   (table.set $lexical-rules _lex-rule-uinteger-8                      (ref.func $lex-match-uinteger-8))
   (table.set $lexical-rules _lex-rule-uinteger-2                      (ref.func $lex-match-uinteger-2))
   (table.set $lexical-rules _lex-rule-prefix-16                       (ref.func $lex-match-prefix-16))
   (table.set $lexical-rules _lex-rule-prefix-10                       (ref.func $lex-match-prefix-10))
   (table.set $lexical-rules _lex-rule-prefix-8                        (ref.func $lex-match-prefix-8))
   (table.set $lexical-rules _lex-rule-prefix-2                        (ref.func $lex-match-prefix-2))
   (table.set $lexical-rules _lex-rule-infnan                          (ref.func $lex-match-infnan))
   (table.set $lexical-rules _lex-rule-inf-or-nan                      (ref.func $lex-match-inf-or-nan))
   (table.set $lexical-rules _lex-rule-suffix                          (ref.func $lex-match-suffix))
   (table.set $lexical-rules _lex-rule-suffix-sequence                 (ref.func $lex-match-suffix-sequence))
   (table.set $lexical-rules _lex-rule-exponent-marker                 (ref.func $lex-match-exponent-marker))
   (table.set $lexical-rules _lex-rule-sign                            (ref.func $lex-match-sign))
   (table.set $lexical-rules _lex-rule-exactness                       (ref.func $lex-match-exactness))
   (table.set $lexical-rules _lex-rule-radix-2                         (ref.func $lex-match-radix-2))
   (table.set $lexical-rules _lex-rule-radix-8                         (ref.func $lex-match-radix-8))
   (table.set $lexical-rules _lex-rule-radix-10                        (ref.func $lex-match-radix-10))
   (table.set $lexical-rules _lex-rule-radix-16                        (ref.func $lex-match-radix-16))
   (table.set $lexical-rules _lex-rule-digit-2                         (ref.func $lex-match-digit-2))
   (table.set $lexical-rules _lex-rule-digit-8                         (ref.func $lex-match-digit-8))
   (table.set $lexical-rules _lex-rule-digit-10                        (ref.func $lex-match-digit))
   (table.set $lexical-rules _lex-rule-digit-16                        (ref.func $lex-match-digit-16))
   (table.set $lexical-rules _lex-rule-digit-16/A-F                    (ref.func $lex-match-digit-16/A-F))
   (table.set $lexical-rules _lex-rule-digit-16/a-f                    (ref.func $lex-match-digit-16/a-f)))

 (func $lex-match-delimited-token (export "lex-match-delimited-token")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-4 _lex-rule-delimited-token
                                  _lex-rule-paren-char
                                  _lex-rule-quoted-string
                                  _lex-rule-delimited-token-string
                                  _lex-rule-vertical-line-quoted-symbol
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-delimited-token))

 (func $lex-match-paren-char (export "lex-match-paren-char")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-charset/ascii _lex-rule-paren-char
                             _string-paren-charset
                             $text
                             $end))

 (elem funcref (ref.func $lex-match-paren-char))

 (func $lex-match-undelimited-token (export "lex-match-undelimited-token")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-2 _lex-rule-undelimited-token
                                  _lex-rule-token/group-1
                                  _lex-rule-token/group-2
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-undelimited-token))

 (func $lex-match-token/group-1 (export "lex-match-token/group-1")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-4 _lex-rule-token/group-1
                                  ;; $lex-rule-number appears before $lex-rule-identifier
                                  ;; so that +i, -1, and <infnan> are categorized as numbers
                                  ;; in the lexer, rather than needing special handling further
                                  ;; downstream in the reader
                                  _lex-rule-number
                                  _lex-rule-ordinary-identifier
                                  _lex-rule-peculiar-identifier
                                  _lex-rule-boolean
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-token/group-1))

 (func $lex-match-token/group-2 (export "lex-match-token/group-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-token/group-2
                                  _lex-rule-character
                                  _lex-rule-token-char
                                  _lex-rule-unquote-splicing
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-token/group-2))

 (func $lex-match-token-char (export "lex-match-token-char")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-charset/ascii _lex-rule-token-char
                             _string-token-charset
                             $text
                             $end))

 (elem funcref (ref.func $lex-match-token-char))

 (func $lex-match-delimited-token-string (export "lex-match-delimited-token-string")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-strings/one-of-2 _lex-rule-delimited-token-string
                                _string-begin-vector
                                _string-begin-bytevector
                                $text
                                $end))

 (elem funcref (ref.func $lex-match-delimited-token-string))

 (func $lex-match-unquote-splicing (export "lex-match-unquote-splicing")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-string _lex-rule-unquote-splicing
                      _string-unquote-splicing
                      $text
                      $end))

 (elem funcref (ref.func $lex-match-unquote-splicing))


 ;; <delimiter>-> <whitespace> | <vertical line>| ( | ) | " | ;

 (func $lex-match-delimiter (export "lex-match-delimiter")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-charset/ascii _lex-rule-delimiter
                             _string-delimiter-charset
                             $text
                             $end))

 (elem funcref (ref.func $lex-match-delimiter))


 ;; <intraline whitespace> -> <space or tab>

 (func $lex-match-intraline-whitespace (export "lex-match-intraline-whitespace")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-charset/ascii _lex-rule-intraline-whitespace
                             _string-intraline-whitespace
                             $text
                             $end))

 (elem funcref (ref.func $lex-match-intraline-whitespace))


 ;; <whitespace>-> <intraline whitespace> | <line ending>

 (func $lex-match-whitespace (export "lex-match-whitespace")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-2 _lex-rule-whitespace
                                  _lex-rule-intraline-whitespace
                                  _lex-rule-line-ending
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-whitespace))

 ;; <vertical line> -> |

 (func $lex-match-vertical-line (export "lex-match-vertical-line")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-char _lex-rule-vertical-line
                    _char-vertical-line
                    $text
                    $end))

 (elem funcref (ref.func $lex-match-vertical-line))

 ;; <line ending> -> <newline> | <return> <newline> | <return>

 (func $lex-match-line-ending (export "lex-match-line-ending")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-2 _lex-rule-line-ending
                                  _lex-rule-line-ending-char
                                  _lex-rule-dos-line-ending
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-line-ending))

 (func $lex-match-line-ending-char (export "lex-match-line-ending-char")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-charset/ascii _lex-rule-line-ending-char
                             _string-line-ending-charset
                             $text
                             $end))

 (elem funcref (ref.func $lex-match-line-ending-char))


 (func $lex-match-dos-line-ending (export "lex-match-dos-line-ending")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-string _lex-rule-dos-line-ending
                      _string-dos-line-ending
                      $text
                      $end))

 (elem funcref (ref.func $lex-match-dos-line-ending))

 ;; <comment> -> ; <all subsequent characters up to a line ending>
 ;;                | <nested comment>
 ;;                | #; <intertoken space> <datum>

 ;; NB: #; is not lexically well-defined here, since <datum> is only
 ;; well-defined at the parse stage.  In fact, #; is similar to '
 ;; (quote) in that it alters how the following datum is parsed.  In
 ;; the case of quote, the following datum is enclosed in a list
 ;; beginning with the symbol "quote".  For #;, the datum is dropped
 ;; and not included in the parsed value.  It is therefore
 ;; categorically different from simple and nested comments, which are
 ;; just text that can be ignored, and so it is not included in
 ;; $lex-match-comment.

 (func $lex-match-comment (export "lex-match-comment")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-2 _lex-rule-comment
                                  _lex-rule-simple-comment
                                  _lex-rule-nested-comment
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-comment))

 (func $lex-match-simple-comment (export "lex-match-simple-comment")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-simple-comment
                                   _lex-rule-semicolon
                                   _lex-rule-simple-comment-continuation
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-simple-comment))

 (func $lex-match-semicolon (export "lex-match-semicolon")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-char _lex-rule-semicolon
                    _char-semicolon
                    $text
                    $end))

 (elem funcref (ref.func $lex-match-semicolon))

 (func $lex-match-simple-comment-continuation (export "lex-match-simple-comment-continuation")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-until-rule _lex-rule-simple-comment-continuation
                          _lex-rule-line-ending
                          $text
                          $end))

 (elem funcref (ref.func $lex-match-simple-comment-continuation))

 (func $lex-match-datum-comment (export "lex-match-datum-comment")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-string _lex-rule-datum-comment
                      _string-begin-datum-comment
                      $text
                      $end))

 (elem funcref (ref.func $lex-match-datum-comment))

 ;;<nested comment> -> #| <comment text> <comment cont>* |#

 (func $lex-match-nested-comment (export "lex-match-nested-comment")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-4 _lex-rule-nested-comment
                                   _lex-rule-begin-nested-comment
                                   _lex-rule-comment-text
                                   _lex-rule-comment-continuations
                                   _lex-rule-end-nested-comment
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-nested-comment))

 (func $lex-match-begin-nested-comment (export "lex-match-begin-nested-comment")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-string _lex-rule-begin-nested-comment
                      _string-begin-nested-comment
                      $text
                      $end))

 (elem funcref (ref.func $lex-match-begin-nested-comment))


 (func $lex-match-comment-continuations (export "lex-match-comment-continuations")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rule/zero-or-more _lex-rule-comment-continuations
                                 _lex-rule-comment-continuation
                                 $text
                                 $end))

 (elem funcref (ref.func $lex-match-comment-continuations))

 (func $lex-match-end-nested-comment (export "lex-match-end-nested-comment")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-string _lex-rule-end-nested-comment
                      _string-end-nested-comment
                      $text
                      $end))

 (elem funcref (ref.func $lex-match-end-nested-comment))


 ;;<comment text> -> <character sequence not containing #| or |#>

 (func $lex-match-comment-text (export "lex-match-comment-text")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-until-rule _lex-rule-comment-text
                          _lex-rule-nested-comment-delimiters
                          $text
                          $end))

 (elem funcref (ref.func $lex-match-comment-text))

 (func $lex-match-nested-comment-delimiters (export "lex-match-nested-comment-delimiters")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-strings/one-of-2 _lex-rule-nested-comment-delimiters
                                _string-begin-nested-comment
                                _string-end-nested-comment
                                $text
                                $end))

 (elem funcref (ref.func $lex-match-nested-comment-delimiters))

 ;; <comment cont> -> <nested comment> <comment text>

 (func $lex-match-comment-continuation (export "lex-match-comment-continuation")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-comment-continuation
                                   _lex-rule-nested-comment
                                   _lex-rule-comment-text
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-comment-continuation))

 ;; <directive> -> #!fold-case | #!no-fold-case

 (func $lex-match-directive (export "lex-match-directive")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-strings/one-of-2 _lex-rule-directive
                                _string-directive-fold-case
                                _string-directive-no-fold-case
                                $text
                                $end))

 (elem funcref (ref.func $lex-match-directive))


 ;; <atmosphere> -> <whitespace> | <comment> | <directive>

 (func $lex-match-atmosphere (export "lex-match-atmosphere")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-atmosphere
                                  _lex-rule-whitespace
                                  _lex-rule-comment
                                  _lex-rule-directive
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-atmosphere))

 ;; <identifier> -> <initial> <subsequent>*
 ;;                    | <vertical line> <symbol element>* <vertical line>
 ;;                    | <peculiar identifier>

 (func $lex-match-identifier (export "lex-match-identifier")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-identifier
                                  _lex-rule-ordinary-identifier
                                  _lex-rule-vertical-line-quoted-symbol
                                  _lex-rule-peculiar-identifier
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-identifier))

 (func $lex-match-ordinary-identifier (export "lex-match-ordinary-identifier")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-ordinary-identifier
                                   _lex-rule-initial
                                   _lex-rule-subsequents
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-ordinary-identifier))

 (func $lex-match-subsequents (export "lex-match-subsequents")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rule/zero-or-more _lex-rule-subsequents
                                 _lex-rule-subsequent
                                 $text
                                 $end))

 (elem funcref (ref.func $lex-match-subsequents))

 (func $lex-match-vertical-line-quoted-symbol (export "lex-match-vertical-line-quoted-symbol")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-vertical-line-quoted-symbol
                                   _lex-rule-vertical-line
                                   _lex-rule-symbol-elements
                                   _lex-rule-vertical-line
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-vertical-line-quoted-symbol))

 (func $lex-match-symbol-elements (export "lex-match-symbol-elements")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rule/zero-or-more _lex-rule-symbol-elements
                                 _lex-rule-symbol-element
                                 $text
                                 $end))

 (elem funcref (ref.func $lex-match-symbol-elements))

 ;;<initial> -> <letter> | <special initial>

 (func $lex-match-initial (export "lex-match-initial")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-2 _lex-rule-initial
                                  _lex-rule-letter
                                  _lex-rule-special-initial
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-initial))

 ;;<letter> -> a | b | c | ... | z | A | B | C | ... | Z

 (func $lex-match-letter (export "lex-match-letter")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-2 _lex-rule-letter
                                  _lex-rule-lowercase-letter
                                  _lex-rule-uppercase-letter
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-letter))

 (func $lex-match-lowercase-letter (export "lex-match-lowercase-letter")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-char-range/ascii _lex-rule-lowercase-letter
                                _char-a
                                _char-z
                                $text
                                $end))

 (elem funcref (ref.func $lex-match-lowercase-letter))

 (func $lex-match-uppercase-letter (export "lex-match-uppercase-letter")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-char-range/ascii _lex-rule-uppercase-letter
                                _char-A
                                _char-Z
                                $text
                                $end))

 (elem funcref (ref.func $lex-match-uppercase-letter))


 ;; <special initial> -> ! | $ | % | & | * | / | : | < | = | > | ? | ^ | _ | ~

 (func $lex-match-special-initial (export "lex-match-special-initial")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-charset/ascii _lex-rule-special-initial
                             _string-special-initials
                             $text
                             $end))

 (elem funcref (ref.func $lex-match-special-initial))


 ;;<subsequent> -> <initial> | <digit> | <special subsequent>

 (func $lex-match-subsequent (export "lex-match-subsequent")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-subsequent
                                  _lex-rule-initial
                                  _lex-rule-digit
                                  _lex-rule-special-subsequent
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-subsequent))

 ;; <digit> -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

 (func $lex-match-digit (export "lex-match-digit")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-char-range/ascii _lex-rule-digit
                                _char-0
                                _char-9
                                $text
                                $end))

 (elem funcref (ref.func $lex-match-digit))

 ;; <explicit sign> -> + | -

 (func $lex-match-explicit-sign (export "lex-match-explicit-sign")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-charset/ascii _lex-rule-explicit-sign
                             _string-explicit-sign-charset
                             $text
                             $end))

 (elem funcref (ref.func $lex-match-explicit-sign))


 ;; <special subsequent> -> <explicit sign> | . | @

 (func $lex-match-special-subsequent (export "lex-match-special-subsequent")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-charset/ascii _lex-rule-special-subsequent
                             _string-special-subsequent-charset
                             $text
                             $end))

 (elem funcref (ref.func $lex-match-special-subsequent))

 ;; <inline hex escape> -> \x<hex scalar value>;

 (func $lex-match-inline-hex-escape (export "lex-match-inline-hex-escape")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-inline-hex-escape
                                   _lex-rule-inline-hex-escape-prefix
                                   _lex-rule-hex-scalar-value
                                   _lex-rule-semicolon
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-inline-hex-escape))

 (func $lex-match-inline-hex-escape-prefix (export "lex-match-inline-hex-escape-prefix")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-string _lex-rule-inline-hex-escape-prefix
                      _string-inline-escape-prefix
                      $text
                      $end))

 (elem funcref (ref.func $lex-match-inline-hex-escape-prefix))


 ;; <hex scalar value> -> <hex digit>+

 (func $lex-match-hex-scalar-value (export "lex-match-hex-scalar-value")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rule/one-or-more _lex-rule-hex-scalar-value
                                _lex-rule-digit-16
                                $text
                                $end))

 (elem funcref (ref.func $lex-match-hex-scalar-value))

 ;;<mnemonic escape> -> \a | \b | \t | \n | \r

 (func $lex-match-mnemonic-escape (export "lex-match-mnemonic-escape")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-mnemonic-escape
                                   _lex-rule-backslash
                                   _lex-rule-mnemonic-escape-character
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-mnemonic-escape))

 (func $lex-match-backslash (export "lex-match-backslash")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-char _lex-rule-backslash
                    _char-backslash
                    $text
                    $end))

 (elem funcref (ref.func $lex-match-backslash))

 (func $lex-match-mnemonic-escape-character (export "lex-match-mnemonic-escape-character")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-charset/ascii _lex-rule-mnemonic-escape-character
                             _string-mnemonic-escapes
                             $text
                             $end))

 (elem funcref (ref.func $lex-match-mnemonic-escape-character))


 ;; <peculiar identifier> -> <explicit sign>
 ;;                             | <explicit sign> <sign subsequent> <subsequent>*
 ;;                             | <explicit sign> . <dot subsequent> <subsequent>*
 ;;                             | . <dot subsequent> <subsequent>*

 (func $lex-match-peculiar-identifier (export "lex-match-peculiar-identifier")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $match-end i32)

   _lex-rule-peculiar-identifier

   (drop  ;; rule-id
    (set! $match-end
          ($lex-match-rules/longest-of-4 _lex-rule-peculiar-identifier
                                         _lex-rule-explicit-sign
                                         _lex-rule-peculiar-identifier/form-1
                                         _lex-rule-peculiar-identifier/form-2
                                         _lex-rule-peculiar-identifier/form-3
                                         $text
                                         $end)))

   $match-end)

 (elem funcref (ref.func $lex-match-peculiar-identifier))

 (func $lex-match-peculiar-identifier/form-1 (export "lex-match-peculiar-identifier/form-1")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-peculiar-identifier/form-1
                                   _lex-rule-explicit-sign
                                   _lex-rule-sign-subsequent
                                   _lex-rule-subsequents
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-peculiar-identifier/form-1))

 (func $lex-match-peculiar-identifier/form-2 (export "lex-match-peculiar-identifier/form-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-4 _lex-rule-peculiar-identifier/form-2
                                   _lex-rule-explicit-sign
                                   _lex-rule-dot
                                   _lex-rule-dot-subsequent
                                   _lex-rule-subsequents
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-peculiar-identifier/form-2))

 (func $lex-match-dot (export "lex-match-dot")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-char _lex-rule-dot
                    _char-dot
                    $text
                    $end))

 (elem funcref (ref.func $lex-match-dot))

 (func $lex-match-peculiar-identifier/form-3 (export "lex-match-peculiar-identifier/form-3")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-peculiar-identifier/form-3
                                   _lex-rule-dot
                                   _lex-rule-dot-subsequent
                                   _lex-rule-subsequents
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-peculiar-identifier/form-3))

 ;; <dot subsequent> -> <sign subsequent> | .

 (func $lex-match-dot-subsequent (export "lex-match-dot-subsequent")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-2 _lex-rule-dot-subsequent
                                  _lex-rule-sign-subsequent
                                  _lex-rule-dot
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-dot-subsequent))

 ;; <sign subsequent> -> <initial> | <explicit sign> | @

 (func $lex-match-sign-subsequent (export "lex-match-sign-subsequent")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-sign-subsequent
                                  _lex-rule-initial
                                  _lex-rule-explicit-sign
                                  _lex-rule-at-sign
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-sign-subsequent))

 (func $lex-match-at-sign (export "lex-match-at-sign")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-char _lex-rule-at-sign
                    _char-at-sign
                    $text
                    $end))

 (elem funcref (ref.func $lex-match-at-sign))

 ;; <symbol element> -> <any character other than <vertical line> or \>
 ;;                        | <inline hex escape>
 ;;                        | <mnemonic escape>
 ;;                        | \|
 ;;
 ;; NB: this specification does not allow an escaped backslash inside
 ;; of a vertical-line quoted symbol, though a sample of 3 modern
 ;; scheme implementations -- gauche, guile, and racket -- suggest
 ;; that this is generally supported.

 (func $lex-match-symbol-element (export "lex-match-symbol-element")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-4 _lex-rule-symbol-element
                                  _lex-rule-symbol-element/character
                                  _lex-rule-inline-hex-escape
                                  _lex-rule-mnemonic-escape
                                  _lex-rule-escaped-vertical-line
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-symbol-element))

 (func $lex-match-symbol-element/character (export "lex-match-symbol-element/character")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-char-complement/set-of-2 _lex-rule-symbol-element/character
                                        _char-vertical-line
                                        _char-backslash
                                        $text
                                        $end))

 (elem funcref (ref.func $lex-match-symbol-element/character))

 (func $lex-match-escaped-vertical-line (export "lex-match-escaped-vertical-line")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-escaped-vertical-line
                                   _lex-rule-backslash
                                   _lex-rule-vertical-line
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-escaped-vertical-line))

 ;; <boolean> -> #t | #f | #true | #false

 (func $lex-match-boolean (export "lex-match-boolean")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-strings/longest-of-4 _lex-rule-boolean
                                    _string-boolean-t
                                    _string-boolean-f
                                    _string-boolean-true
                                    _string-boolean-false
                                    $text
                                    $end))

 (elem funcref (ref.func $lex-match-boolean))



 ;; <character> -> #\ <any character>
 ;;                  | #\ <character name>
 ;;                  | #\x<hex scalar value>

 (func $lex-match-character (export "lex-match-character")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-character
                                  _lex-rule-escaped-character
                                  _lex-rule-named-character
                                  _lex-rule-escaped-character-hex
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-character))

 (func $lex-match-escaped-character (export "lex-match-escaped-character")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-escaped-character
                                   _lex-rule-character-prefix
                                   _lex-rule-single-character
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-escaped-character))

 (func $lex-match-single-character (export "lex-match-single-character")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-any-char _lex-rule-single-character
                        $text
                        $end))

 (elem funcref (ref.func $lex-match-single-character))

 (func $lex-match-character-prefix (export "lex-match-character-prefix")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-string _lex-rule-character-prefix
                      _string-character-prefix
                      $text
                      $end))

 (elem funcref (ref.func $lex-match-character-prefix))


 (func $lex-match-named-character (export "lex-match-named-character")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-named-character
                                   _lex-rule-character-prefix
                                   _lex-rule-character-name
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-named-character))

 (func $lex-match-escaped-character-hex (export "lex-match-escaped-character-hex")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-escaped-character-hex
                                   _lex-rule-character-hex-prefix
                                   _lex-rule-hex-scalar-value
                                   _lex-rule-semicolon
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-escaped-character-hex))

 (func $lex-match-character-hex-prefix (export "lex-match-character-hex-prefix")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-string _lex-rule-character-hex-prefix
                      _string-character-hex-prefix
                      $text
                      $end))

 (elem funcref (ref.func $lex-match-character-hex-prefix))


 ;; <character name> -> alarm | backspace | delete | escape
 ;;                       | newline | null | return | space | tab

 (func $lex-match-character-name (export "lex-match-character-name")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $match-end i32)

   _lex-rule-character-name

   (drop ;; rule-id
    (set! $match-end
          ($lex-match-rules/longest-of-3 _lex-rule-character-name
                                         _lex-rule-character-name/group-1
                                         _lex-rule-character-name/group-2
                                         _lex-rule-character-name/group-3
                                         $text
                                         $end)))

   $match-end)

 (elem funcref (ref.func $lex-match-character-name))

 (func $lex-match-character-name/group-1 (export "lex-match-character-name/group-1")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-strings/one-of-3 _lex-rule-character-name/group-1
                                _string-alarm
                                _string-backspace
                                _string-delete
                                $text
                                $end))

 (elem funcref (ref.func $lex-match-character-name/group-1))

 (func $lex-match-character-name/group-2 (export "lex-match-character-name/group-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-strings/one-of-3 _lex-rule-character-name/group-2
                                _string-escape
                                _string-newline
                                _string-null
                                $text
                                $end))

 (elem funcref (ref.func $lex-match-character-name/group-2))

 (func $lex-match-character-name/group-3 (export "lex-match-character-name/group-3")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-strings/one-of-3 _lex-rule-character-name/group-3
                                _string-return
                                _string-space
                                _string-tab
                                $text
                                $end))

 (elem funcref (ref.func $lex-match-character-name/group-3))


 ;; <string> -> " <string element>* "

 (func $lex-match-quoted-string (export "lex-match-quoted-string")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-quoted-string
                                   _lex-rule-double-quote
                                   _lex-rule-string-elements
                                   _lex-rule-double-quote
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-string))

 (func $lex-match-double-quote (export "lex-match-double-quote")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-char _lex-rule-double-quote
                    _char-double-quote
                    $text
                    $end))

 (elem funcref (ref.func $lex-match-double-quote))

 (func $lex-match-string-elements (export "lex-match-string-elements")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rule/zero-or-more _lex-rule-string-elements
                                 _lex-rule-string-element
                                 $text
                                 $end))

 (elem funcref (ref.func $lex-match-string-elements))

 ;; <string element> -> <any character other than " or \>
 ;;                        | <mnemonic escape> | \ " | \\
 ;;                        | \<intraline whitespace>*<line ending><intraline whitespace>*
 ;;                        | <inline hex escape>

 (func $lex-match-string-element (export "lex-match-string-element")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-4 _lex-rule-string-element
                                  _lex-rule-string-element/character
                                  _lex-rule-string-element/character-escape
                                  _lex-rule-escaped-line-ending
                                  _lex-rule-inline-hex-escape
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-string-element))

 (func $lex-match-string-element/character (export "lex-match-string-element/character")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-char-complement/set-of-2 _lex-rule-string-element/character
                                        _char-double-quote
                                        _char-backslash
                                        $text
                                        $end))

 (elem funcref (ref.func $lex-match-string-element/character))

 (func $lex-match-string-element/character-escape (export "lex-match-string-element/character-escape")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-string-element/character-escape
                                  _lex-rule-mnemonic-escape
                                  _lex-rule-escaped-double-quote
                                  _lex-rule-escaped-backslash
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-string-element/character-escape))

 (func $lex-match-escaped-double-quote (export "lex-match-escaped-double-quote")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-escaped-double-quote
                                   _lex-rule-backslash
                                   _lex-rule-double-quote
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-escaped-double-quote))

 (func $lex-match-escaped-backslash (export "lex-match-escaped-backslash")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-escaped-backslash
                                   _lex-rule-backslash
                                   _lex-rule-backslash
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-escaped-backslash))

 (func $lex-match-escaped-line-ending (export "lex-match-escaped-line-ending")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-4 _lex-rule-escaped-line-ending
                                   _lex-rule-backslash
                                   _lex-rule-some-intraline-whitespace
                                   _lex-rule-line-ending
                                   _lex-rule-some-intraline-whitespace
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-escaped-line-ending))

 (func $lex-match-some-intraline-whitespace (export "lex-match-some-intraline-whitespace")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rule/zero-or-more _lex-rule-some-intraline-whitespace
                                 _lex-rule-intraline-whitespace
                                 $text
                                 $end))

 (elem funcref (ref.func $lex-match-some-intraline-whitespace))

 ;;<number> -> <num 2> | <num 8> | <num 10> | <num 16>

 (func $lex-match-number (export "lex-match-number")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-4 _lex-rule-number
                                  _lex-rule-num-2
                                  _lex-rule-num-8
                                  _lex-rule-num-10
                                  _lex-rule-num-16
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-number))

 ;; <num 2> -> <prefix 2> <complex 2>

 (func $lex-match-num-2 (export "lex-match-num-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-num-2
                                   _lex-rule-prefix-2
                                   _lex-rule-complex-2
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-num-2))

 ;; <num 8> -> <prefix 8> <complex 8>

 (func $lex-match-num-8 (export "lex-match-num-8")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-num-8
                                   _lex-rule-prefix-8
                                   _lex-rule-complex-8
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-num-8))

 ;; <num 10> -> <prefix 10> <complex 10>

 (func $lex-match-num-10 (export "lex-match-num-10")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-num-10
                                   _lex-rule-prefix-10
                                   _lex-rule-complex-10
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-num-10))

 ;; <num 16> -> <prefix 16> <complex 16>

 (func $lex-match-num-16 (export "lex-match-num-16")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-num-16
                                   _lex-rule-prefix-16
                                   _lex-rule-complex-16
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-num-16))

 ;; <complex R> -> <real R> | <real R> @ <real R>
 ;;                   | <real R> + <ureal R> i | <real R> - <ureal R> i
 ;;                   | <real R> + i | <real R> - i | <real R> <infnan> i
 ;;                   | + <ureal R> i | - <ureal R> i
 ;;                   | <infnan> i | + i | - i

 (func $lex-match-complex-16 (export "lex-match-complex-16")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-complex-16
                                  _lex-rule-complex-16/group-1
                                  _lex-rule-complex-16/group-2
                                  _lex-rule-simple-im
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-complex-16))

 (func $lex-match-complex-10 (export "lex-match-complex-10")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-complex-10
                                  _lex-rule-complex-10/group-1
                                  _lex-rule-complex-10/group-2
                                  _lex-rule-simple-im
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-complex-10))

 (func $lex-match-complex-8 (export "lex-match-complex-8")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-complex-8
                                  _lex-rule-complex-8/group-1
                                  _lex-rule-complex-8/group-2
                                  _lex-rule-simple-im
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-complex-8))

 (func $lex-match-complex-2 (export "lex-match-complex-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-complex-2
                                  _lex-rule-complex-2/group-1
                                  _lex-rule-complex-2/group-2
                                  _lex-rule-simple-im
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-complex-2))

 (func $lex-match-simple-im (export "lex-match-simple-im")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-2 _lex-rule-simple-im
                                  _lex-rule-unit-im
                                  _lex-rule-infnan-im
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-simple-im))

 (func $lex-match-unit-im (export "lex-match-unit-im")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-unit-im
                                   _lex-rule-explicit-sign
                                   _lex-rule-complex-i
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-unit-im))

 (func $lex-match-complex-i (export "lex-match-complex-i")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-char/ascii-ci _lex-rule-complex-i
                             _char-i
                             $text
                             $end))

 (elem funcref (ref.func $lex-match-complex-i))

 (func $lex-match-infnan-im (export "lex-match-infnan-im")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-infnan-im
                                   _lex-rule-infnan
                                   _lex-rule-complex-i
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-infnan-im))

 (func $lex-match-complex-16/group-1 (export "lex-match-complex-16/group-1")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-complex-16/group-1
                                  _lex-rule-real-16
                                  _lex-rule-complex-polar-16
                                  _lex-rule-complex-infnan-im-16
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-complex-16/group-1))

 (func $lex-match-complex-10/group-1 (export "lex-match-complex-10/group-1")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-complex-10/group-1
                                  _lex-rule-real-10
                                  _lex-rule-complex-polar-10
                                  _lex-rule-complex-infnan-im-10
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-complex-10/group-1))

 (func $lex-match-complex-8/group-1 (export "lex-match-complex-8/group-1")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-complex-8/group-1
                                  _lex-rule-real-8
                                  _lex-rule-complex-polar-8
                                  _lex-rule-complex-infnan-im-8
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-complex-8/group-1))

 (func $lex-match-complex-2/group-1 (export "lex-match-complex-2/group-1")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-complex-2/group-1
                                  _lex-rule-real-2
                                  _lex-rule-complex-polar-2
                                  _lex-rule-complex-infnan-im-2
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-complex-2/group-1))

 (func $lex-match-complex-polar-16 (export "lex-match-complex-polar-16")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-complex-polar-16
                                   _lex-rule-real-16
                                   _lex-rule-at-sign
                                   _lex-rule-real-16
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-complex-polar-16))

 (func $lex-match-complex-polar-10 (export "lex-match-complex-polar-10")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-complex-polar-10
                                   _lex-rule-real-10
                                   _lex-rule-at-sign
                                   _lex-rule-real-10
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-complex-polar-10))

 (func $lex-match-complex-polar-8 (export "lex-match-complex-polar-8")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-complex-polar-8
                                   _lex-rule-real-8
                                   _lex-rule-at-sign
                                   _lex-rule-real-8
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-complex-polar-8))

 (func $lex-match-complex-polar-2 (export "lex-match-complex-polar-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-complex-polar-2
                                   _lex-rule-real-2
                                   _lex-rule-at-sign
                                   _lex-rule-real-2
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-complex-polar-2))

 (func $lex-match-complex-infnan-im-16 (export "lex-match-complex-infnan-im-16")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-complex-infnan-im-16
                                   _lex-rule-real-16
                                   _lex-rule-infnan
                                   _lex-rule-complex-i
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-complex-infnan-im-16))

 (func $lex-match-complex-infnan-im-10 (export "lex-match-complex-infnan-im-10")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-complex-infnan-im-10
                                   _lex-rule-real-10
                                   _lex-rule-infnan
                                   _lex-rule-complex-i
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-complex-infnan-im-10))

 (func $lex-match-complex-infnan-im-8 (export "lex-match-complex-infnan-im-8")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-complex-infnan-im-8
                                   _lex-rule-real-8
                                   _lex-rule-infnan
                                   _lex-rule-complex-i
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-complex-infnan-im-8))

 (func $lex-match-complex-infnan-im-2 (export "lex-match-complex-infnan-im-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-complex-infnan-im-2
                                   _lex-rule-real-2
                                   _lex-rule-infnan
                                   _lex-rule-complex-i
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-complex-infnan-im-2))

 (func $lex-match-complex-16/group-2 (export "lex-match-complex-16/group-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-complex-16/group-2
                                  _lex-rule-full-complex-16
                                  _lex-rule-complex-unit-im-16
                                  _lex-rule-complex-im-only-16
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-complex-16/group-2))

 (func $lex-match-complex-10/group-2 (export "lex-match-complex-10/group-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-complex-10/group-2
                                  _lex-rule-full-complex-10
                                  _lex-rule-complex-unit-im-10
                                  _lex-rule-complex-im-only-10
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-complex-10/group-2))

 (func $lex-match-complex-8/group-2 (export "lex-match-complex-8/group-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-complex-8/group-2
                                  _lex-rule-full-complex-8
                                  _lex-rule-complex-unit-im-8
                                  _lex-rule-complex-im-only-8
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-complex-8/group-2))

 (func $lex-match-complex-2/group-2 (export "lex-match-complex-2/group-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-complex-2/group-2
                                  _lex-rule-full-complex-2
                                  _lex-rule-complex-unit-im-2
                                  _lex-rule-complex-im-only-2
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-complex-2/group-2))

 (func $lex-match-full-complex-16 (export "lex-match-full-complex-16")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-4 _lex-rule-full-complex-16
                                   _lex-rule-real-16
                                   _lex-rule-explicit-sign
                                   _lex-rule-ureal-16
                                   _lex-rule-complex-i
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-full-complex-16))

 (func $lex-match-full-complex-10 (export "lex-match-full-complex-10")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-4 _lex-rule-full-complex-10
                                   _lex-rule-real-10
                                   _lex-rule-explicit-sign
                                   _lex-rule-ureal-10
                                   _lex-rule-complex-i
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-full-complex-10))

 (func $lex-match-full-complex-8 (export "lex-match-full-complex-8")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-4 _lex-rule-full-complex-8
                                   _lex-rule-real-8
                                   _lex-rule-explicit-sign
                                   _lex-rule-ureal-8
                                   _lex-rule-complex-i
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-full-complex-8))

 (func $lex-match-full-complex-2 (export "lex-match-full-complex-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-4 _lex-rule-full-complex-2
                                   _lex-rule-real-2
                                   _lex-rule-explicit-sign
                                   _lex-rule-ureal-2
                                   _lex-rule-complex-i
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-full-complex-2))

 (func $lex-match-complex-unit-im-16 (export "lex-match-complex-unit-im-16")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-complex-unit-im-16
                                   _lex-rule-real-16
                                   _lex-rule-explicit-sign
                                   _lex-rule-complex-i
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-complex-unit-im-16))

 (func $lex-match-complex-unit-im-10 (export "lex-match-complex-unit-im-10")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-complex-unit-im-10
                                   _lex-rule-real-10
                                   _lex-rule-explicit-sign
                                   _lex-rule-complex-i
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-complex-unit-im-10))

 (func $lex-match-complex-unit-im-8 (export "lex-match-complex-unit-im-8")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-complex-unit-im-8
                                   _lex-rule-real-8
                                   _lex-rule-explicit-sign
                                   _lex-rule-complex-i
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-complex-unit-im-8))

 (func $lex-match-complex-unit-im-2 (export "lex-match-complex-unit-im-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-complex-unit-im-2
                                   _lex-rule-real-2
                                   _lex-rule-explicit-sign
                                   _lex-rule-complex-i
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-complex-unit-im-2))

 (func $lex-match-complex-im-only-16 (export "lex-match-complex-im-only-16")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-complex-im-only-16
                                   _lex-rule-explicit-sign
                                   _lex-rule-ureal-16
                                   _lex-rule-complex-i
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-complex-im-only-16))

 (func $lex-match-complex-im-only-10 (export "lex-match-complex-im-only-10")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-complex-im-only-10
                                   _lex-rule-explicit-sign
                                   _lex-rule-ureal-10
                                   _lex-rule-complex-i
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-complex-im-only-10))

 (func $lex-match-complex-im-only-8 (export "lex-match-complex-im-only-8")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-complex-im-only-8
                                   _lex-rule-explicit-sign
                                   _lex-rule-ureal-8
                                   _lex-rule-complex-i
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-complex-im-only-8))

 (func $lex-match-complex-im-only-2 (export "lex-match-complex-im-only-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-complex-im-only-2
                                   _lex-rule-explicit-sign
                                   _lex-rule-ureal-2
                                   _lex-rule-complex-i
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-complex-im-only-2))

 ;;<real R> -> <sign> <ureal R> | <infnan>

 (func $lex-match-real-16 (export "lex-match-real-16")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-2 _lex-rule-real-16
                                  _lex-rule-signed-real-16
                                  _lex-rule-infnan
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-real-16))

 (func $lex-match-real-10 (export "lex-match-real-10")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-2 _lex-rule-real-10
                                  _lex-rule-signed-real-10
                                  _lex-rule-infnan
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-real-10))

 (func $lex-match-real-8 (export "lex-match-real-8")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-2 _lex-rule-real-8
                                  _lex-rule-signed-real-8
                                  _lex-rule-infnan
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-real-8))

 (func $lex-match-real-2 (export "lex-match-real-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-2 _lex-rule-real-2
                                  _lex-rule-signed-real-2
                                  _lex-rule-infnan
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-real-2))

 (func $lex-match-signed-real-16 (export "lex-match-signed-real-16")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-signed-real-16
                                   _lex-rule-sign
                                   _lex-rule-ureal-16
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-signed-real-16))

 (func $lex-match-signed-real-10 (export "lex-match-signed-real-10")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-signed-real-10
                                   _lex-rule-sign
                                   _lex-rule-ureal-10
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-signed-real-10))

 (func $lex-match-signed-real-8 (export "lex-match-signed-real-8")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-signed-real-8
                                   _lex-rule-sign
                                   _lex-rule-ureal-8
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-signed-real-8))

 (func $lex-match-signed-real-2 (export "lex-match-signed-real-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-signed-real-2
                                   _lex-rule-sign
                                   _lex-rule-ureal-2
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-signed-real-2))


 ;; <ureal R> -> <uinteger R> | <uinteger R> / <uinteger R> | <decimal R>
 ;;  Note: the decimal term is only present for R = 10

 (func $lex-match-ureal-16 (export "lex-match-ureal-16")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-2 _lex-rule-ureal-16
                                  _lex-rule-uinteger-16
                                  _lex-rule-urational-16
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-ureal-16))

 (func $lex-match-ureal-10 (export "lex-match-ureal-10")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-ureal-10
                                  _lex-rule-uinteger-10
                                  _lex-rule-urational-10
                                  _lex-rule-decimal-10
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-ureal-10))

 (func $lex-match-ureal-8 (export "lex-match-ureal-8")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-2 _lex-rule-ureal-8
                                  _lex-rule-uinteger-8
                                  _lex-rule-urational-8
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-ureal-8))

 (func $lex-match-ureal-2 (export "lex-match-ureal-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-2 _lex-rule-ureal-2
                                  _lex-rule-uinteger-2
                                  _lex-rule-urational-2
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-ureal-2))

 (func $lex-match-urational-16 (export "lex-match-urational-16")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-urational-16
                                   _lex-rule-uinteger-16
                                   _lex-rule-slash
                                   _lex-rule-uinteger-16
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-urational-16))

 (func $lex-match-urational-10 (export "lex-match-urational-10")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-urational-10
                                   _lex-rule-uinteger-10
                                   _lex-rule-slash
                                   _lex-rule-uinteger-10
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-urational-10))

 (func $lex-match-urational-8 (export "lex-match-urational-8")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-urational-8
                                   _lex-rule-uinteger-8
                                   _lex-rule-slash
                                   _lex-rule-uinteger-8
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-urational-8))

 (func $lex-match-urational-2 (export "lex-match-urational-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-urational-2
                                   _lex-rule-uinteger-2
                                   _lex-rule-slash
                                   _lex-rule-uinteger-2
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-urational-2))

 (func $lex-match-slash (export "lex-match-slash")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-char _lex-rule-slash
                    _char-slash
                    $text
                    $end))

 (elem funcref (ref.func $lex-match-slash))

 ;; <decimal 10> -> <uinteger 10> <suffix>
 ;;                    | . <digit 10>+ <suffix>
 ;;                    | <digit 10>+ . <digit 10>* <suffix>

 (func $lex-match-decimal-10 (export "lex-match-decimal-10")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-decimal-10
                                   _lex-rule-significand-forms
                                   _lex-rule-suffix
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-decimal-10))

 (func $lex-match-significand-forms (export "lex-match-significand-forms")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-significand-forms
                                  _lex-rule-uinteger-10
                                  _lex-rule-dot-digits-10
                                  _lex-rule-digits-dot-digits-10
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-significand-forms))

 (func $lex-match-dot-digits-10 (export "lex-match-dot-digits-10")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-dot-digits-10
                                   _lex-rule-dot
                                   _lex-rule-digits-10
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-dot-digits-10))

 (func $lex-match-digits-10 (export "lex-match-digits-10")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rule/one-or-more _lex-rule-digits-10
                                _lex-rule-digit-10
                                $text
                                $end))

 (elem funcref (ref.func $lex-match-digits-10))

 (func $lex-match-digits-dot-digits-10 (export "lex-match-digits-dot-digits-10")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-digits-dot-digits-10
                                   _lex-rule-digits-10
                                   _lex-rule-dot
                                   _lex-rule-digits-10?
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-digits-dot-digits-10))

 (func $lex-match-digits-10? (export "lex-match-digits-10?")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rule/zero-or-more _lex-rule-digits-10?
                                 _lex-rule-digit-10
                                 $text
                                 $end))

 (elem funcref (ref.func $lex-match-digits-10?))

 ;; <uinteger R> -> <digit R>

 (func $lex-match-uinteger-16 (export "lex-match-uinteger-16")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rule/one-or-more _lex-rule-uinteger-16
                                _lex-rule-digit-16
                                $text
                                $end))

 (elem funcref (ref.func $lex-match-uinteger-16))

 (func $lex-match-uinteger-10 (export "lex-match-uinteger-10")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rule/one-or-more _lex-rule-uinteger-10
                                _lex-rule-digit-10
                                $text
                                $end))

 (elem funcref (ref.func $lex-match-uinteger-10))

 (func $lex-match-uinteger-8 (export "lex-match-uinteger-8")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rule/one-or-more _lex-rule-uinteger-8
                                _lex-rule-digit-8
                                $text
                                $end))

 (elem funcref (ref.func $lex-match-uinteger-8))

 (func $lex-match-uinteger-2 (export "lex-match-uinteger-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rule/one-or-more _lex-rule-uinteger-2
                                _lex-rule-digit-2
                                $text
                                $end))

 (elem funcref (ref.func $lex-match-uinteger-2))

 ;; <prefix R> -> <radix R> <exactness> | <exactness> <radix R>

 (func $lex-match-prefix-16 (export "lex-match-prefix-16")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/set-of-2 _lex-rule-prefix-16
                              _lex-rule-radix-16
                              _lex-rule-exactness
                              $text
                              $end))

 (elem funcref (ref.func $lex-match-prefix-16))

 (func $lex-match-prefix-10 (export "lex-match-prefix-10")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/set-of-2 _lex-rule-prefix-10
                              _lex-rule-radix-10
                              _lex-rule-exactness
                              $text
                              $end))

 (elem funcref (ref.func $lex-match-prefix-10))

 (func $lex-match-prefix-8 (export "lex-match-prefix-8")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/set-of-2 _lex-rule-prefix-8
                              _lex-rule-radix-8
                              _lex-rule-exactness
                              $text
                              $end))

 (elem funcref (ref.func $lex-match-prefix-8))

 (func $lex-match-prefix-2 (export "lex-match-prefix-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/set-of-2 _lex-rule-prefix-2
                              _lex-rule-radix-2
                              _lex-rule-exactness
                              $text
                              $end))

 (elem funcref (ref.func $lex-match-prefix-2))

 ;; <infnan> -> +inf.0 | -inf.0 | +nan.0 | -nan.0

 (func $lex-match-infnan (export "lex-match-infnan")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-2 _lex-rule-infnan
                                   _lex-rule-explicit-sign
                                   _lex-rule-inf-or-nan
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-infnan))

 (func $lex-match-inf-or-nan (export "lex-match-inf-or-nan")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-strings/ascii-ci/one-of-2 _lex-rule-inf-or-nan
                                         _string-inf
                                         _string-nan
                                         $text
                                         $end))

 (elem funcref (ref.func $lex-match-inf-or-nan))


 ;; <suffix> -> <empty> | <exponent marker> <sign> <digit 10>+

 (func $lex-match-suffix (export "lex-match-suffix")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rule? _lex-rule-suffix
                     _lex-rule-suffix-sequence
                     $text
                     $end))

 (elem funcref (ref.func $lex-match-suffix))

 (func $lex-match-suffix-sequence (export "lex-match-suffix-sequence")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/sequence-of-3 _lex-rule-suffix-sequence
                                   _lex-rule-exponent-marker
                                   _lex-rule-sign
                                   _lex-rule-digits-10
                                   $text
                                   $end))

 (elem funcref (ref.func $lex-match-suffix-sequence))

 ;; <exponent marker> -> e

 (func $lex-match-exponent-marker (export "lex-match-exponent-marker")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-char/ascii-ci _lex-rule-exponent-marker
                             _char-e
                             $text
                             $end))

 (elem funcref (ref.func $lex-match-exponent-marker))

 ;;<sign> -> <empty> | + | -

 (func $lex-match-sign (export "lex-match-sign")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rule? _lex-rule-sign
                     _lex-rule-explicit-sign
                     $text
                     $end))

 (elem funcref (ref.func $lex-match-sign))

 ;; <exactness> -> <empty> | #i | #e

 (func $lex-match-exactness (export "lex-match-exactness")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-strings/ascii-ci/longest-of-3 _lex-rule-exactness
                                             _string-empty
                                             _string-exact-prefix
                                             _string-inexact-prefix
                                             $text
                                             $end))

 (elem funcref (ref.func $lex-match-exactness))


 ;; <radix 2> -> #b

 (func $lex-match-radix-2 (export "lex-match-radix-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-string/ascii-ci _lex-rule-radix-2
                               _string-radix-2
                               $text
                               $end))

 (elem funcref (ref.func $lex-match-radix-2))


 ;; <radix 8> -> #o

 (func $lex-match-radix-8 (export "lex-match-radix-8")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-string/ascii-ci _lex-rule-radix-8
                               _string-radix-8
                               $text
                               $end))

 (elem funcref (ref.func $lex-match-radix-8))


 ;;<radix 10> -> <empty> | #d

 (func $lex-match-radix-10 (export "lex-match-radix-10")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-strings/ascii-ci/longest-of-2 _lex-rule-radix-10
                                             _string-empty
                                             _string-radix-10
                                             $text
                                             $end))

 (elem funcref (ref.func $lex-match-radix-10))


 ;; <radix 16> -> #x

 (func $lex-match-radix-16 (export "lex-match-radix-16")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-string/ascii-ci _lex-rule-radix-16
                               _string-radix-16
                               $text
                               $end))

 (elem funcref (ref.func $lex-match-radix-16))


 ;; <digit 2> -> 0 | 1

 (func $lex-match-digit-2 (export "lex-match-digit-2")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-char-range/ascii _lex-rule-digit-2
                                _char-0
                                _char-1
                                $text
                                $end))

 (elem funcref (ref.func $lex-match-digit-2))

 ;; <digit 8> -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7

 (func $lex-match-digit-8 (export "lex-match-digit-8")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-char-range/ascii _lex-rule-digit-8
                                _char-0
                                _char-7
                                $text
                                $end))

 (elem funcref (ref.func $lex-match-digit-8))

 ;; <digit 10> -> <digit>

 (elem funcref (ref.func $lex-match-digit))

 ;; <digit 16> -> <digit 10> | a | b | c | d | e | f

 (func $lex-match-digit-16 (export "lex-match-digit-16")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-rules/longest-of-3 _lex-rule-digit-16
                                  _lex-rule-digit-10
                                  _lex-rule-digit-16/A-F
                                  _lex-rule-digit-16/a-f
                                  $text
                                  $end))

 (elem funcref (ref.func $lex-match-digit-16))

 (func $lex-match-digit-16/A-F (export "lex-match-digit-16/A-F")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-char-range/ascii _lex-rule-digit-16/A-F
                                _char-A
                                _char-F
                                $text
                                $end))

 (elem funcref (ref.func $lex-match-digit-16/A-F))

 (func $lex-match-digit-16/a-f (export "lex-match-digit-16/a-f")
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   ($lex-match-char-range/ascii _lex-rule-digit-16/a-f
                                _char-a
                                _char-f
                                $text
                                $end))

 (elem funcref (ref.func $lex-match-digit-16/a-f))

 )

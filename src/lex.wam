(module

 (import "chars" "calc-encoded-length"     (func $calc-encoded-length   (param i32)         (result i32)))
 (import "chars" "char-eq/ascii-ci"        (func $char-eq/ascii-ci      (param i32 i32)     (result i32)))
 (import "strings" "get-string-char"       (func $get-string-char       (param i32)         (result i32)))
 (import "strings" "match-charset/ascii"   (func $match-charset/ascii   (param i32 i32 i32) (result i32)))
 (import "strings" "match-string"          (func $match-string          (param i32 i32 i32) (result i32)))
 (import "strings" "match-string/ascii-ci" (func $match-string/ascii-ci (param i32 i32 i32) (result i32)))

 (include "./constants.wam")
 (include "./globals.wam")

 (type $lexical-rule-func (func (param i32 i32) (result i32 i32)))
 (table $lexical-rules (export "lexical-rules") #max-lexical-rules funcref)

 (macro %get-char
   (expr ,addr)
   ($get-string-char ,addr))

 (func $lex-match-empty (export "lex-match-empty")
   (param $rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   $rule-id
   $text)

 (func $lex-match-any-char (export "lex-match-any-char")
   (param $rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   $rule-id
   (if (result i32) (i32.eq $text $end)
     (then
      _null)
     (else
      (i32.add (i32.const 1) $text)))) ;; todo unicode

 (func $lex-match-char (export "lex-match-char")
   (param $rule-id i32)
   (param $char i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $c i32)

   (if (i32.eq $text $end)
       (then
        $rule-id
        (return _null)))

   (set! $c (%get-char $text))

   (if (result i32 i32) (i32.eq $char $c)
     (then
      $rule-id
      (i32.add (i32.const 1) $text))
     (else
      $rule-id
      _null)))

 (func $lex-match-char/ascii-ci (export "lex-match-char/ascii-ci")
   (param $rule-id i32)
   (param $char i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $c i32)

   (if (i32.eq $text $end)
       (then
        $rule-id
        (return _null)))

   (set! $c (%get-char $text))

   (if (result i32 i32) ($char-eq/ascii-ci $char $c)
     (then
      $rule-id
      (i32.add (i32.const 1) $text))
     (else
      $rule-id
      _null)))

 (func $lex-match-char-complement/set-of-2 (export "lex-match-char-complement/set-of-2")
   (param $rule-id i32)
   (param $first-char i32)
   (param $second-char i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $c i32)

   (if (i32.eq $text $end)
       (then
        $rule-id
        (return _null)))

   (set! $c (%get-char $text))

   (if (result i32 i32)
       (i32.and (i32.ne $first-char $c) (i32.ne $second-char $c))
     (then
      $rule-id
      (i32.add ($calc-encoded-length $c) $text))
     (else
      $rule-id
      _null)))

 (func $lex-match-char-range/ascii (export "lex-match-char-range/ascii")
   (param $rule-id i32)
   (param $min-char i32)
   (param $max-char i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $c i32)

   (if (i32.eq $text $end)
       (then
        $rule-id
        (return _null)))

   (set! $c (%get-char $text))

   (if (result i32 i32)
       (i32.and (i32.ge_u $c $min-char) (i32.le_u $c $max-char))
     (then
      $rule-id
      (i32.add (i32.const 1) $text))
     (else
      $rule-id
      _null)))

 (func $lex-match-charset/ascii (export "lex-match-charset/ascii")
   (param $rule-id i32)
   (param $str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   $rule-id
   ($match-charset/ascii $str $text $end))

 (func $lex-match-string (export "lex-match-string")
   (param $rule-id i32)
   (param $str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   $rule-id
   ($match-string $str $text $end))

 (func $lex-match-string/ascii-ci (export "lex-match-string/ascii-ci")
   (param $rule-id i32)
   (param $str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   $rule-id
   ($match-string/ascii-ci $str $text $end))

 (func $lex-match-strings/one-of-2 (export "lex-match-strings/one-of-2")
   (param $rule-id i32)
   (param $first-str i32)
   (param $second-str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)

   (set! $end-match ($match-string $first-str $text $end))

   $rule-id

   (if (result i32) (i32.ne $end-match _null)
     (then $end-match)
     (else ($match-string $second-str $text $end))))

 (func $lex-match-strings/ascii-ci/one-of-2 (export "lex-match-strings/ascii-ci/one-of-2")
   (param $rule-id i32)
   (param $first-str i32)
   (param $second-str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)

   (set! $end-match ($match-string/ascii-ci $first-str $text $end))

   $rule-id

   (if (result i32) (i32.ne $end-match _null)
     (then $end-match)
     (else ($match-string/ascii-ci $second-str $text $end))))

 (func $lex-match-strings/one-of-3 (export "lex-match-strings/one-of-3")
   (param $rule-id i32)
   (param $first-str i32)
   (param $second-str i32)
   (param $third-str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)

   (set! $end-match ($match-string $first-str $text $end))

   $rule-id

   (if (result i32) (i32.ne $end-match _null)
     (then $end-match)

     (else
      (set! $end-match ($match-string $second-str $text $end))

      (if (result i32) (i32.ne $end-match _null)
        (then $end-match)
        (else ($match-string $third-str $text $end))))))

 (func $lex-match-strings/one-of-3/ascii-ci (export "lex-match-strings/one-of-3/ascii-ci")
   (param $rule-id i32)
   (param $first-str i32)
   (param $second-str i32)
   (param $third-str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)

   (set! $end-match ($match-string/ascii-ci $first-str $text $end))

   $rule-id

   (if (result i32) (i32.ne $end-match _null)
     (then $end-match)

     (else
      (set! $end-match ($match-string/ascii-ci $second-str $text $end))

      (if (result i32) (i32.ne $end-match _null)
        (then $end-match)
        (else ($match-string/ascii-ci $third-str $text $end))))))

 (func $lex-match-strings/longest-of-2 (export "lex-match-strings/longest-of-2")
   (param $rule-id i32)
   (param $first-str i32)
   (param $second-str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $max-end i32)

   (set! $max-end (i32.const -1))

   (set! $end-match
         ($match-string $first-str $text $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-string $second-str $text $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   $rule-id
   $max-end)

 (func $lex-match-strings/ascii-ci/longest-of-2 (export "lex-match-strings/ascii-ci/longest-of-2")
   (param $rule-id i32)
   (param $first-str i32)
   (param $second-str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $max-end i32)

   (set! $max-end (i32.const -1))

   (set! $end-match
         ($match-string/ascii-ci $first-str $text $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-string/ascii-ci $second-str $text $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   $rule-id
   $max-end)

 (func $lex-match-strings/longest-of-3 (export "lex-match-strings/longest-of-3")
   (param $rule-id i32)
   (param $first-str i32)
   (param $second-str i32)
   (param $third-str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $max-end i32)

   (set! $max-end (i32.const -1))

   (set! $end-match
         ($match-string $first-str $text $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-string $second-str $text $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-string $third-str $text $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   $rule-id
   $max-end)

 (func $lex-match-strings/ascii-ci/longest-of-3 (export "lex-match-strings/ascii-ci/longest-of-3")
   (param $rule-id i32)
   (param $first-str i32)
   (param $second-str i32)
   (param $third-str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $max-end i32)

   (set! $max-end (i32.const -1))

   (set! $end-match
         ($match-string/ascii-ci $first-str $text $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-string/ascii-ci $second-str $text $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-string/ascii-ci $third-str $text $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   $rule-id
   $max-end)

 (func $lex-match-strings/longest-of-4 (export "lex-match-strings/longest-of-4")
   (param $rule-id i32)
   (param $first-str i32)
   (param $second-str i32)
   (param $third-str i32)
   (param $fourth-str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $max-end i32)

   (set! $max-end (i32.const -1))

   (set! $end-match
         ($match-string $first-str $text $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-string $second-str $text $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-string $third-str $text $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-string $fourth-str $text $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   $rule-id
   $max-end)

 (func $lex-match-strings/ascii-ci/longest-of-4 (export "lex-match-strings/ascii-ci/longest-of-4")
   (param $rule-id i32)
   (param $first-str i32)
   (param $second-str i32)
   (param $third-str i32)
   (param $fourth-str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $max-end i32)

   (set! $max-end (i32.const -1))

   (set! $end-match
         ($match-string/ascii-ci $first-str $text $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-string/ascii-ci $second-str $text $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-string/ascii-ci $third-str $text $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-string/ascii-ci $fourth-str $text $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   $rule-id
   $max-end)

 (func $lex-match-rule? (export "lex-match-rule?")
   (param $rule-id i32)
   (param $target-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)

   (drop ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func) $text $end $target-rule-id)))

   $rule-id
   (if (result i32) (i32.eq $end-match _null)
     (then
      $text)
     (else
      $end-match)))

 (func $lex-match-rule/zero-or-more (export "lex-match-rule/zero-or-more")
   (param $rule-id i32)
   (param $target-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $next-end i32)

   (set! $end-match $text)

   (loop $again

     (drop ;; matching rule id
      (set! $next-end
            (call_indirect $lexical-rules (type $lexical-rule-func)
                           $end-match $end
                           $target-rule-id)))

     (if (i32.gt_s $next-end _null)
         (then
          (set! $end-match $next-end)
          (br $again))))

   $rule-id
   $end-match)

 (func $lex-match-rule/one-or-more (export "lex-match-rule/one-or-more")
   (param $rule-id i32)
   (param $target-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $next-end i32)

   (drop ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func)
                         $text $end
                         $target-rule-id)))

   (if (i32.eq $end-match _null)
       (then
        $rule-id
        _null
        (return)))

   (loop $again

     (drop ;; matching rule id
      (set! $next-end
            (call_indirect $lexical-rules (type $lexical-rule-func)
                           $end-match $end
                           $target-rule-id)))

     (if (i32.ne $next-end _null)
         (then
          (set! $end-match $next-end)
          (br $again))))

   $rule-id
   $end-match)

 (func $lex-match-rules/sequence-of-2 (export "lex-match-rules/sequence-of-2")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)

   (drop  ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func) $text $end $first-rule-id)))

   (if (i32.eq $end-match _null)
       (then
        $rule-id
        _null
        (return)))

   (drop  ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func)
                         $end-match $end
                         $second-rule-id)))

   (if (i32.eq $end-match _null)
       (then
        $rule-id
        _null
        (return)))

   $rule-id
   $end-match)

 (func $lex-match-rules/sequence-of-3 (export "lex-match-rules/sequence-of-3")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $third-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)

   (drop ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func)
                         $text $end
                         $first-rule-id)))

   (if (i32.eq $end-match _null)
       (then
        $rule-id
        _null
        (return)))

   (drop ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func)
                         $end-match $end
                         $second-rule-id)))

   (if (i32.eq $end-match _null)
       (then
        $rule-id
        _null
        (return)))

   (drop ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func)
                         $end-match $end
                         $third-rule-id)))

   (if (i32.eq $end-match _null)
       (then
        $rule-id
        _null
        (return)))

   $rule-id
   $end-match)

 (func $lex-match-rules/sequence-of-4 (export "lex-match-rules/sequence-of-4")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $third-rule-id i32)
   (param $fourth-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)

   (drop ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func)
                         $text $end
                         $first-rule-id)))

   (if (i32.eq $end-match _null)
       (then
        $rule-id
        _null
        (return)))

   (drop ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func)
                         $end-match $end
                         $second-rule-id)))

   (if (i32.eq $end-match _null)
       (then
        $rule-id
        _null
        (return)))

   (drop ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func)
                         $end-match $end
                         $third-rule-id)))

   (if (i32.eq $end-match _null)
       (then
        $rule-id
        _null
        (return)))

   (drop ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func)
                         $end-match $end
                         $fourth-rule-id)))

   (if (i32.eq $end-match _null)
       (then
        $rule-id
        _null
        (return)))

   $rule-id
   $end-match)

 (func $lex-match-rules/longest-of-2 (export "lex-match-rules/longest-of-2")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $matching-rule-id i32)
   (local $end-match i32)

   (local $longest-matching-rule-id i32)
   (local $max-end i32)

   (set! $matching-rule-id $rule-id)
   (set! $end-match _null)

   (set! $longest-matching-rule-id $rule-id)
   (set! $max-end (i32.const -1))

   (set! $matching-rule-id
         (set! $end-match
               (call_indirect $lexical-rules (type $lexical-rule-func)
                              $text $end
                              $first-rule-id)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $longest-matching-rule-id $matching-rule-id)
        (set! $max-end $end-match)))

   (set! $matching-rule-id
         (set! $end-match
               (call_indirect $lexical-rules (type $lexical-rule-func)
                              $text $end
                              $second-rule-id)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $longest-matching-rule-id $matching-rule-id)
        (set! $max-end $end-match)))

   $longest-matching-rule-id
   $max-end)

 (func $lex-match-rules/longest-of-3 (export "lex-match-rules/longest-of-3")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $third-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $matching-rule-id i32)
   (local $end-match i32)

   (local $longest-matching-rule-id i32)
   (local $max-end i32)

   (set! $matching-rule-id $rule-id)
   (set! $end-match _null)

   (set! $longest-matching-rule-id $rule-id)
   (set! $max-end (i32.const -1))

   (set! $matching-rule-id
         (set! $end-match
               (call_indirect $lexical-rules (type $lexical-rule-func)
                              $text $end
                              $first-rule-id)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $longest-matching-rule-id $matching-rule-id)
        (set! $max-end $end-match)))

   (set! $matching-rule-id
         (set! $end-match
               (call_indirect $lexical-rules (type $lexical-rule-func)
                              $text $end
                              $second-rule-id)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $longest-matching-rule-id $matching-rule-id)
        (set! $max-end $end-match)))

   (set! $matching-rule-id
         (set! $end-match
               (call_indirect $lexical-rules (type $lexical-rule-func)
                              $text $end
                              $third-rule-id)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $longest-matching-rule-id $matching-rule-id)
        (set! $max-end $end-match)))

   $longest-matching-rule-id
   $max-end)

 (func $lex-match-rules/longest-of-4 (export "lex-match-rules/longest-of-4")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $third-rule-id i32)
   (param $fourth-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $matching-rule-id i32)
   (local $end-match i32)

   (local $longest-matching-rule-id i32)
   (local $max-end i32)

   (set! $matching-rule-id $rule-id)
   (set! $end-match _null)

   (set! $longest-matching-rule-id $rule-id)
   (set! $max-end (i32.const -1))

   (set! $matching-rule-id
         (set! $end-match
               (call_indirect $lexical-rules (type $lexical-rule-func)
                              $text $end
                              $first-rule-id)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $longest-matching-rule-id $matching-rule-id)
        (set! $max-end $end-match)))

   (set! $matching-rule-id
         (set! $end-match
               (call_indirect $lexical-rules (type $lexical-rule-func)
                              $text $end
                              $second-rule-id)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $longest-matching-rule-id $matching-rule-id)
        (set! $max-end $end-match)))

   (set! $matching-rule-id
         (set! $end-match
               (call_indirect $lexical-rules (type $lexical-rule-func)
                              $text $end
                              $third-rule-id)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $longest-matching-rule-id $matching-rule-id)
        (set! $max-end $end-match)))

   (set! $matching-rule-id
         (set! $end-match
               (call_indirect $lexical-rules (type $lexical-rule-func)
                              $text $end
                              $fourth-rule-id)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $longest-matching-rule-id $matching-rule-id)
        (set! $max-end $end-match)))

   $longest-matching-rule-id
   $max-end)

 (func $lex-match-rules/set-of-2 (export "lex-match-rules/set-of-2")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $max-end i32)

   (set! $max-end (i32.const -1))

   (drop ;; matching rule id
    (set! $end-match
          ($lex-match-rules/sequence-of-2 $rule-id
                                          $first-rule-id
                                          $second-rule-id
                                          $text
                                          $end)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (drop ;; matching rule id
    (set! $end-match
          ($lex-match-rules/sequence-of-2 $rule-id
                                          $second-rule-id
                                          $first-rule-id
                                          $text
                                          $end)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   $rule-id
   $max-end)

 (func $lex-match-until-rule (export "lex-match-until-rule")
   (param $rule-id i32)
   (param $end-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $current i32)
   (local $end-match i32)

   (set! $current $text)

   (loop $again
     (drop ;; matching rule id
      (set! $end-match
            (call_indirect $lexical-rules (type $lexical-rule-func)
                           $current $end
                           $end-rule-id)))

     (if (i32.lt_u $current $end)
         (then
          (if (i32.eq _null $end-match)
              (then
               (set! $current (i32.add (i32.const 1) $current))
               (br $again))))
       (else
        (set! $current _null))))

   $rule-id
   $current))

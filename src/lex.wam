(module

 ;; todo: write get-string-addr-char (incl reserving 16B at end of block)
 (import "strings" "get-string-addr-char" (func $get-string-addr-char (param i32) (result i32)))

 (include "./ascii.wam")
 (include "./globals.wam")

 (type $lexical-rule-func (func (param i32 i32) (result i32 i32)))
 (table $lexical-rules 200 funcref) ;; todo export

 (macro %load-char
   (expr ,addr)
   (call $get-string-addr-char ,addr))

 (func $ascii-lower (export "ascii-lower")
   (param $x i32)

   (result i32)

   (if (result i32)
       (i32.and
        (i32.ge_u (%get $x) (global.get $char-A))
        (i32.le_u (%get $x) (global.get $char-Z)))
     (then
      (i32.add (%get $x) (i32.const 0x20)))
     (else
      (%get $x))))

 (func $char-eq/ascii-ci (export "char-eq/ascii-ci")
   (param $x i32)
   (param $y i32)

   (result i32)

   (i32.or
    (i32.eq (%get $x) (%get $y))
    (i32.eq (call $ascii-lower (%get $x) (call $ascii-lower (%get $y))))))

 (func $lex-match-empty (export "lex-match-empty")
   (param $rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (%get $rule-id)
   (%get $text))

 (func $lex-match-any-char (export "lex-match-any-char")
   (param $rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (%get $rule-id)
   (if (result i32)
       (i32.eq (%get $text) (%get $end))
     (then
      (%null))
     (else
      (i32.add (i32.const 1) (%get $text))))) ;; todo unicode

 (func $lex-match-char/ascii (export "lex-match-char/ascii")
   (param $rule-id i32)
   (param $char i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $c i32)

   (if (i32.eq (%get $text) (%get $end))
       (then
        (%get $rule-id)
        (return (%null))))

   (%set! $c (%get-char (%get $text)))

   (if (result i32 i32) (i32.eq (%get $char) (%get $c))
     (then
      (%get $rule-id)
      (i32.add (i32.const 1) (%get $text))) ;; todo unicode
     (else
      (%get $rule-id)
      (%null))))

 (func $lex-match-char/ascii-ci (export "lex-match-char/ascii-ci")
   (param $rule-id i32)
   (param $char i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $c i32)

   (if (i32.eq (%get $text) (%get $end))
       (then
        (%get $rule-id)
        (return (%null))))

   (%set! $c (%get-char (%get $text)))

   (if (result i32 i32) (call $char-eq/ascii-ci (%get $char) (%get $c))
     (then
      (%get $rule-id)
      (i32.add (i32.const 1) (%get $text))) ;; todo unicode
     (else
      (%get $rule-id)
      (%null))))

 (func $lex-match-char-complement/ascii/set-of-2 (export "lex-match-char-complement/ascii/set-of-2")
   (param $rule-id i32)
   (param $first-char i32)
   (param $second-char i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $c i32)

   (if (i32.eq (%get $text) (%get $end))
       (then
        (%get $rule-id)
        (return (%null))))

   (%set! $c (%get-char (%get $text)))

   (if (result i32 i32)
       (i32.and (i32.ne (%get $first-char) (%get $c))
                (i32.ne (%get $second-char) (%get $c)))
     (then
      (%get $rule-id)
      (i32.add (i32.const 1) (%get $text))) ;; todo unicode
     (else
      (%get $rule-id)
      (%null))))

 (func $lex-match-char-range/ascii (export "lex-match-char-range/ascii")
   (param $rule-id i32)
   (param $min-char i32)
   (param $max-char i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $c i32)

   (if (i32.eq (%get $text) (%get $end))
       (then
        (%get $rule-id)
        (return (%null))))

   (%set! $c (%get-char (%get $text)))

   (if (result i32 i32)
       (i32.and
        (i32.ge_u (%get $c) (%get $min-char))
        (i32.le_u (%get $c) (%get $max-char)))
     (then
      (%get $rule-id)
      (i32.add (i32.const 1) (%get $text))) ;; todo unicode
     (else
      (%get $rule-id)
      (%null))))

 (func $match-charset (export "match-charset")
   (param $str i32)
   (param $length i32)
   (param $text i32)
   (param $end i32)

   (result i32)

   (local $c i32)
   (local $s i32)
   (local $s-end i32)

   (if (i32.eq (%get $text) (%get $end))
       (then
        (return (%null))))

   (%set! $c (%get-char (%get $text)))

   (%set! $s (%get $str))
   (%set! $s-end (i32.add (%get $s) (%get $length)))

   (loop $again
     (if (i32.lt_u (%get $s) (%get $s-end))
         (then
          (if (i32.eq (%get $c) (%get-char (%get $s)))
              (then
               (i32.add (i32.const 1) (%get $text)) ;; todo unicode
               (return))
            (else
             (%set! $s (i32.add (%get $s) (i32.const 1)))
             (br $again))))))

   (%null))

 (func $lex-match-charset (export "lex-match-charset")
   (param $rule-id i32)
   (param $str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (%get $rule-id)
   (call $match-charset
         (i32.add (i32.const 1) (%get $str))
         (%get-char (%get $str))
         (%get $text)
         (%get $end)))

 (func $match-static-string (export "match-static-string")
   (param $str i32)
   (param $length i32)
   (param $text i32)
   (param $end i32)

   (result i32)

   (local $s i32)
   (local $s-end i32)
   (local $t i32)

   (if (i32.gt_u (%get $length) (i32.sub (%get $end) (%get $text)))
       (then
        (return (%null))))

   (%set! $s (%get $str))
   (%set! $s-end (i32.add (%get $s) (%get $length)))

   (%set! $t (%get $text))

   (loop $again

     (if (i32.lt_u (%get $s) (%get $s-end))
         (then
          (if (i32.eq
               (%get-char (%get $s))
               (%get-char (%get $t)))
              (then
               (%set! $s (i32.add (%get $s) (i32.const 1)))
               (%set! $t (i32.add (%get $t) (i32.const 1)))
               (br $again))
            (else
             (%set! $t (%null)))))))

   (%get $t))

 (func $lex-match-static-string (export "lex-match-static-string")
   (param $rule-id i32)
   (param $str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (%get $rule-id)
   (call $match-static-string
         (i32.add (i32.const 1) (%get $str))
         (%get-char (%get $str))
         (%get $text)
         (%get $end)))

 (func $match-static-string/ascii-ci (export "match-static-string/ascii-ci")
   (param $str i32)
   (param $length i32)
   (param $text i32)
   (param $end i32)

   (result i32)

   (local $s i32)
   (local $s-end i32)
   (local $t i32)

   (if (i32.gt_u (%get $length) (i32.sub (%get $end) (%get $text)))
       (then
        (return (%null))))

   (%set! $s (%get $str))
   (%set! $s-end (i32.add (%get $s) (%get $length)))

   (%set! $t (%get $text))

   (loop $again

     (if (i32.lt_u (%get $s) (%get $s-end))
         (then
          (if (call $char-eq/ascii-ci
                    (%get-char (%get $s))
                    (%get-char (%get $t)))
              (then
               (%set! $s (i32.add (%get $s) (i32.const 1)))
               (%set! $t (i32.add (%get $t) (i32.const 1)))
               (br $again))
            (else
             (%set! $t (%null)))))))

   (%get $t))

 (func $lex-match-static-string/ascii-ci (export "lex-match-static-string/ascii-ci")
   (param $rule-id i32)
   (param $str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (%get $rule-id)
   (call $match-static-string/ascii-ci
         (i32.add (i32.const 1) (%get $str))
         (%get-char (%get $str))
         (%get $text)
         (%get $end)))

 (func $lex-match-static-strings/longest-of-2 (export "lex-match-static-strings/longest-of-2")
   (param $rule-id i32)
   (param $first-str i32)
   (param $second-str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $max-end i32)

   (%set! $max-end (i32.const -1))

   (%set! $end-match
          (call $match-static-string
                (i32.add (i32.const 1) (%get $first-str))
                (%get-char (%get $first-str))
                (%get $text)
                (%get $end)))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $max-end (%get $end-match))))

   (%set! $end-match
          (call $match-static-string
                (i32.add (i32.const 1) (%get $second-str))
                (%get-char (%get $second-str))
                (%get $text)
                (%get $end)))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $max-end (%get $end-match))))

   (%get $rule-id)
   (%get $max-end))

 (func $lex-match-static-strings/ascii-ci/longest-of-2 (export "lex-match-static-strings/ascii-ci/longest-of-2")
   (param $rule-id i32)
   (param $first-str i32)
   (param $second-str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $max-end i32)

   (%set! $max-end (i32.const -1))

   (%set! $end-match
          (call $match-static-string/ascii-ci
                (i32.add (i32.const 1) (%get $first-str))
                (%get-char (%get $first-str))
                (%get $text)
                (%get $end)))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $max-end (%get $end-match))))

   (%set! $end-match
          (call $match-static-string/ascii-ci
                (i32.add (i32.const 1) (%get $second-str))
                (%get-char (%get $second-str))
                (%get $text)
                (%get $end)))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $max-end (%get $end-match))))

   (%get $rule-id)
   (%get $max-end))

 (func $lex-match-static-strings/longest-of-3 (export "lex-match-static-strings/longest-of-3")
   (param $rule-id i32)
   (param $first-str i32)
   (param $second-str i32)
   (param $third-str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $max-end i32)

   (%set! $max-end (i32.const -1))

   (%set! $end-match
          (call $match-static-string
                (i32.add (i32.const 1) (%get $first-str))
                (%get-char (%get $first-str))
                (%get $text)
                (%get $end)))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $max-end (%get $end-match))))

   (%set! $end-match
          (call $match-static-string
                (i32.add (i32.const 1) (%get $second-str))
                (%get-char (%get $second-str))
                (%get $text)
                (%get $end)))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $max-end (%get $end-match))))

   (%set! $end-match
          (call $match-static-string
                (i32.add (i32.const 1) (%get $third-str))
                (%get-char (%get $third-str))
                (%get $text)
                (%get $end)))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $max-end (%get $end-match))))

   (%get $rule-id)
   (%get $max-end))

 (func $lex-match-static-strings/ascii-ci/longest-of-3 (export "lex-match-static-strings/ascii-ci/longest-of-3")
   (param $rule-id i32)
   (param $first-str i32)
   (param $second-str i32)
   (param $third-str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $max-end i32)

   (%set! $max-end (i32.const -1))

   (%set! $end-match
          (call $match-static-string/ascii-ci
                (i32.add (i32.const 1) (%get $first-str))
                (%get-char (%get $first-str))
                (%get $text)
                (%get $end)))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $max-end (%get $end-match))))

   (%set! $end-match
          (call $match-static-string/ascii-ci
                (i32.add (i32.const 1) (%get $second-str))
                (%get-char (%get $second-str))
                (%get $text)
                (%get $end)))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $max-end (%get $end-match))))

   (%set! $end-match
          (call $match-static-string/ascii-ci
                (i32.add (i32.const 1) (%get $third-str))
                (%get-char (%get $third-str))
                (%get $text)
                (%get $end)))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $max-end (%get $end-match))))

   (%get $rule-id)
   (%get $max-end))

 (func $lex-match-static-strings/longest-of-4 (export "lex-match-static-strings/longest-of-4")
   (param $rule-id i32)
   (param $first-str i32)
   (param $second-str i32)
   (param $third-str i32)
   (param $fourth-str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $max-end i32)

   (%set! $max-end (i32.const -1))

   (%set! $end-match
          (call $match-static-string
                (i32.add (i32.const 1) (%get $first-str))
                (%get-char (%get $first-str))
                (%get $text)
                (%get $end)))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $max-end (%get $end-match))))

   (%set! $end-match
          (call $match-static-string
                (i32.add (i32.const 1) (%get $second-str))
                (%get-char (%get $second-str))
                (%get $text)
                (%get $end)))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $max-end (%get $end-match))))

   (%set! $end-match
          (call $match-static-string
                (i32.add (i32.const 1) (%get $third-str))
                (%get-char (%get $third-str))
                (%get $text)
                (%get $end)))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $max-end (%get $end-match))))

   (%set! $end-match
          (call $match-static-string
                (i32.add (i32.const 1) (%get $fourth-str))
                (%get-char (%get $fourth-str))
                (%get $text)
                (%get $end)))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $max-end (%get $end-match))))

   (%get $rule-id)
   (%get $max-end))

 (func $lex-match-rule? (export "lex-match-rule?")
   (param $rule-id i32)
   (param $target-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)

   (drop  ;; matching rule id
    (%set! $end-match
           (call_indirect $lexical-rules (type $lexical-rule-func)
                          (%get $text) (%get $end)
                          (%get $target-rule-id))))

   (%get $rule-id)
   (if (result i32) (i32.eq (%get $end-match) (%null))
     (then
      (%get $text))
     (else
      (%get $end-match))))

 (func $lex-match-rule/zero-or-more (export "lex-match-rule/zero-or-more")
   (param $rule-id i32)
   (param $target-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $next-end i32)

   (%set! $end-match (%get $text))

   (loop $again

     (drop  ;; matching rule id
      (%set! $next-end
             (call_indirect $lexical-rules (type $lexical-rule-func)
                            (%get $end-match) (%get $end)
                            (%get $target-rule-id))))

     (if (i32.gt_s (%get $next-end) (%null))
         (then
          (%set! $end-match (%get $next-end))
          (br $again))))

   (%get $rule-id)
   (%get $end-match))

 (func $lex-match-rule/one-or-more (export "lex-match-rule/one-or-more")
   (param $rule-id i32)
   (param $target-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $next-end i32)

   (drop ;; matching rule id
    (%set! $end-match
           (call_indirect $lexical-rules (type $lexical-rule-func)
                          (%get $text) (%get $end)
                          (%get $target-rule-id))))

   (if (i32.eq (%get $end-match) (%null))
       (then
        (%get $rule-id)
        (%null)
        (return)))

   (loop $again

     (drop ;; matching rule id
      (%set! $next-end
             (call_indirect $lexical-rules (type $lexical-rule-func)
                            (%get $end-match) (%get $end)
                            (%get $target-rule-id))))

     (if (i32.ne (%get $next-end) (%null))
         (then
          (%set! $end-match (%get $next-end))
          (br $again))))

   (%get $rule-id)
   (%get $end-match))

 (func $lex-match-rules/sequence (export "lex-match-rules/sequence")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $last-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $current-rule-id i32)
   (local $end-match i32)

   (%set! $current-rule-id (%get $first-rule-id))
   (%set! $end-match (%get $text))

   (loop $again




     (drop ;; matching rule id
      (%set! $end-match
             (call_indirect $lexical-rules (type $lexical-rule-func)
                            (%get $end-match) (%get $end)
                            (%get $current-rule-id))))

     (if (i32.and
          (i32.gt_s (%get $end-match) (%null))
          (i32.lt_u (%get $current-rule-id) (%get $last-rule-id)))
         (then
          (%set! $current-rule-id (i32.add (i32.const 1) (%get $current-rule-id)))
          (br $again))))

   (%get $rule-id)
   (%get $end-match))

 (func $lex-match-rules/sequence-of-2 (export "lex-match-rules/sequence-of-2")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)

   (drop  ;; matching rule id
    (%set! $end-match
           (call_indirect $lexical-rules (type $lexical-rule-func)
                          (%get $text) (%get $end)
                          (%get $first-rule-id))))

   (if (i32.eq (%get $end-match) (%null))
       (then
        (%get $rule-id)
        (%null)
        (return)))

   (drop  ;; matching rule id
    (%set! $end-match
           (call_indirect $lexical-rules (type $lexical-rule-func)
                          (%get $end-match) (%get $end)
                          (%get $second-rule-id))))

   (if (i32.eq (%get $end-match) (%null))
       (then
        (%get $rule-id)
        (%null)
        (return)))

   (%get $rule-id)
   (%get $end-match))

 (func $lex-match-rules/sequence-of-3 (export "lex-match-rules/sequence-of-3")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $third-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)

   (drop ;; matching rule id
    (%set! $end-match
           (call_indirect $lexical-rules (type $lexical-rule-func)
                          (%get $text) (%get $end)
                          (%get $first-rule-id))))

   (if (i32.eq (%get $end-match) (%null))
       (then
        (%get $rule-id)
        (%null)
        (return)))

   (drop ;; matching rule id
    (%set! $end-match
           (call_indirect $lexical-rules (type $lexical-rule-func)
                          (%get $end-match) (%get $end)
                          (%get $second-rule-id))))

   (if (i32.eq (%get $end-match) (%null))
       (then
        (%get $rule-id)
        (%null)
        (return)))

   (drop ;; matching rule id
    (%set! $end-match
           (call_indirect $lexical-rules (type $lexical-rule-func)
                          (%get $end-match) (%get $end)
                          (%get $third-rule-id))))

   (if (i32.eq (%get $end-match) (%null))
       (then
        (%get $rule-id)
        (%null)
        (return)))

   (%get $rule-id)
   (%get $end-match))

 (func $lex-match-rules/sequence-of-4 (export "lex-match-rules/sequence-of-4")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $third-rule-id i32)
   (param $fourth-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)

   (drop ;; matching rule id
    (%set! $end-match
           (call_indirect $lexical-rules (type $lexical-rule-func)
                          (%get $text) (%get $end)
                          (%get $first-rule-id))))

   (if (i32.eq (%get $end-match) (%null))
       (then
        (%get $rule-id)
        (%null)
        (return)))

   (drop ;; matching rule id
    (%set! $end-match
           (call_indirect $lexical-rules (type $lexical-rule-func)
                          (%get $end-match) (%get $end)
                          (%get $second-rule-id))))

   (if (i32.eq (%get $end-match) (%null))
       (then
        (%get $rule-id)
        (%null)
        (return)))

   (drop ;; matching rule id
    (%set! $end-match
           (call_indirect $lexical-rules (type $lexical-rule-func)
                          (%get $end-match) (%get $end)
                          (%get $third-rule-id))))

   (if (i32.eq (%get $end-match) (%null))
       (then
        (%get $rule-id)
        (%null)
        (return)))

   (drop ;; matching rule id
    (%set! $end-match
           (call_indirect $lexical-rules (type $lexical-rule-func)
                          (%get $end-match) (%get $end)
                          (%get $fourth-rule-id))))

   (if (i32.eq (%get $end-match) (%null))
       (then
        (%get $rule-id)
        (%null)
        (return)))

   (%get $rule-id)
   (%get $end-match))

 (func $lex-match-rules/longest (export "lex-match-rules/longest")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $last-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $current-rule-id i32)
   (local $matching-rule-id i32)
   (local $end-match i32)

   (local $longest-matching-rule-id i32)
   (local $max-end i32)

   (%set! $current-rule-id (%get $first-rule-id))
   (%set! $matching-rule-id (%get $rule-id))
   (%set! $end-match (%null))

   (loop $again

     (%set! $matching-rule-id
            (%set! $end-match
                   (call_indirect $lexical-rules (type $lexical-rule-func)
                                  (%get $text) (%get $end)
                                  (%get $current-rule-id))))

     (if (i32.gt_s (%get $end-match) (%get $max-end))
         (then
          (%set! $longest-matching-rule-id (%get $matching-rule-id))
          (%set! $max-end (%get $end-match))))

     (if (i32.lt_u (%get $current-rule-id) (%get $last-rule-id))
         (then
          (%set! $current-rule-id (i32.add (i32.const 1) (%get $current-rule-id)))
          (br $again))))

   (%get $longest-matching-rule-id)
   (%get $max-end))

 (func $lex-match-rules/longest-of-2 (export "lex-match-rules/longest-of-2")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $matching-rule-id i32)
   (local $end-match i32)

   (local $longest-matching-rule-id i32)
   (local $max-end i32)

   (%set! $matching-rule-id (%get $rule-id))
   (%set! $end-match (%null))

   (%set! $longest-matching-rule-id (%get $rule-id))
   (%set! $max-end (i32.const -1))

   (%set! $matching-rule-id
          (%set! $end-match
                 (call_indirect $lexical-rules (type $lexical-rule-func)
                                (%get $text) (%get $end)
                                (%get $first-rule-id))))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $longest-matching-rule-id (%get $matching-rule-id))
        (%set! $max-end (%get $end-match))))

   (%set! $matching-rule-id
          (%set! $end-match
                 (call_indirect $lexical-rules (type $lexical-rule-func)
                                (%get $text) (%get $end)
                                (%get $second-rule-id))))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $longest-matching-rule-id (%get $matching-rule-id))
        (%set! $max-end (%get $end-match))))

   (%get $longest-matching-rule-id)
   (%get $max-end))

 (func $lex-match-rules/longest-of-3 (export "lex-match-rules/longest-of-3")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $third-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $matching-rule-id i32)
   (local $end-match i32)

   (local $longest-matching-rule-id i32)
   (local $max-end i32)

   (%set! $matching-rule-id (%get $rule-id))
   (%set! $end-match (%null))

   (%set! $longest-matching-rule-id (%get $rule-id))
   (%set! $max-end (i32.const -1))

   (%set! $matching-rule-id
          (%set! $end-match
                 (call_indirect $lexical-rules (type $lexical-rule-func)
                                (%get $text) (%get $end)
                                (%get $first-rule-id))))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $longest-matching-rule-id (%get $matching-rule-id))
        (%set! $max-end (%get $end-match))))

   (%set! $matching-rule-id
          (%set! $end-match
                 (call_indirect $lexical-rules (type $lexical-rule-func)
                                (%get $text) (%get $end)
                                (%get $second-rule-id))))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $longest-matching-rule-id (%get $matching-rule-id))
        (%set! $max-end (%get $end-match))))

   (%set! $matching-rule-id
          (%set! $end-match
                 (call_indirect $lexical-rules (type $lexical-rule-func)
                                (%get $text) (%get $end)
                                (%get $third-rule-id))))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $longest-matching-rule-id (%get $matching-rule-id))
        (%set! $max-end (%get $end-match))))

   (%get $longest-matching-rule-id)
   (%get $max-end))

 (func $lex-match-rules/longest-of-4 (export "lex-match-rules/longest-of-4")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $third-rule-id i32)
   (param $fourth-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $matching-rule-id i32)
   (local $end-match i32)

   (local $longest-matching-rule-id i32)
   (local $max-end i32)

   (%set! $matching-rule-id (%get $rule-id))
   (%set! $end-match (%null))

   (%set! $longest-matching-rule-id (%get $rule-id))
   (%set! $max-end (i32.const -1))

   (%set! $matching-rule-id
          (%set! $end-match
                 (call_indirect $lexical-rules (type $lexical-rule-func)
                                (%get $text) (%get $end)
                                (%get $first-rule-id))))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $longest-matching-rule-id (%get $matching-rule-id))
        (%set! $max-end (%get $end-match))))

   (%set! $matching-rule-id
          (%set! $end-match
                 (call_indirect $lexical-rules (type $lexical-rule-func)
                                (%get $text) (%get $end)
                                (%get $second-rule-id))))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $longest-matching-rule-id (%get $matching-rule-id))
        (%set! $max-end (%get $end-match))))

   (%set! $matching-rule-id
          (%set! $end-match
                 (call_indirect $lexical-rules (type $lexical-rule-func)
                                (%get $text) (%get $end)
                                (%get $third-rule-id))))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $longest-matching-rule-id (%get $matching-rule-id))
        (%set! $max-end (%get $end-match))))

   (%set! $matching-rule-id
          (%set! $end-match
                 (call_indirect $lexical-rules (type $lexical-rule-func)
                                (%get $text) (%get $end)
                                (%get $fourth-rule-id))))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $longest-matching-rule-id (%get $matching-rule-id))
        (%set! $max-end (%get $end-match))))

   (%get $longest-matching-rule-id)
   (%get $max-end))

 (func $lex-match-rules/longest-unordered-sequence-of-2 (export "lex-match-rules/longest-unordered-sequence-of-2")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $max-end i32)

   (%set! $max-end (i32.const -1))

   (drop ;; matching rule id
    (%set! $end-match
           (call $lex-match-rules/sequence-of-2
                 (%get $rule-id)
                 (%get $first-rule-id)
                 (%get $second-rule-id)
                 (%get $text)
                 (%get $end))))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $max-end (%get $end-match))))

   (drop ;; matching rule id
    (%set! $end-match
           (call $lex-match-rules/sequence-of-2
                 (%get $rule-id)
                 (%get $second-rule-id)
                 (%get $first-rule-id)
                 (%get $text)
                 (%get $end))))

   (if (i32.gt_s (%get $end-match) (%get $max-end))
       (then
        (%set! $max-end (%get $end-match))))

   (%get $rule-id)
   (%get $max-end))

 (func $lex-match-until-rule (export "lex-match-until-rule")
   (param $rule-id i32)
   (param $end-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)

   (local $current i32)
   (%set! $current (%get $text))

   (loop $again
     (drop ;; matching rule id
      (%set! $end-match
             (call_indirect $lexical-rules (type $lexical-rule-func)
                            (%get $current) (%get $end)
                            (%get $end-rule-id))))

     (if (i32.and
          (i32.lt_u (%get $current) (%get $end))
          (i32.eq (%null) (%get $end-match)))
         (then
          (%set! $current (i32.add (i32.const 1) (%get $current)))
          (br $again))))

   (%get $rule-id)
   (%get $current))

 (func $lex-token-relabel (export "lex-token-relabel")
   (param $new-rule-id i32)
   (param $rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)

   (drop ;; matching rule id
    (%set! $end-match
           (call_indirect $lexical-rules (type $lexical-rule-func)
                          (%get $text) (%get $end)
                          (%get $rule-id))))

   (%get $new-rule-id)
   (%get $end-match)))

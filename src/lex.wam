(module

 ;; todo: write get-string-char (incl reserving 16B at end of block)
 (import "strings" "get-string-char" (func $get-string-char (param i32) (result i32)))

 (include "./ascii.wam")
 (include "./globals.wam")

 (type $lexical-rule-func (func (param i32 i32) (result i32 i32)))
 (table $lexical-rules 200 funcref) ;; todo export

 (macro %get-char
   (expr ,addr)
   ($get-string-char ,addr))

 (func $ascii-lower (export "ascii-lower")
   (param $x i32)

   (result i32)

   (if (result i32)
       (i32.and (i32.ge_u $x _char-A)
                (i32.le_u $x _char-Z))
     (then
      (i32.add $x (i32.const 0x20)))
     (else
      $x)))

 (func $char-eq/ascii-ci (export "char-eq/ascii-ci")
   (param $x i32)
   (param $y i32)

   (result i32)

   (i32.or (i32.eq $x $y)
           (i32.eq ($ascii-lower $x ($ascii-lower $y)))))

 (func $lex-match-empty (export "lex-match-empty")
   (param $rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   $rule-id
   $text)

 (func $lex-match-any-char (export "lex-match-any-char")
   (param $rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   $rule-id
   (if (result i32) (i32.eq $text $end)
     (then
      _null)
     (else
      (i32.add (i32.const 1) $text)))) ;; todo unicode

 (func $lex-match-char/ascii (export "lex-match-char/ascii")
   (param $rule-id i32)
   (param $char i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $c i32)

   (if (i32.eq $text $end)
       (then
        $rule-id
        (return _null)))

   (set! $c (%get-char $text))

   (if (result i32 i32) (i32.eq $char $c)
     (then
      $rule-id
      (i32.add (i32.const 1) $text)) ;; todo unicode
     (else
      $rule-id
      _null)))

 (func $lex-match-char/ascii-ci (export "lex-match-char/ascii-ci")
   (param $rule-id i32)
   (param $char i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $c i32)

   (if (i32.eq $text $end)
       (then
        $rule-id
        (return _null)))

   (set! $c (%get-char $text))

   (if (result i32 i32) ($char-eq/ascii-ci $char $c)
     (then
      $rule-id
      (i32.add (i32.const 1) $text)) ;; todo unicode
     (else
      $rule-id
      _null)))

 (func $lex-match-char-complement/ascii/set-of-2 (export "lex-match-char-complement/ascii/set-of-2")
   (param $rule-id i32)
   (param $first-char i32)
   (param $second-char i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $c i32)

   (if (i32.eq $text $end)
       (then
        $rule-id
        (return _null)))

   (set! $c (%get-char $text))

   (if (result i32 i32)
       (i32.and (i32.ne $first-char $c) (i32.ne $second-char $c))
     (then
      $rule-id
      (i32.add (i32.const 1) $text)) ;; todo unicode
     (else
      $rule-id
      _null)))

 (func $lex-match-char-range/ascii (export "lex-match-char-range/ascii")
   (param $rule-id i32)
   (param $min-char i32)
   (param $max-char i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $c i32)

   (if (i32.eq $text $end)
       (then
        $rule-id
        (return _null)))

   (set! $c (%get-char $text))

   (if (result i32 i32)
       (i32.and (i32.ge_u $c $min-char) (i32.le_u $c $max-char))
     (then
      $rule-id
      (i32.add (i32.const 1) $text)) ;; todo unicode
     (else
      $rule-id
      _null)))

 (func $match-charset (export "match-charset")
   ;; todo move to strings
   ;; todo static strings
   (param $str i32)
   (param $length i32)
   (param $text i32)
   (param $end i32)

   (result i32)

   (local $c i32)
   (local $s i32)
   (local $s-end i32)

   (if (i32.eq $text $end)
       (then
        (return _null)))

   (set! $c (%get-char $text))

   (set! $s $str)
   (set! $s-end (i32.add $s $length))

   (loop $again
     (if (i32.lt_u $s $s-end)
         (then
          (if (i32.eq $c (%get-char $s))
              (then
               (i32.add (i32.const 1) $text) ;; todo unicode
               (return))
            (else
             (set! $s (i32.add $s (i32.const 1)))
             (br $again))))))

   _null)

 (func $lex-match-charset (export "lex-match-charset")
   (param $rule-id i32)
   (param $str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   $rule-id
   ($match-charset (i32.add (i32.const 1) $str) (%get-char $str) $text $end))

 (func $match-static-string (export "match-static-string")
   ;; todo move to strings
   ;; todo static strings
   (param $str i32)
   (param $length i32)
   (param $text i32)
   (param $end i32)

   (result i32)

   (local $length i32)
   (local $s i32)
   (local $s-end i32)
   (local $t i32)

   (if (i32.gt_u $length (i32.sub $end $text))
       (then
        (return _null)))

   (set! $s $str)
   (set! $s-end (i32.add $s $length))

   (set! $t $text)

   (loop $again

     (if (i32.lt_u $s $s-end)
         (then
          (if (i32.eq
               (%get-char $s)
               (%get-char $t))
              (then
               (set! $s (i32.add $s (i32.const 1)))
               (set! $t (i32.add $t (i32.const 1)))
               (br $again))
            (else
             (set! $t _null))))))

   $t)

 (func $lex-match-static-string (export "lex-match-static-string")
   (param $rule-id i32)
   (param $str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   $rule-id
   ($match-static-string (i32.add (i32.const 1) $str) (%get-char $str) $text $end))

 (func $match-static-string/ascii-ci (export "match-static-string/ascii-ci")
   ;; todo move to strings
   ;; todo static strings
   (param $str i32)
   (param $length i32)
   (param $text i32)
   (param $end i32)

   (result i32)

   (local $s i32)
   (local $s-end i32)
   (local $t i32)

   (if (i32.gt_u $length (i32.sub $end $text))
       (then
        (return _null)))

   (set! $s $str)
   (set! $s-end (i32.add $s $length))

   (set! $t $text)

   (loop $again

     (if (i32.lt_u $s $s-end)
         (then
          (if ($char-eq/ascii-ci (%get-char $s) (%get-char $t))
              (then
               (set! $s (i32.add $s (i32.const 1)))
               (set! $t (i32.add $t (i32.const 1)))
               (br $again))
            (else
             (set! $t _null))))))

   $t)

 (func $lex-match-static-string/ascii-ci (export "lex-match-static-string/ascii-ci")
   (param $rule-id i32)
   (param $str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   $rule-id
   ($match-static-string/ascii-ci (i32.add (i32.const 1) $str) (%get-char $str) $text $end))

 (func $lex-match-static-strings/longest-of-2 (export "lex-match-static-strings/longest-of-2")
   (param $rule-id i32)
   (param $first-str i32)
   (param $second-str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $max-end i32)

   (set! $max-end (i32.const -1))

   (set! $end-match
         ($match-static-string (i32.add (i32.const 1) $first-str)
                               (%get-char $first-str)
                               $text
                               $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-static-string (i32.add (i32.const 1) $second-str)
                               (%get-char $second-str)
                               $text
                               $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   $rule-id
   $max-end)

 (func $lex-match-static-strings/ascii-ci/longest-of-2 (export "lex-match-static-strings/ascii-ci/longest-of-2")
   (param $rule-id i32)
   (param $first-str i32)
   (param $second-str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $max-end i32)

   (set! $max-end (i32.const -1))

   (set! $end-match
         ($match-static-string/ascii-ci (i32.add (i32.const 1) $first-str)
                                        (%get-char $first-str)
                                        $text
                                        $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-static-string/ascii-ci (i32.add (i32.const 1) $second-str)
                                        (%get-char $second-str)
                                        $text
                                        $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   $rule-id
   $max-end)

 (func $lex-match-static-strings/longest-of-3 (export "lex-match-static-strings/longest-of-3")
   (param $rule-id i32)
   (param $first-str i32)
   (param $second-str i32)
   (param $third-str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $max-end i32)

   (set! $max-end (i32.const -1))

   (set! $end-match
         ($match-static-string (i32.add (i32.const 1) $first-str)
                               (%get-char $first-str)
                               $text
                               $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-static-string (i32.add (i32.const 1) $second-str)
                               (%get-char $second-str)
                               $text
                               $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-static-string (i32.add (i32.const 1) $third-str)
                               (%get-char $third-str)
                               $text
                               $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   $rule-id
   $max-end)

 (func $lex-match-static-strings/ascii-ci/longest-of-3 (export "lex-match-static-strings/ascii-ci/longest-of-3")
   (param $rule-id i32)
   (param $first-str i32)
   (param $second-str i32)
   (param $third-str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $max-end i32)

   (set! $max-end (i32.const -1))

   (set! $end-match
         ($match-static-string/ascii-ci (i32.add (i32.const 1) $first-str)
                                        (%get-char $first-str)
                                        $text
                                        $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-static-string/ascii-ci (i32.add (i32.const 1) $second-str)
                                        (%get-char $second-str)
                                        $text
                                        $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-static-string/ascii-ci (i32.add (i32.const 1) $third-str)
                                        (%get-char $third-str)
                                        $text
                                        $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   $rule-id
   $max-end)

 (func $lex-match-static-strings/longest-of-4 (export "lex-match-static-strings/longest-of-4")
   (param $rule-id i32)
   (param $first-str i32)
   (param $second-str i32)
   (param $third-str i32)
   (param $fourth-str i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $max-end i32)

   (set! $max-end (i32.const -1))

   (set! $end-match
         ($match-static-string (i32.add (i32.const 1) $first-str)
                               (%get-char $first-str)
                               $text
                               $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-static-string (i32.add (i32.const 1) $second-str)
                               (%get-char $second-str)
                               $text
                               $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-static-string (i32.add (i32.const 1) $third-str)
                               (%get-char $third-str)
                               $text
                               $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (set! $end-match
         ($match-static-string (i32.add (i32.const 1) $fourth-str)
                               (%get-char $fourth-str)
                               $text
                               $end))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   $rule-id
   $max-end)

 (func $lex-match-rule? (export "lex-match-rule?")
   (param $rule-id i32)
   (param $target-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)

   (drop  ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func) $text $end $target-rule-id)))

   $rule-id
   (if (result i32) (i32.eq $end-match _null)
     (then
      $text)
     (else
      $end-match)))

 (func $lex-match-rule/zero-or-more (export "lex-match-rule/zero-or-more")
   (param $rule-id i32)
   (param $target-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $next-end i32)

   (set! $end-match $text)

   (loop $again

     (drop  ;; matching rule id
      (set! $next-end
            (call_indirect $lexical-rules (type $lexical-rule-func)
                           $end-match $end
                           $target-rule-id)))

     (if (i32.gt_s $next-end _null)
         (then
          (set! $end-match $next-end)
          (br $again))))

   $rule-id
   $end-match)

 (func $lex-match-rule/one-or-more (export "lex-match-rule/one-or-more")
   (param $rule-id i32)
   (param $target-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $next-end i32)

   (drop ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func)
                         $text $end
                         $target-rule-id)))

   (if (i32.eq $end-match _null)
       (then
        $rule-id
        _null
        (return)))

   (loop $again

     (drop ;; matching rule id
      (set! $next-end
            (call_indirect $lexical-rules (type $lexical-rule-func)
                           $end-match $end
                           $target-rule-id)))

     (if (i32.ne $next-end _null)
         (then
          (set! $end-match $next-end)
          (br $again))))

   $rule-id
   $end-match)

 (func $lex-match-rules/sequence (export "lex-match-rules/sequence")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $last-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $current-rule-id i32)
   (local $end-match i32)

   (set! $current-rule-id $first-rule-id)
   (set! $end-match $text)

   (loop $again




     (drop ;; matching rule id
      (set! $end-match
            (call_indirect $lexical-rules (type $lexical-rule-func)
                           $end-match $end
                           $current-rule-id)))

     (if (i32.and
          (i32.gt_s $end-match _null)
          (i32.lt_u $current-rule-id $last-rule-id))
         (then
          (set! $current-rule-id (i32.add (i32.const 1) $current-rule-id))
          (br $again))))

   $rule-id
   $end-match)

 (func $lex-match-rules/sequence-of-2 (export "lex-match-rules/sequence-of-2")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)

   (drop  ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func) $text $end $first-rule-id)))

   (if (i32.eq $end-match _null)
       (then
        $rule-id
        _null
        (return)))

   (drop  ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func)
                         $end-match $end
                         $second-rule-id)))

   (if (i32.eq $end-match _null)
       (then
        $rule-id
        _null
        (return)))

   $rule-id
   $end-match)

 (func $lex-match-rules/sequence-of-3 (export "lex-match-rules/sequence-of-3")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $third-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)

   (drop ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func)
                         $text $end
                         $first-rule-id)))

   (if (i32.eq $end-match _null)
       (then
        $rule-id
        _null
        (return)))

   (drop ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func)
                         $end-match $end
                         $second-rule-id)))

   (if (i32.eq $end-match _null)
       (then
        $rule-id
        _null
        (return)))

   (drop ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func)
                         $end-match $end
                         $third-rule-id)))

   (if (i32.eq $end-match _null)
       (then
        $rule-id
        _null
        (return)))

   $rule-id
   $end-match)

 (func $lex-match-rules/sequence-of-4 (export "lex-match-rules/sequence-of-4")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $third-rule-id i32)
   (param $fourth-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)

   (drop ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func)
                         $text $end
                         $first-rule-id)))

   (if (i32.eq $end-match _null)
       (then
        $rule-id
        _null
        (return)))

   (drop ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func)
                         $end-match $end
                         $second-rule-id)))

   (if (i32.eq $end-match _null)
       (then
        $rule-id
        _null
        (return)))

   (drop ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func)
                         $end-match $end
                         $third-rule-id)))

   (if (i32.eq $end-match _null)
       (then
        $rule-id
        _null
        (return)))

   (drop ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func)
                         $end-match $end
                         $fourth-rule-id)))

   (if (i32.eq $end-match _null)
       (then
        $rule-id
        _null
        (return)))

   $rule-id
   $end-match)

 (func $lex-match-rules/longest (export "lex-match-rules/longest")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $last-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $current-rule-id i32)
   (local $matching-rule-id i32)
   (local $end-match i32)

   (local $longest-matching-rule-id i32)
   (local $max-end i32)

   (set! $current-rule-id $first-rule-id)
   (set! $matching-rule-id $rule-id)
   (set! $end-match _null)

   (loop $again

     (set! $matching-rule-id
           (set! $end-match
                 (call_indirect $lexical-rules (type $lexical-rule-func)
                                $text $end
                                $current-rule-id)))

     (if (i32.gt_s $end-match $max-end)
         (then
          (set! $longest-matching-rule-id $matching-rule-id)
          (set! $max-end $end-match)))

     (if (i32.lt_u $current-rule-id $last-rule-id)
         (then
          (set! $current-rule-id (i32.add (i32.const 1) $current-rule-id))
          (br $again))))

   $longest-matching-rule-id
   $max-end)

 (func $lex-match-rules/longest-of-2 (export "lex-match-rules/longest-of-2")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $matching-rule-id i32)
   (local $end-match i32)

   (local $longest-matching-rule-id i32)
   (local $max-end i32)

   (set! $matching-rule-id $rule-id)
   (set! $end-match _null)

   (set! $longest-matching-rule-id $rule-id)
   (set! $max-end (i32.const -1))

   (set! $matching-rule-id
         (set! $end-match
               (call_indirect $lexical-rules (type $lexical-rule-func)
                              $text $end
                              $first-rule-id)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $longest-matching-rule-id $matching-rule-id)
        (set! $max-end $end-match)))

   (set! $matching-rule-id
         (set! $end-match
               (call_indirect $lexical-rules (type $lexical-rule-func)
                              $text $end
                              $second-rule-id)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $longest-matching-rule-id $matching-rule-id)
        (set! $max-end $end-match)))

   $longest-matching-rule-id
   $max-end)

 (func $lex-match-rules/longest-of-3 (export "lex-match-rules/longest-of-3")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $third-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $matching-rule-id i32)
   (local $end-match i32)

   (local $longest-matching-rule-id i32)
   (local $max-end i32)

   (set! $matching-rule-id $rule-id)
   (set! $end-match _null)

   (set! $longest-matching-rule-id $rule-id)
   (set! $max-end (i32.const -1))

   (set! $matching-rule-id
         (set! $end-match
               (call_indirect $lexical-rules (type $lexical-rule-func)
                              $text $end
                              $first-rule-id)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $longest-matching-rule-id $matching-rule-id)
        (set! $max-end $end-match)))

   (set! $matching-rule-id
         (set! $end-match
               (call_indirect $lexical-rules (type $lexical-rule-func)
                              $text $end
                              $second-rule-id)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $longest-matching-rule-id $matching-rule-id)
        (set! $max-end $end-match)))

   (set! $matching-rule-id
         (set! $end-match
               (call_indirect $lexical-rules (type $lexical-rule-func)
                              $text $end
                              $third-rule-id)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $longest-matching-rule-id $matching-rule-id)
        (set! $max-end $end-match)))

   $longest-matching-rule-id
   $max-end)

 (func $lex-match-rules/longest-of-4 (export "lex-match-rules/longest-of-4")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $third-rule-id i32)
   (param $fourth-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $matching-rule-id i32)
   (local $end-match i32)

   (local $longest-matching-rule-id i32)
   (local $max-end i32)

   (set! $matching-rule-id $rule-id)
   (set! $end-match _null)

   (set! $longest-matching-rule-id $rule-id)
   (set! $max-end (i32.const -1))

   (set! $matching-rule-id
         (set! $end-match
               (call_indirect $lexical-rules (type $lexical-rule-func)
                              $text $end
                              $first-rule-id)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $longest-matching-rule-id $matching-rule-id)
        (set! $max-end $end-match)))

   (set! $matching-rule-id
         (set! $end-match
               (call_indirect $lexical-rules (type $lexical-rule-func)
                              $text $end
                              $second-rule-id)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $longest-matching-rule-id $matching-rule-id)
        (set! $max-end $end-match)))

   (set! $matching-rule-id
         (set! $end-match
               (call_indirect $lexical-rules (type $lexical-rule-func)
                              $text $end
                              $third-rule-id)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $longest-matching-rule-id $matching-rule-id)
        (set! $max-end $end-match)))

   (set! $matching-rule-id
         (set! $end-match
               (call_indirect $lexical-rules (type $lexical-rule-func)
                              $text $end
                              $fourth-rule-id)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $longest-matching-rule-id $matching-rule-id)
        (set! $max-end $end-match)))

   $longest-matching-rule-id
   $max-end)

 (func $lex-match-rules/longest-unordered-sequence-of-2 (export "lex-match-rules/longest-unordered-sequence-of-2")
   (param $rule-id i32)
   (param $first-rule-id i32)
   (param $second-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)
   (local $max-end i32)

   (set! $max-end (i32.const -1))

   (drop ;; matching rule id
    (set! $end-match
          ($lex-match-rules/sequence-of-2 $rule-id
                                          $first-rule-id
                                          $second-rule-id
                                          $text
                                          $end)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   (drop ;; matching rule id
    (set! $end-match
          ($lex-match-rules/sequence-of-2 $rule-id
                                          $second-rule-id
                                          $first-rule-id
                                          $text
                                          $end)))

   (if (i32.gt_s $end-match $max-end)
       (then
        (set! $max-end $end-match)))

   $rule-id
   $max-end)

 (func $lex-match-until-rule (export "lex-match-until-rule")
   (param $rule-id i32)
   (param $end-rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)

   (local $current i32)
   (set! $current $text)

   (loop $again
     (drop ;; matching rule id
      (set! $end-match
            (call_indirect $lexical-rules (type $lexical-rule-func)
                           $current $end
                           $end-rule-id)))

     (if (i32.and (i32.lt_u $current $end) (i32.eq _null $end-match))
         (then
          (set! $current (i32.add (i32.const 1) $current))
          (br $again))))

   $rule-id
   $current)

 (func $lex-token-relabel (export "lex-token-relabel")
   (param $new-rule-id i32)
   (param $rule-id i32)
   (param $text i32)
   (param $end i32)

   (result i32 i32)

   (local $end-match i32)

   (drop ;; matching rule id
    (set! $end-match
          (call_indirect $lexical-rules (type $lexical-rule-func) $text $end $rule-id)))

   $new-rule-id
   $end-match))

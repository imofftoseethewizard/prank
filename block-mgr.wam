;; # Block Allocation Manager
;;
;; This module manages allocation and deallocation of variable-length blocks of
;; memory.  It depends on the values and pairs modules.  It is intended to be
;; used by the bytevectors, numbers, strings, symbols, and vectors modules, and
;; by the garbage collector for its internal indexes.
;;
;;
;; ## Design
;;
;; The simplest memory management policy is static allocation, common on small,
;; embedded devices with limited RAM and functionality.  FORTH uses a slightly
;; more advanced allocation scheme with just a single "dictionary" pointer that
;; increases with each allocation.  One could think of this as static
;; allocation, but incrementally defined.  Beyond that, things get complex
;; quickly.  To support reuse of memory that is no longer needed, we need to
;; track deallocated blocks, and these could be stored in a list, either
;; implemented as a linked list or in a dynamic array.  Typcial distributions of
;; block sizes lead to fragmentation and a loss of memory efficiency.  (There
;; are special cases where this does not apply, such as when all blocks have the
;; same size, or when they have varying sizes, but form a power law
;; distribution, etc).  Further if the number of free blocks grows large, then
;; searching through the list of free blocks for one of a matching size becomes
;; increasingly expensive, or we could maintain a sorted array, but then
;; allocation and free become expensive.  The free list could be recast as a
;; heap, but then we aren't guaranteed to find a block of the correct size, so
;; to maintain computational efficiency we need to allow blocks to be split.
;; Splitting blocks just makes the fragmentation problem worse.  We could
;; coalesce adjacent free blocks, but then we need an ordered data structure
;; again, and we're back to having a free list.  But now the free list needs to
;; be careful not to corrupt the heap when coalescing free blocks.  That still
;; leaves the possibility of small bits of memory lost between larger blocks
;; which have a long lifetime.  To handle that, we need to be able to relocate
;; allocated blocks, but that requires an ordered list of all blocks -- both
;; free and allocated -- and indirection of block id and block storage address.
;; So that's what we have here: indirection of storage address, an ordered list
;; of blocks, an ordered list of free blocks, and a heap of free blocks.
;; Allocation and deallocation are O(log(#free)).  Defragmentation is
;; incremental.  Memory management policies can be set to optimize for memory
;; efficiency, computational efficiency, or low run-time variance.
;;
;;
;; ## Data Representation
;;
;; A block is a pair. ( addr . length )
;;
;; A block ref is a pair in which the car is a block. ( block . * )
;;
;; The block list is a linked list of block refs, ( block1 . ( block2 . ... ) ),
;; where block2 addr = block1 addr + block1 length.
;;
;; A free entry is a pair in which the car is a block ref. ( block-ref . * )
;;
;; The free list is a linked list of free entries, ( free1. ( free 2 . ... ) ),
;; such that free block2 addr >= free block1 addr + free block1 length.
;;
;; A free heap node is a list, ( block left right . free entry ) where left
;; and right are also heap nodes, or null, and where block is lifted out of
;; the referenced free entry to reduce the number of indirections required for
;; heap maintenance.
;;
;; The free heap is a max heap by block size of free heap nodes.
;;
;; A heap node is unused if the address in its block is $null (i32_u -1).
;;
;; A blockset is an index into an array of structures which capture the state of
;; a client's memory.  These structures include pointers to the block list,
;; free list, heap, and various values necessary for managing memory.
;;
;;
;; ## Memory Access
;;
;; The block allocation manager has no direct access to the memory it manages.
;; It has a single memory page to store the state of each client module, and it
;; uses the pairs module for the representing the blocks, block list, free list,
;; and heap.  It needs access to client memory when is attempting to allocate a
;; block larger than any free block in the heap, in which case it uses client
;; proxies memory.size and memory.grow.  It also needs access during
;; defragmentation, when it needs to call a proxy for memory.copy.  Access to
;; these instructions is provided through three tables, one for each of the
;; memory functions mentioned.  The client module provides a client id, which
;; is the index into each of the tables for its proxies for the memory it owns.
;; The clients need to be coordinated to ensure that there are no conflicts.
;; (The client ids are defined in globals.wam.)
;;
;; See $memory-copy-sig, $memory-copy, etc below the import section.
;;
;; Clients need to import these tables and fill their entries before calling any
;; block allocation manager functions.
;;
;;
;; ## Allocation Algorithm
;;
;; Upon receiving an allocation request, the allocator does a little heap
;; maintenance, andh then checks if the top block on the free heap is at least
;; as big as the request.  If it's not big enough, it calls the proxies for
;; memory.size and memory.grow to allocate a new free block big enough to
;; satisfy the request.  New free blocks are always in multiples of whole pages
;; (64KB).  If the free block is exactly the same size as the request, it is
;; removed from the heap and free list and returned to the caller.  Otherwise,
;; the block is split, the heap is updated, and the new block is returned to the
;; caller.
;;
;; Blocks are split from upper memory down.
;;
;; Allocation is done from the largest block because...
;;
;;
;; ## Heap maintenance
;;
;; During defragmentation, free blocks are coalesced.  One free block becomes
;; bigger and another is removed from the block list.  The heap, however, will
;; still have references to these blocks.  There is no efficient way to find
;; these blocks, so they must be marked for future disposal and handled when the
;; heap encounters them.  In order not to corrupt the heap, the sizes of the
;; blocks must remain unchanged.  The solution here is set the address field to
;; -1 to signal that a block is unused.  To coalese two free blocks, the two
;; source blocks are both set to unused and removed from the block list and free
;; list.  A new block is created to replace them and added to the heap.  When a
;; traversal of the heap encounters an entry with an unused block, it sets the
;; block's size field to 0 and sinks it to the bottom.  Later when a new entry
;; is added, if the would-be parent of the entry is unused, then instead of
;; becoming a child, it takes the unused entry's place and the unused entry is
;; deallocated.
;;
;; That leaves the question of when the heap checks for unused nodes Obviously,
;; if the free list and the heap have the same number of items, checking is
;; unnecessary.  It is also obvious that the root needs to be checked before it
;; is returned as a free block.  Perhaps less obvious is that if the heap were
;; half unused items, that would only add one more operation to every full
;; traversal, on average, and most sink/swim operations do not actually fully
;; traverse the heap.  A lot of unused items in the heap is does not incur a
;; large computational penalty, but it does consume pair memory.  On the other
;; hand, keeping the unused items to a minimum would require more computation,
;; so we need a policy parameter and a two sets of heap traversal routines.
;; TODO: When the fraction of unused nodes crosses the policy threshold, heap
;; operations use the set of routines that check for unused nodes during
;; traversals.
;;
;; Adding an node and removing the head from heap both require knowing where
;; the last node of the heap is (or, equivalently) where it should go.
;; Adding an node is straightforward: add it at the appropriate place, and
;; repeatedly swap it with its parent until the heap condition is satisfied, in
;; this case, that the block it references is no smaller than its two children,
;; but no bigger than its parent.  In the case of removing an node, we
;; replace the root with last elemment of the heap, and then swap with its
;; largest child until the heap condition is satisfied.  With an array-based
;; heap, this is
;;
;; Why not implement the heap as an array? Where would it be stored?  .. store
;; the heaps in the blockmgr memory segment expanding heap requires moving
;; others heap node is just a pair address, but would be the free entry,
;; hence size would be caadr adding a free node is possibly proportional to
;; the sum of the sizes of the other heaps. How big are the heaps likely to get?
;; memory use: as pairs, and additional 24 bytes (3 pairs) are required, for the
;; same we'd require 8 bytes in an array, plus a budget for extra stace in the
;; array, say 1/3 more, so 11 bytes on average per heap node.  These would
;; need to be managed such that growth of an array could be amortized.  Noting
;; that this is similar to the service the block manager provides, there is a
;; temptation to attempt to use the block mgr to manage the storage for its own
;; heap, but this would require some delicacy in the event the the heap's storage
;; needs to grow (and move) and the heap is needed to do that.  In particular,
;; the address of any heap node may not remain on the call stack above a
;; call which moves the heap, or must be recalculated after the call completes.
;; A call which inserts an node in the heap can move the heap.  Deallocation
;; and (possibly) reallocation.
;;
;; There is a nearly complete implementation of an array-based heap in the
;; array-heap branch.  This work was abandoned since it was likely to be slower
;; than the pair-based heap for the likely heap sizes.  This is primarily due to
;; ;;
;; Finding the last node of a heap.  In an array-based heap, finding the last
;; node is simple.  With a pair-based heap, it requires a walk from the root.
;; Let h be the root of the heap and let k be the number of nodes in the
;; heap.  If k = 1 then we are done.  Otherwise if k is even let h = left(h),
;; and if k is odd, let h = right(h).  Let k = k >> 1 and repeat.
;;
;; Removing the root from the heap follows the usual process of removing the
;; last node of the heap and sink it from the root.  Deallocate 3 pairs, as
;; identified by their cars: block, left, and right.
;;
;; Removing a block from the free list
;;
;; Adding an node to the heap.
;;
;; Finding Free Blocks
;;
;; (32 - clz(Heap count)) >> 1 levels
;; compute max <= limit
;; check for unused blocks, sink if found

(module

 (import "pairs" "dealloc-pair"   (func $dealloc-pair   (param i32)))
 (import "pairs" "get-pair-caaar" (func $get-pair-caaar (param i32)     (result i32)))
 (import "pairs" "get-pair-caadr" (func $get-pair-caadr (param i32)     (result i32)))
 (import "pairs" "get-pair-caar"  (func $get-pair-caar  (param i32)     (result i32)))
 (import "pairs" "get-pair-cadr"  (func $get-pair-cadr  (param i32)     (result i32)))
 (import "pairs" "get-pair-car"   (func $get-pair-car   (param i32)     (result i32)))
 (import "pairs" "get-pair-cdr"   (func $get-pair-cdr   (param i32)     (result i32)))
 (import "pairs" "make-pair"      (func $make-pair      (param i32 i32) (result i32)))
 (import "pairs" "set-pair-caaar" (func $set-pair-caaar (param i32 i32)))
 (import "pairs" "set-pair-caar"  (func $set-pair-caar  (param i32 i32)))
 (import "pairs" "set-pair-cadr"  (func $set-pair-cadr  (param i32 i32)))
 (import "pairs" "set-pair-car"   (func $set-pair-car   (param i32 i32)))
 (import "pairs" "set-pair-cdr"   (func $set-pair-cdr   (param i32 i32)))
 (import "values" "get-value-tag" (func $get-value-tag  (param i32)     (result i32)))

 (include "./globals.wam")

 ;; Used to store per-client information
 (memory (export "memory") 1)

 (global $heap-node-size-bits (export "heap-node-size-bits") i32 (i32.const 3))
 (global $blockset-size-bits (export "blockset-size-bits") i32 (i32.const 6))
 (global $debug (export "#debug") (mut i32) (i32.const 0))

 ;; Each heap node is 8 bytes, allow 3 nodes per blockset
 (global $per-blockset-heap0-capacity-bytes (export "per-blockset-heap0-capacity-bytes") i32 (i32.const 24))

 ;; 1KB, enough for 128 heap nodes
 (global $initial-heap-size (export "initial-heap-size") i32 (i32.const 0x400))

 (global $blockset-block-count                (export "blockset-block-count")                i32 (i32.const 0x00))
 (global $blockset-block-list                 (export "blockset-block-list")                 i32 (i32.const 0x04))
 (global $blockset-defrag-cursor              (export "blockset-defrag-cursor")              i32 (i32.const 0x08))
 (global $blockset-end-block-ref              (export "blockset-end-block-ref")              i32 (i32.const 0x0c))
 (global $blockset-free-list                  (export "blockset-free-list")                  i32 (i32.const 0x10))
 (global $blockset-free-list-length           (export "blockset-free-list-length")           i32 (i32.const 0x14))
 (global $blockset-free-space                 (export "blockset-free-space")                 i32 (i32.const 0x18))
 (global $blockset-heap-ref                   (export "blockset-heap-ref")                   i32 (i32.const 0x1c))
 (global $blockset-heap-size                  (export "blockset-heap-size")                  i32 (i32.const 0x20))
 (global $blockset-immobile-block-size        (export "blockset-immobile-block-size")        i32 (i32.const 0x24))
 (global $blockset-relocation-size-limit      (export "blockset-relocation-size-limit")      i32 (i32.const 0x28))
 (global $blockset-heap-sweep-cursor      (export "blockset-heap-sweep-cursor")      i32 (i32.const 0x2c))

 (type $memory-copy-sig (func (param i32 i32 i32)))
 (type $memory-grow-sig (func (param i32) (result i32)))
 (type $memory-size-sig (func (result i32)))

 (table $memory-copy (export "memory-copy") 16 funcref)
 (table $memory-grow (export "memory-grow") 16 funcref)
 (table $memory-size (export "memory-size") 16 funcref)

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Module Initialization
 ;;
 ;;

 (start $init-blockset-manager)
 (func $init-blockset-manager (export "init-blockset-manager")
   ;; Bootstrap blockset 0, which manages the blocks which contain the heaps of
   ;; all blocksets (including blockset 0).

   (local $blockset i32)
   (local $free-block i32)
   (local $free-block-addr i32)
   (local $free-block-size i32)
   (local $free-entry i32)
   (local $free-ref i32)
   (local $heap-block i32)
   (local $heap-block-addr i32)
   (local $heap-block-size i32)
   (local $heap-ref i32)

   (table.set $memory-copy (global.get $block-mgr-blockset-id) (ref.func $memory-copy))
   (table.set $memory-grow (global.get $block-mgr-blockset-id) (ref.func $memory-grow))
   (table.set $memory-size (global.get $block-mgr-blockset-id) (ref.func $memory-size))

   (local.set $blockset (call $get-blockset (global.get $block-mgr-blockset-id)))

   (local.set $heap-block-addr (i32.shl (global.get $max-blockset-id)
                                        (global.get $blockset-size-bits)))

   (local.set $heap-block-size (i32.mul (global.get $max-blockset-id)
                                        (global.get $per-blockset-heap0-capacity-bytes)))

   (local.set $free-block-addr (i32.add (local.get $heap-block-addr)
                                        (local.get $heap-block-size)))

   (local.set $free-block-size (i32.sub (global.get $page-size)
                                        (local.get $free-block-addr)))

   (local.set $free-block (call $make-block
                                (local.get $free-block-addr)
                                (local.get $free-block-size)))

   (local.set $free-ref (call $make-block-ref (local.get $free-block) (global.get $null)))

   (local.set $free-entry (call $make-free-entry (local.get $free-ref) (global.get $null)))

   (local.set $heap-block (call $make-block
                                (local.get $heap-block-addr)
                                (local.get $heap-block-size)))

   (local.set $heap-ref (call $make-block-ref (local.get $heap-block) (local.get $free-ref)))

   (call $set-blockset-block-list (local.get $blockset) (local.get $heap-ref))
   (call $incr-blockset-block-count (local.get $blockset))

   (call $set-blockset-block-count      (local.get $blockset) (i32.const 2))
   (call $set-blockset-block-list       (local.get $blockset) (local.get $heap-ref))
   (call $set-blockset-defrag-cursor    (local.get $blockset) (global.get $null))
   (call $set-blockset-end-block-ref    (local.get $blockset) (local.get $free-ref))
   (call $set-blockset-heap-ref         (local.get $blockset) (local.get $heap-ref))
   (call $set-blockset-heap-size        (local.get $blockset) (i32.const 1))
   (call $set-blockset-free-list        (local.get $blockset) (local.get $free-entry))
   (call $set-blockset-free-list-length (local.get $blockset) (i32.const 1))
   (call $set-blockset-free-space       (local.get $blockset) (local.get $free-block-size))

   (call $set-blockset-immobile-block-size (local.get $blockset) (global.get $page-size))
   (call $set-blockset-relocation-size-limit (local.get $blockset) (global.get $page-size))

   (call $set-heap-node-entry (local.get $heap-block-addr) (i32.const 0) (local.get $free-entry)))

 (elem funcref (ref.func $memory-copy))
 (func $memory-copy
   (param $dest-addr i32)
   (param $source-addr i32)
   (param $size i32)
   (memory.copy (local.get $dest-addr)
                (local.get $source-addr)
                (local.get $size)))

 (elem funcref (ref.func $memory-grow))
 (func $memory-grow
   (param $page-count i32)
   (result i32)
   (memory.grow (local.get $page-count)))

 (elem funcref (ref.func $memory-size))
 (func $memory-size
   (result i32)
   (memory.size))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Blockset Initialization
 ;;
 ;;

 (func $init-blockset (export "init-blockset")
   (param $blockset-id i32)
   (param $immobile-block-size i32)
   (param $relocation-size-limit i32)

   (local $blockset i32)
   (local $heap-ref i32)

   (local.set $blockset (call $get-blockset (local.get $blockset-id)))

   (call $set-blockset-immobile-block-size
         (local.get $blockset)
         (local.get $immobile-block-size))

   (call $set-blockset-relocation-size-limit
         (local.get $blockset)
         (local.get $relocation-size-limit))

   (local.set $heap-ref (call $alloc-block
                              (global.get $block-mgr-blockset-id)
                              (global.get $initial-heap-size)))

   (call $set-blockset-block-count      (local.get $blockset) (i32.const 0))
   (call $set-blockset-block-list       (local.get $blockset) (global.get $null))
   (call $set-blockset-defrag-cursor    (local.get $blockset) (global.get $null))
   (call $set-blockset-end-block-ref    (local.get $blockset) (global.get $null))
   (call $set-blockset-heap-ref         (local.get $blockset) (local.get $heap-ref))
   (call $set-blockset-heap-size        (local.get $blockset) (i32.const 0))
   (call $set-blockset-free-list        (local.get $blockset) (global.get $null))
   (call $set-blockset-free-list-length (local.get $blockset) (i32.const 0))
   (call $set-blockset-free-space       (local.get $blockset) (i32.const 0)))

 (func $get-blockset (export "get-blockset")
   (param $blockset-id i32)
   (result i32)
   (i32.shl (local.get $blockset-id) (global.get $blockset-size-bits)))

 (func $get-blockset-id (export "get-blockset-id")
   (param $blockset i32)
   (result i32)
   (i32.shr_u (local.get $blockset) (global.get $blockset-size-bits)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Blockset Accessors
 ;;

 (func $get-blockset-block-count (export "get-blockset-block-count")
   (param $blockset i32)
   (result i32)
   (i32.load (i32.add (local.get $blockset)
                      (global.get $blockset-block-count))))

 (func $get-blockset-block-list (export "get-blockset-block-list")
   (param $blockset i32)
   (result i32)
   (i32.load (i32.add (local.get $blockset)
                      (global.get $blockset-block-list))))

 (func $get-blockset-defrag-cursor (export "get-blockset-defrag-cursor")
   (param $blockset i32)
   (result i32)
   (i32.load (i32.add (local.get $blockset)
                      (global.get $blockset-defrag-cursor))))

 (func $get-blockset-end-block-ref (export "get-blockset-end-block-ref")
   (param $blockset i32)
   (result i32)
   (i32.load (i32.add (local.get $blockset)
                      (global.get $blockset-end-block-ref))))

 (func $get-blockset-heap (export "get-blockset-heap")
   (param $blockset i32)
   (result i32)
   (call $get-block-ref-addr (call $get-blockset-heap-ref (local.get $blockset))))

 (func $get-blockset-heap-ref (export "get-blockset-heap-ref")
   (param $blockset i32)
   (result i32)
   (i32.load (i32.add (local.get $blockset)
                      (global.get $blockset-heap-ref))))

 (func $get-blockset-heap-sweep-cursor (export "get-blockset-heap-sweep-cursor")
   (param $blockset i32)
   (result i32)
   (i32.load (i32.add (local.get $blockset)
                      (global.get $blockset-heap-sweep-cursor))))

 (func $get-blockset-heap-size (export "get-blockset-heap-size")
   (param $blockset i32)
   (result i32)
   (i32.load (i32.add (local.get $blockset)
                      (global.get $blockset-heap-size))))

 (func $get-blockset-free-list (export "get-blockset-free-list")
   (param $blockset i32)
   (result i32)
   (i32.load (i32.add (local.get $blockset)
                      (global.get $blockset-free-list))))

 (func $get-blockset-free-list-length (export "get-blockset-free-list-length")
   (param $blockset i32)
   (result i32)
   (i32.load (i32.add (local.get $blockset)
                      (global.get $blockset-free-list-length))))

 (func $get-blockset-immobile-block-size (export "get-blockset-immobile-block-size")
   (param $blockset i32)
   (result i32)
   (i32.load (i32.add (local.get $blockset)
                      (global.get $blockset-immobile-block-size))))

 (func $get-blockset-relocation-size-limit (export "get-blockset-relocation-size-limit")
   (param $blockset i32)
   (result i32)
   (i32.load (i32.add (local.get $blockset)
                      (global.get $blockset-relocation-size-limit))))

 (func $get-blockset-free-space (export "get-blockset-free-space")
   (param $blockset i32)
   (result i32)
   (i32.load (i32.add (local.get $blockset)
                      (global.get $blockset-free-space))))

 (func $set-blockset-block-count (export "set-blockset-block-count")
   (param $blockset i32)
   (param $block-count i32)
   (i32.store (i32.add (local.get $blockset)
                       (global.get $blockset-block-count))
              (local.get $block-count)))

 (func $set-blockset-block-list (export "set-blockset-block-list")
   (param $blockset i32)
   (param $block-list i32)
   (i32.store (i32.add (local.get $blockset)
                       (global.get $blockset-block-list))
              (local.get $block-list)))

 (func $set-blockset-defrag-cursor (export "set-blockset-defrag-cursor")
   (param $blockset i32)
   (param $defrag-cursor i32)
   (i32.store (i32.add (local.get $blockset)
                       (global.get $blockset-defrag-cursor))
              (local.get $defrag-cursor)))

 (func $set-blockset-end-block-ref (export "set-blockset-end-block-ref")
   (param $blockset i32)
   (param $end-block-ref i32)
   (i32.store (i32.add (local.get $blockset)
                       (global.get $blockset-end-block-ref))
              (local.get $end-block-ref)))

 (func $set-blockset-heap-ref (export "set-blockset-heap-ref")
   (param $blockset i32)
   (param $heap-ref i32)
   (i32.store (i32.add (local.get $blockset)
                       (global.get $blockset-heap-ref))
              (local.get $heap-ref)))

 (func $set-blockset-heap-sweep-cursor (export "set-blockset-heap-sweep-cursor")
   (param $blockset i32)
   (param $node-idx i32)
   (i32.store (i32.add (local.get $blockset)
                       (global.get $blockset-heap-sweep-cursor))
              (local.get $node-idx)))

 (func $set-blockset-heap-size (export "set-blockset-heap-size")
   (param $blockset i32)
   (param $heap-size i32)
   (i32.store (i32.add (local.get $blockset)
                       (global.get $blockset-heap-size))
              (local.get $heap-size)))

 (func $set-blockset-free-list (export "set-blockset-free-list")
   (param $blockset i32)
   (param $free-list i32)
   (i32.store (i32.add (local.get $blockset)
                       (global.get $blockset-free-list))
              (local.get $free-list)))

 (func $set-blockset-free-list-length (export "set-blockset-free-list-length")
   (param $blockset i32)
   (param $free-list-length i32)
   (i32.store (i32.add (local.get $blockset)
                       (global.get $blockset-free-list-length))
              (local.get $free-list-length)))

 (func $set-blockset-immobile-block-size (export "set-blockset-immobile-block-size")
   (param $blockset i32)
   (param $immobile-block-size i32)
   (i32.store (i32.add (local.get $blockset)
                       (global.get $blockset-immobile-block-size))
              (local.get $immobile-block-size)))

 (func $set-blockset-relocation-size-limit (export "set-blockset-relocation-size-limit")
   (param $blockset i32)
   (param $relocation-size-limit i32)
   (i32.store (i32.add (local.get $blockset)
                       (global.get $blockset-relocation-size-limit))
              (local.get $relocation-size-limit)))

 (func $set-blockset-free-space (export "set-blockset-free-space")
   (param $blockset i32)
   (param $free-space i32)
   (i32.store (i32.add (local.get $blockset)
                       (global.get $blockset-free-space))
              (local.get $free-space)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Blockset Utilities
 ;;

 (func $decr-blockset-block-count (export "decr-blockset-block-count")
   (param $blockset i32)
   (local $addr i32)
   (local.set $addr (i32.add (local.get $blockset) (global.get $blockset-block-count)))
   (i32.store (local.get $addr) (i32.sub (i32.load (local.get $addr)) (i32.const 1))))

 (func $decr-blockset-heap-size (export "decr-blockset-heap-size")
   (param $blockset i32)
   (local $addr i32)
   (local.set $addr (i32.add (local.get $blockset) (global.get $blockset-heap-size)))
   (i32.store (local.get $addr) (i32.sub (i32.load (local.get $addr)) (i32.const 1))))

 (func $decr-blockset-free-list-length (export "decr-blockset-free-list-length")
   (param $blockset i32)
   (local $addr i32)
   (local.set $addr (i32.add (local.get $blockset) (global.get $blockset-free-list-length)))
   (i32.store (local.get $addr) (i32.sub (i32.load (local.get $addr)) (i32.const 1))))

 (func $incr-blockset-block-count (export "incr-blockset-block-count")
   (param $blockset i32)
   (local $addr i32)
   (local.set $addr (i32.add (local.get $blockset) (global.get $blockset-block-count)))
   (i32.store (local.get $addr) (i32.add (i32.load (local.get $addr)) (i32.const 1))))

 (func $incr-blockset-heap-size (export "incr-blockset-heap-size")
   (param $blockset i32)
   (local $addr i32)
   (local.set $addr (i32.add (local.get $blockset) (global.get $blockset-heap-size)))
   (i32.store (local.get $addr) (i32.add (i32.load (local.get $addr)) (i32.const 1))))

 (func $incr-blockset-free-list-length (export "incr-blockset-free-list-length")
   (param $blockset i32)
   (local $addr i32)
   (local.set $addr (i32.add (local.get $blockset) (global.get $blockset-free-list-length)))
   (i32.store (local.get $addr) (i32.add (i32.load (local.get $addr)) (i32.const 1))))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Block Utilities
 ;;

 (func $make-block (export "make-block")
   (param $addr i32)
   (param $length i32)
   (result i32)
   (call $make-pair (local.get $addr) (local.get $length)))

 (func $get-next-block-addr (export "get-next-block-addr")
   (param $block i32)
   (result i32)
   (i32.add (call $get-block-addr (local.get $block))
            (call $get-block-size (local.get $block))))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Block Accessors
 ;;

 (func $get-block-addr (export "get-block-addr")
   (param $block i32)
   (result i32)
   (call $get-pair-car (local.get $block)))

 (func $get-block-size (export "get-block-size")
   (param $block i32)
   (result i32)
   (call $get-pair-cdr (local.get $block)))

 (func $set-block-addr (export "set-block-addr")
   (param $block i32)
   (param $addr i32)
   (call $set-pair-car (local.get $block) (local.get $addr)))

 (func $set-block-size (export "set-block-size")
   (param $block i32)
   (param $size i32)
   (call $set-pair-cdr (local.get $block) (local.get $size)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Block Ref Utilities
 ;;

 (func $make-block-ref (export "make-block-ref")
   (param $block i32)
   (param $next i32)
   (result i32)
   (call $make-pair (local.get $block) (local.get $next)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Block Ref Accessors
 ;;

 (func $get-block-ref-addr (export "get-block-ref-addr")
   (param $block-ref i32)
   (result i32)
   (call $get-pair-caar (local.get $block-ref)))

 (func $get-block-ref-block (export "get-block-ref-block")
   (param $block-ref i32)
   (result i32)
   (call $get-pair-car (local.get $block-ref)))

 (func $get-block-ref-size (export "get-block-ref-size")
   (param $block-ref i32)
   (result i32)
   (call $get-pair-cadr (local.get $block-ref)))

 (func $get-next-block-ref (export "get-next-block-ref")
   (param $block-ref i32)
   (result i32)
   (call $get-pair-cdr (local.get $block-ref)))

 (func $set-block-ref-addr (export "set-block-ref-addr")
   (param $block-ref i32)
   (param $addr i32)
   (call $set-pair-caar (local.get $block-ref) (local.get $addr)))

 (func $set-block-ref-size (export "set-block-ref-size")
   (param $block-ref i32)
   (param $size i32)
   (call $set-pair-cadr (local.get $block-ref) (local.get $size)))

 (func $set-next-block-ref (export "set-next-block-ref")
   (param $block-ref i32)
   (param $next i32)
   (call $set-pair-cdr (local.get $block-ref) (local.get $next)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Free Entry Utilities
 ;;

 (func $make-free-entry (export "make-free-entry")
   (param $block-ref i32)
   (param $next i32)
   (result i32)
   (call $make-pair (local.get $block-ref) (local.get $next)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Free Entry Accessors
 ;;

 (func $get-free-entry-addr (export "get-free-entry-addr")
   (param $entry i32)
   (result i32)
   (call $get-pair-caaar (local.get $entry)))

 (func $get-free-entry-block (export "get-free-entry-block")
   (param $entry i32)
   (result i32)
   (call $get-pair-caar (local.get $entry)))

 (func $get-free-entry-block-ref (export "get-free-entry-block-ref")
   (param $entry i32)
   (result i32)
   (call $get-pair-car (local.get $entry)))

 (func $get-free-entry-size (export "get-free-entry-size")
   (param $entry i32)
   (result i32)
   (call $get-pair-caadr (local.get $entry)))

 (func $get-next-free-entry (export "get-next-free-entry")
   (param $entry i32)
   (result i32)
   (call $get-pair-cdr (local.get $entry)))

 (func $set-free-entry-addr (export "set-free-entry-addr")
   (param $entry i32)
   (param $addr i32)
   (call $set-pair-caaar (local.get $entry) (local.get $addr)))

 (func $set-free-entry-block-ref (export "set-free-entry-block-ref")
   (param $entry i32)
   (param $block-ref i32)
   (call $set-pair-car (local.get $entry) (local.get $block-ref)))

 (func $set-next-free-entry (export "set-next-free-entry")
   (param $entry i32)
   (param $next i32)
   (call $set-pair-cdr (local.get $entry) (local.get $next)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Heap Node Utilities
 ;;

 (func $make-heap-node (export "make-heap-node")
   (param $free-entry i32)
   (result i64)

   (i64.or (i64.shl (i64.extend_i32_u (local.get $free-entry))
                    (i64.const 32))
           (i64.extend_i32_u (call $get-free-entry-block (local.get $free-entry)))))

 (func $calc-heap-node-addr (export "calc-heap-node-addr")
   (param $heap i32)
   (param $idx i32)
   (result i32)
   (i32.add (local.get $heap)
            (i32.shl (local.get $idx) (global.get $heap-node-size-bits))))

 (func $calc-parent-idx (export "calc-parent-idx")
   (param $idx i32)
   (result i32)
   (i32.shr_u (i32.sub (local.get $idx) (i32.const 1))
              (i32.const 1)))

 (func $calc-left-idx (export "calc-left-idx")
   (param $idx i32)
   (result i32)
   (i32.add (i32.shl (local.get $idx) (i32.const 1))
            (i32.const 1)))

 (func $calc-right-idx (export "calc-right-idx")
   (param $idx i32)
   (result i32)
   (i32.shl (i32.add (local.get $idx) (i32.const 1))
            (i32.const 1)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Heap Node Accessors
 ;;

 (func $get-heap-node (export "get-heap-node")
   (param $heap i32)
   (param $idx i32)
   (result i64)
   (i64.load (call $calc-heap-node-addr (local.get $heap) (local.get $idx))))

 (func $get-heap-block (export "get-heap-block")
   (param $heap i32)
   (param $idx i32)
   (result i32)
   (i32.load (call $calc-heap-node-addr (local.get $heap) (local.get $idx))))

 (func $get-heap-block-addr (export "get-heap-block-addr")
   (param $heap i32)
   (param $idx i32)
   (result i32)
   (call $get-pair-car (call $get-heap-block (local.get $heap) (local.get $idx))))

 (func $get-heap-block-size (export "get-heap-block-size")
   (param $heap i32)
   (param $idx i32)
   (result i32)
   (call $get-pair-cdr (call $get-heap-block (local.get $heap) (local.get $idx))))

 (func $get-heap-node-entry (export "get-heap-node-entry")
   (param $heap i32)
   (param $idx i32)
   (result i32)
   (i32.wrap_i64 (i64.shr_u (call $get-heap-node (local.get $heap) (local.get $idx))
                            (i64.const 32))))

 (func $set-heap-block (export "set-heap-block")
   (param $heap i32)
   (param $idx i32)
   (param $block i32)
   (i32.store (call $calc-heap-node-addr (local.get $heap) (local.get $idx))
              (local.get $block)))

 (func $set-heap-block-addr (export "set-heap-block-addr")
   (param $heap i32)
   (param $idx i32)
   (param $addr i32)
   (call $set-block-addr
         (call $get-heap-block (local.get $heap) (local.get $idx))
         (local.get $addr)))

 (func $set-heap-block-size (export "set-heap-block-size")
   (param $heap i32)
   (param $idx i32)
   (param $size i32)
   (call $set-block-size
         (call $get-heap-block (local.get $heap) (local.get $idx))
         (local.get $size)))

 (func $set-heap-node-entry (export "set-heap-node-entry")
   (param $heap i32)
   (param $idx i32)
   (param $entry i32)
   (i64.store (call $calc-heap-node-addr (local.get $heap) (local.get $idx))
              (call $make-heap-node (local.get $entry))))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Allocation
 ;;

 (func $stub-alloc-block (export "stub-alloc-block")
   (param $blockset-id i32)
   (param $size i32)
   (result i32)
   (global.get $null))

 (func $alloc-block (export "alloc-block")
   (param $blockset-id i32)
   (param $size i32)
   (result i32)

   (local $blockset i32)
   (local $free-entry i32)
   (local $heap i32)
   (local $new-block-ref i32)
   (local $node-idx i32)

   (local.set $size (call $quantize-size (local.get $size)))

   (local.set $blockset (call $get-blockset (local.get $blockset-id)))

   (call $provision-blockset-heap (local.get $blockset) (local.get $size))

   (local.set $heap (call $get-blockset-heap (local.get $blockset)))

   (local.set $node-idx (call $select-heap-node (local.get $blockset) (local.get $size)))

   (if (i32.le_u (i32.sub (call $get-heap-block-size (local.get $heap) (local.get $node-idx))
                          (local.get $size))
                 (call $calc-max-overage (local.get $size)))
       (then
        (local.set $free-entry (call $get-heap-node-entry (local.get $heap) (local.get $node-idx)))
        (local.set $new-block-ref (call $get-free-entry-block-ref (local.get $free-entry)))

        (call $remove-free-list-entry (local.get $blockset) (local.get $free-entry))

        (call $remove-heap-node (local.get $blockset) (local.get $node-idx)))

     (else
      (local.set $new-block-ref
                 (call $split-heap-root
                       (local.get $blockset)
                       (local.get $heap)
                       (local.get $size)))))

   (call $set-blockset-free-space (local.get $blockset)
         (i32.sub (call $get-blockset-free-space (local.get $blockset))
                  (call $get-block-ref-size (local.get $new-block-ref))))

   (local.get $new-block-ref))

 (func $quantize-size (export "quantize-size")
   (param $size i32)
   (result i32)

   (local $mask i32)
   (local $rank i32)

   (local.set $rank (i32.sub (i32.const 32) (i32.clz (local.get $size))))

   (if (i32.le_u (local.get $rank) (i32.const 4))
       (then
        (local.set $mask (i32.const 0)))
     (else
      (local.set $mask (i32.sub (i32.shl (i32.const 1)
                                         (i32.sub (local.get $rank) (i32.const 4)))
                                (i32.const 1)))))

   (i32.and (i32.add (local.get $size) (local.get $mask))
            (i32.xor (local.get $mask) (i32.const -1))))

 (func $calc-max-overage (export "calc-max-overage")
   (param $size i32)
   (result i32)

   (local $rank i32)

   (local.set $rank (i32.sub (i32.const 32) (i32.clz (local.get $size))))

   (if (result i32) (i32.le_u (local.get $rank) (i32.const 4))
       (then
        (global.get $value-size))
       (else
        (i32.shl (i32.const 1)
                 (i32.sub (local.get $rank) (i32.const 2))))))

 (func $select-heap-node (export "select-heap-node")
   (param $blockset i32)
   (param $size i32)
   (result i32)

   (local $delta i32)
   (local $heap i32)
   (local $heap-size i32)
   (local $min-delta i32)
   (local $node-idx i32)
   (local $result-idx i32)
   (local $step i32)

   (local.set $heap (call $get-blockset-heap (local.get $blockset)))
   (local.set $heap-size (call $get-blockset-heap-size (local.get $blockset)))
   (local.set $result-idx (i32.const 0))
   (local.set $min-delta (i32.sub (call $get-heap-block-size (local.get $heap) (i32.const 0))
                                  (local.get $size)))
   (local.set $step (call $estimate-sqrt (local.get $heap-size)))

   (local.set $node-idx (i32.const 1))
   (loop $again
     (if (i32.and (i32.gt_u (local.get $min-delta) (i32.const 0))
                  (i32.lt_u (local.get $node-idx) (local.get $heap-size)))
         (then
          (if (i32.eqz (call $is-unused-heap-block (local.get $heap) (local.get $node-idx)))
              (then
               (local.set $delta
                          (i32.sub (call $get-heap-block-size (local.get $heap) (local.get $node-idx))
                                   (local.get $size)))
               (if (i32.lt_u (local.get $delta) (local.get $min-delta))
                   (then
                    (local.set $min-delta (local.get $delta))
                    (local.set $result-idx (local.get $node-idx))))))
        (local.set $node-idx (i32.add (local.get $node-idx) (local.get $step)))
        (br $again))))

   (local.get $result-idx))

 (func $provision-blockset-heap (export "provision-blockset-heap")
   (param $blockset i32)
   (param $size i32)

   (local $heap i32)

   (local.set $heap (call $get-blockset-heap (local.get $blockset)))

   (if (call $get-blockset-free-list-length (local.get $blockset))
       (then
        (loop $again
          (if (call $is-unused-heap-block (local.get $heap) (i32.const 0))
                 (then
                  (call $remove-unused-heap-node (local.get $blockset) (i32.const 0))
                  (br $again))))))

   (if (i32.eqz (call $get-blockset-free-list-length (local.get $blockset)))
       (then
        (call $expand-blockset-heap (local.get $blockset) (local.get $size)))
     (else
      (local.set $heap (call $get-blockset-heap (local.get $blockset)))
      (if (i32.gt_u (local.get $size) (call $get-heap-block-size (local.get $heap) (i32.const 0)))
          (then
           (call $expand-blockset-heap (local.get $blockset) (local.get $size)))))))

 (func $expand-blockset-heap (export "expand-blockset-heap")
   (param $blockset i32)
   (param $size i32)

   (local $block i32)
   (local $block-addr i32)
   (local $block-ref i32)
   (local $blockset-id i32)
   (local $end-block i32)
   (local $end-page i32)
   (local $end-ref i32)
   (local $free-pages i32)
   (local $page-count i32)
   (local $total-pages i32)

   (local.set $blockset-id (call $get-blockset-id (local.get $blockset)))

   (local.set $page-count (i32.add (i32.shr_u (i32.sub (local.get $size)
                                                       (i32.const 1))
                                              (global.get $page-size-bits))
                                   (i32.const 1)))

   (local.set $total-pages (call_indirect
                            $memory-size
                            (type $memory-size-sig)
                            (local.get $blockset-id)))

   (local.set $end-ref (call $get-blockset-end-block-ref (local.get $blockset)))

   (if (i32.eq (local.get $end-ref) (global.get $null))
       (then
        (local.set $free-pages (local.get $total-pages))
        (local.set $block-addr (i32.const 0)))

     (else
      (local.set $end-block (call $get-block-ref-block (local.get $end-ref)))

      (local.set $end-page (i32.shr_u (call $get-next-block-addr (local.get $end-block))
                                      (global.get $page-size-bits)))

      (local.set $free-pages (i32.sub (local.get $total-pages) (local.get $end-page)))

      (local.set $block-addr (call $get-next-block-addr (local.get $end-block)))))

   (if (i32.lt_u (local.get $free-pages) (local.get $page-count))
       (then
        (drop (call_indirect $memory-grow
                             (type $memory-grow-sig)
                             (i32.sub (local.get $page-count)
                                      (local.get $free-pages))
                             (local.get $blockset-id)))))

   (local.set $block (call $make-block
                           (local.get $block-addr)
                           (i32.shl (local.get $page-count)
                                    (global.get $page-size-bits))))

   (local.set $block-ref (call $make-block-ref (local.get $block) (global.get $null)))

   (if (i32.eq (local.get $end-ref) (global.get $null))
       (then
        (call $set-blockset-block-list (local.get $blockset) (local.get $block-ref)))
     (else
      (call $set-next-block-ref (local.get $end-ref) (local.get $block-ref))))

   (call $set-blockset-end-block-ref (local.get $blockset) (local.get $block-ref))
   (call $incr-blockset-block-count (local.get $blockset))

   (call $add-free-block (local.get $blockset) (local.get $block-ref)))

 (func $split-heap-root (export "split-heap-root")
   (param $blockset i32)
   (param $heap i32)
   (param $split-size i32)
   (result i32)

   (local $block-ref i32)
   (local $free-entry i32)
   (local $new-block i32)
   (local $new-block-ref i32)
   (local $next-block-ref i32)
   (local $remainder-size i32)

   (local.set $heap (call $get-blockset-heap (local.get $blockset)))
   (local.set $free-entry (call $get-heap-node-entry (local.get $heap) (i32.const 0)))

   (local.set $block-ref (call $get-free-entry-block-ref (local.get $free-entry)))

   (local.set $remainder-size
              (i32.sub (call $get-block-ref-size (local.get $block-ref))
                       (local.get $split-size)))

   (local.set $new-block (call $make-block
                               (i32.add (call $get-block-ref-addr (local.get $block-ref))
                                        (local.get $split-size))
                               (local.get $remainder-size)))

   (local.set $next-block-ref (call $get-next-block-ref (local.get $block-ref)))

   (local.set $new-block-ref (call $make-block-ref
                                   (local.get $new-block)
                                   (local.get $next-block-ref)))

   (call $set-next-block-ref (local.get $block-ref) (local.get $new-block-ref))

   (call $set-block-ref-size (local.get $block-ref) (local.get $split-size))

   (call $incr-blockset-block-count (local.get $blockset))

   (if (i32.eq (local.get $next-block-ref) (global.get $null))
       (then
        (call $set-blockset-end-block-ref
              (local.get $blockset)
              (local.get $new-block-ref))))

   (call $set-free-entry-block-ref (local.get $free-entry) (local.get $new-block-ref))
   (call $set-heap-block (local.get $heap) (i32.const 0) (local.get $new-block))
   (call $sink-heap-node (local.get $blockset) (i32.const 0))

   (local.get $block-ref))

 (func $remove-free-list-entry (export "remove-free-list-entry")
   ;; Removes an entry from the free list. The entry is removed from
   ;; the free list and deallocated, and the free list length is
   ;; decremented.  This is called from alloc-block when the entire
   ;; free block is used for an allocation request.

   (param $blockset i32)
   (param $entry i32)

   (local $next-free-entry i32)
   (local $prior-free-entry i32)

   (local.set $next-free-entry (call $get-next-free-entry (local.get $entry)))

   (local.set $prior-free-entry (call $find-predecessor-free-list-entry
                                      (local.get $blockset)
                                      (call $get-free-entry-block-ref (local.get $entry))))

   (if (i32.eq (local.get $prior-free-entry) (global.get $null))
       (then
        (call $set-blockset-free-list (local.get $blockset) (local.get $next-free-entry)))
     (else
      (call $set-next-block-ref (local.get $prior-free-entry) (local.get $next-free-entry))))

   (call $dealloc-pair (local.get $entry))

   (call $decr-blockset-free-list-length (local.get $blockset)))

 ;;-----------------------------------------------------------------------------
 ;;
 ;; Resize Block
 ;;

 (func $resize-block (export "resize")
   (param $blockset i32)
   (param $block-ref i32)
   (param $new-size i32)
   (result i32)

   (local $free-addr i32)
   (local $free-block i32)
   (local $free-block-ref i32)
   (local $free-size i32)
   (local $new-block-ref i32)
   (local $next-block-ref i32)
   (local $old-size i32)
   (local $resized-block-ref i32)

   (local.set $old-size (call $get-block-ref-size (local.get $block-ref)))

   (if (i32.gt_u (local.get $new-size) (local.get $old-size))
       (then
        (local.set $new-block-ref (call $alloc-block (local.get $blockset) (local.get $new-size)))

        (call_indirect $memory-copy
                       (type $memory-copy-sig)
                       (call $get-block-ref-addr (local.get $new-block-ref))
                       (call $get-block-ref-addr (local.get $block-ref))
                       (local.get $old-size)
                       (call $get-blockset-id (local.get $blockset)))

        (call $add-free-block (local.get $blockset) (local.get $block-ref))
        (local.set $resized-block-ref (local.get $new-block-ref)))

     (else
      (local.set $resized-block-ref (local.get $block-ref))

      (if (i32.gt_u (local.get $old-size) (local.get $new-size))
          (then
           (local.set $next-block-ref (call $get-next-block-ref (local.get $block-ref)))

           (local.set $free-addr (i32.add (call $get-block-ref-addr (local.get $block-ref))
                                          (local.get $new-size)))
           (local.set $free-size (i32.sub (local.get $old-size) (local.get $new-size)))
           (local.set $free-block (call $make-block (local.get $free-addr) (local.get $free-size)))
           (local.set $free-block-ref (call $make-block-ref
                                      (local.get $free-block)
                                      (local.get $next-block-ref)))

           (call $set-next-block-ref (local.get $block-ref) (local.get $free-block-ref))
           (call $set-block-ref-size (local.get $block-ref) (local.get $new-size))
           (call $add-free-block (local.get $blockset) (local.get $free-block-ref))

           (if (i32.eq (local.get $next-block-ref) (global.get $null))
               (then
                (call $set-blockset-end-block-ref
                      (local.get $blockset) (local.get $free-block-ref))))))))

   (local.get $resized-block-ref))


 ;;-----------------------------------------------------------------------------
 ;;
 ;; Deallocation
 ;;

 (func $stub-dealloc-block (export "stub-dealloc-block")
   (param $blockset-id i32)
   (param $block-ref i32))

 (func $dealloc-block (export "dealloc-block")
   (param $blockset-id i32)
   (param $block-ref i32)

   (local $blockset i32)
   (local $free-list-length i32)
   (local $heap-size i32)

   (local.set $blockset (call $get-blockset (local.get $blockset-id)))

   (call $add-free-block (local.get $blockset) (local.get $block-ref))

   (local.set $free-list-length (call $get-blockset-free-list-length (local.get $blockset)))
   (local.set $heap-size (call $get-blockset-heap-size (local.get $blockset)))

   (if (i32.gt_u (i32.mul (local.get $free-list-length)
                          (call $get-blockset-relocation-size-limit (local.get $blockset)))
                 (call $get-blockset-total-size (local.get $blockset)))
       (then
        (call $step-defragment-blockset-free-list (local.get $blockset))
        (call $step-clean-heap (local.get $blockset)))))

 (func $add-free-block (export "add-free-block")
   (param $blockset i32)
   (param $block-ref i32)

   (local $entry i32)
   (local $prior-free-entry i32)
   (local $next-free-entry i32)

   (local.set $entry (call $make-block-ref (local.get $block-ref) (global.get $null)))

   (local.set $prior-free-entry (call $find-predecessor-free-list-entry
                                      (local.get $blockset)
                                      (local.get $block-ref)))

   (if (i32.eq (local.get $prior-free-entry) (global.get $null))
       (then
        (local.set $next-free-entry (call $get-blockset-free-list (local.get $blockset)))
        (call $set-blockset-free-list (local.get $blockset) (local.get $entry)))
     (else
      (local.set $next-free-entry (call $get-next-free-entry (local.get $prior-free-entry)))
      (call $set-next-free-entry (local.get $prior-free-entry) (local.get $entry))))

   (call $set-next-free-entry (local.get $entry) (local.get $next-free-entry))

   (call $incr-blockset-free-list-length (local.get $blockset))

   (call $insert-heap-node (local.get $blockset) (local.get $entry))

   (call $set-blockset-free-space (local.get $blockset)
         (i32.add (call $get-blockset-free-space (local.get $blockset))
                  (call $get-block-ref-size (local.get $block-ref)))))

 ;; todo
 (func $get-blockset-inactive-free-memory (export "get-blockset-inactive-free-memory")
   (param $blockset i32)
   (result i32)
   (i32.const 0)
   ;; (if (result i32) (call $get-blockset-heap-size (local.get $blockset))
   ;;   (then
   ;;    (i32.add (i32.mul (call $get-blockset-free-list-length (local.get $blockset))
   ;;                      (i32.const 48))
   ;;          (i32.sub (call $get-blockset-free-space (local.get $blockset))
   ;;                   (call $get-heap-block-size
   ;;                         (call $get-blockset-heap (local.get $blockset))))))
   ;;   (else
   ;;    ))
   )

 (func $get-blockset-total-size (export "get-blockset-total-size")
   (param $blockset i32)
   (result i32)
   (if (result i32) (call $get-blockset-block-count (local.get $blockset))
     (then
      (i32.sub (call $get-block-ref-addr (call $get-blockset-end-block-ref (local.get $blockset)))
               (call $get-block-ref-addr (call $get-blockset-block-list (local.get $blockset)))))
     (else
      (i32.const 0))))

 ;; ## Defragmentation
 ;;
 ;; Defragmentation is the process of relocating allocated blocks so that free
 ;; blocks can be merged.
 ;;
 ;; Policy parameters: step frequency, target # of bytes copied per step, min
 ;; size of non-relocatable block.
 ;;
 ;; At each step, we need to be able to remove two entries from the free list
 ;; and replace them with a larger entry.  The two candidate entries will be the
 ;; first two above the cursor, so we will need to have the address of the free
 ;; entry immediately below (or at) the cursor.  We need a fast way to find the
 ;; highest address of a free entry at or below the cursor.  The naive approach
 ;; would be to scan from the beginning of the list, but as the number of free
 ;; list entries grows, this becomes increasingly slower.  Since the heap is
 ;; ordered by free block size, we should expect that any arbitrary subset will
 ;; be a random sample over the address space.  This sample won't be uniform,
 ;; especially during defragmentation, where the address space below the cursor
 ;; will be undersampled.  The root node of the heap is generally going to be
 ;; above the cursor, both in the initial part of defragmentation when most heap
 ;; nodes are above the cursor, and the in the later part when most of the
 ;; lower free blocks have been swept up above the cursor.  A useful property of
 ;; heaps is that the top half (in terms of levels) contains roughly the square
 ;; root of the total number of nodes in the heap.  For example, a heap of
 ;; 1023 nodes has 10 levels.  The first 5 levels contain 31 nodes, and
 ;; 31^2 = 961.  An average linear scan of a free list of 1023 entries is going
 ;; to take 512 comparisons, but if we make 31 comparisions of the top half of
 ;; the heap to find a better starting place, we should expect a further 33 to
 ;; find the desired entry.  For a heap of this size, it's roughly 1/8th the
 ;; computational cost to scan the top half of the heap for a better starting
 ;; point than to start at the beginning of the free list.
 ;;
 ;; Assuming then, that we have a pointer to the highest free list entry before
 ;; the cursor, then the defragmentation algorithm is as follows:
 ;;
 ;; 1. Scan the block list forward from the cursor to find the next free block.
 ;;
 ;;   a. if there is no such block, reset the cursor to the beginning of the
 ;;      block list
 ;;
 ;;   b. if a free block is found, leave the cursor at the block before the
 ;;      free block
 ;;
 ;; 2. Scan the block list beyond that free block to find the set of blocks
 ;;    which satisify one of the following conditions, with earlier conditions
 ;;    taking precedence
 ;;
 ;;   a. The set of blocks before the successor to the next free block.
 ;;
 ;;   b. A set of blocks less than the policy limit,
 ;;
 ;;   c. A single block less than the single block policy limit, or
 ;;
 ;; 3. If the set of blocks found in step 2 is empty, then end the step by the
 ;;    following
 ;;
 ;;   a. if the next free block is the last block, reset the cursor to the
 ;;      beginning of the block list
 ;;
 ;;   b. if the next block after the next free block is a free block, then merge
 ;;      the two free blocks by increasing the size of the lower free block,
 ;;      removing its successor from the block list and the free list, and
 ;;      setting the successor's address to -1
 ;;
 ;;   c. if the next block after the next free block is an allocated block, then
 ;;      it is greater than the max relocatable block size. Set the cursor to
 ;;      the next block after the next free block.
 ;;
 ;; 4. Move the blocks found in step 2 lower in memory by the size of the next
 ;;    free block, and adjust their addresses accordingly.
 ;;
 ;; 5. If the last relocated block is followed by a free block, then end the
 ;;    step by the following
 ;;
 ;;    a. then create a new free block with address at the top of the relocated
 ;;       blocks and size of the next free block (formerly below the relocated
 ;;       blocks) plus its successor (formerly above)
 ;;
 ;;    b. remove the next free block and its successor from the free list and
 ;;       from the block list
 ;;
 ;;    c. insert the new free block into the block list after the last relocated
 ;;       block
 ;;
 ;;    d. insert the new free block into the free list at the place formerly
 ;;       occupied by the next free block
 ;;
 ;;    e. set the address of the next free block and its successor to -1
 ;;
 ;;    f. set the cursor to the last relocated block.
 ;;
 ;; 6. If the last relocated block is not followed by a free block, then end the
 ;;    step by the following
 ;;
 ;;    a. remove the next free block from the block list (immediately before the
 ;;       first relocated block)
 ;;
 ;;    b. insert the next free block into the block list immediately following
 ;;       the last relocated block
 ;;
 ;;    c. update the address of the next free block
 ;;
 ;;    d. set the cursor to the last relocated block.
 ;;

 (func $step-defragment-blockset-free-list (export "step-defragment-blockset-free-list")
   (param $blockset i32)

   (local $cursor i32)
   (local $free-entry i32)
   (local $free-ref i32)
   (local $next i32)
   (local $next-free-entry i32)
   (local $next-free-ref i32)
   (local $prior-free-entry i32)
   (local $relo-end i32)
   (local $relo-last i32)
   (local $relo-size i32)
   (local $relo-start i32)

   (if (i32.lt_u (call $get-blockset-free-list-length (local.get $blockset))
                 (i32.const 2))
       (then
        (return)))

   ;; Get three free list entries where the defragmentation cursor will
   ;; be below the block in free entry, but above or at the one in prior
   ;; free entry. NB. prior free entry can be null, indicating that it
   ;; represents the start of the free list.
   (local.set $prior-free-entry
              (local.set $free-entry
                         (local.set $next-free-entry
                                    (call $prepare-defragment-blockset
                                          (local.get $blockset)))))

   ;; The defragmentation cursor is set as a side effect of calling
   ;; $prepare-defragment-blockset
   (local.set $cursor (call $get-blockset-defrag-cursor (local.get $blockset)))

   ;; If the cursor is near the end of the free list, then there's
   ;; nothing to do.
   (if (i32.or (i32.eq (local.get $free-entry) (global.get $null))
               (i32.eq (local.get $next-free-entry) (global.get $null)))
       (then
        (return)))

   ;; These are used a few times below.
   (local.set $free-ref (call $get-free-entry-block-ref (local.get $free-entry)))
   (local.set $next-free-ref (call $get-free-entry-block-ref (local.get $next-free-entry)))

   (local.set $relo-start (call $get-next-block-ref (local.get $free-ref)))

   (if (i32.eq (local.get $relo-start) (local.get $next-free-ref))
       (then
        ;; We found two adjacent free entries. Merge them.
        (call $merge-free-entries
              (local.get $blockset)
              (local.get $cursor)
              (local.get $prior-free-entry)
              (local.get $free-entry)
              (local.get $next-free-entry))
        (return)))

   ;; Scan from free ref upward for allocated blocks, stopping when
   ;; we've found the limit that we can move or the next free ref.
   (local.set $relo-last
              (local.set $relo-size
                         (call $scan-relocatable-blocks
                               (local.get $blockset)
                               (local.get $relo-start)
                               (local.get $next-free-ref)
                               (call $get-blockset-relocation-size-limit (local.get $blockset))
                               (call $get-blockset-immobile-block-size (local.get $blockset)))))

   (local.set $relo-end (call $get-next-block-ref (local.get $relo-last)))

   (if (i32.eqz (local.get $relo-size))
       (then
        ;; The block after free-ref is too big to move. Move the cursor to that block.
        ;; See $get-blockset-immobile-block-size below.
        (call $set-blockset-defrag-cursor (local.get $blockset) (local.get $relo-end))
        (return)))

   ;; Shift the blocks down in memory, adjusting their addresses.
   (call $relocate-blocks
         (local.get $blockset)
         (call $get-block-ref-addr (local.get $free-ref))
         (local.get $relo-start)
         (local.get $relo-end)
         (local.get $relo-size))

   ;; Remove free-ref from between cursor and relo-start.
   (call $set-next-block-ref (local.get $cursor) (local.get $relo-start))

   (if (i32.eq (local.get $relo-end) (local.get $next-free-ref))
       ;; All of the allocated blocks between free-ref and next-free-ref
       ;; were moved down in memory, allowing those free entries
       ;; to be merged.
       (then

        ;; This sets the base address for the merged free block.
        (call $set-block-ref-addr
              (local.get $free-ref)
              (i32.add (call $get-block-ref-addr (local.get $relo-start))
                       (local.get $relo-size)))

        (call $merge-free-entries
              (local.get $blockset)
              (local.get $relo-last)
              (local.get $prior-free-entry)
              (local.get $free-entry)
              (local.get $next-free-entry)))
     (else
      ;; insert free-ref after relo-end
      (call $set-next-block-ref (local.get $free-ref) (local.get $relo-end))
      (call $set-next-block-ref (local.get $relo-last) (local.get $free-ref))

      (call $set-block-ref-addr
            (local.get $free-ref)
            (i32.add (call $get-block-ref-addr (local.get $free-ref))
                     (local.get $relo-size)))

      ;; Check to see if the last moved block was the end block
      (if (i32.eq (call $get-next-block-ref (local.get $free-ref)) (global.get $null))
          (then
           (call $set-blockset-end-block-ref
                 (local.get $blockset)
                 (local.get $free-ref))))))

   ;; At this point, everything before relo-end has been defragmented, and all
   ;; of the gathered free space is in the block immediately after.
   (call $set-blockset-defrag-cursor (local.get $blockset) (local.get $relo-last)))

 (func $prepare-defragment-blockset (export "prepare-defragment-blockset")
   (param $blockset i32)
   (result i32 i32 i32)

   (local $cursor i32)
   (local $first-free-entry i32)
   (local $free-entry i32)
   (local $free-ref i32)
   (local $next i32)
   (local $next-free-entry i32)
   (local $prior-free-entry i32)

   (local.set $prior-free-entry (global.get $null))
   (local.set $free-entry (global.get $null))
   (local.set $next-free-entry (global.get $null))

   (local.set $cursor (call $get-blockset-defrag-cursor (local.get $blockset)))

   (if (i32.eq (local.get $cursor) (global.get $null))
       (then
        ;; A null cursor implies we're starting over from the beginning.
        (local.set $cursor (call $initialize-blockset-defrag (local.get $blockset)))))

   (if (i32.ne (local.get $cursor (global.get $null)))
       (then
        (local.set $prior-free-entry (call $find-predecessor-free-list-entry
                                           (local.get $blockset)
                                           (local.get $cursor)))

        (local.set $free-entry
                   (if (result i32) (i32.eq (local.get $prior-free-entry) (global.get $null))
                     (then
                      ;; If there is no free list entry prior to or at the defrag cursor,
                      ;; then the next free list entry will be the focus of the step.
                      (call $get-blockset-free-list (local.get $blockset)))
                     (else
                      ;; Otherwise, the free list entry just above the cursor is the
                      ;; successor to the prior free entry.
                      (call $get-next-free-entry (local.get $prior-free-entry)))))

        (if (i32.eq (local.get $free-entry) (global.get $null))
            (then
             ;; If the free list is empty, or the prior free list entry is at the
             ;; end of the free list, then start over.
             (call $set-blockset-defrag-cursor (local.get $blockset) (global.get $null)))

          (else
           ;; Otherwise, we'll try to merge free entry with its successor.

           ;; In the case that the cursor points to a free block, treat that as
           ;; the prior free entry.
           (if (i32.eq (call $get-free-entry-block-ref (local.get $free-entry)) (local.get $cursor))
               (then
                (local.set $prior-free-entry (local.get $free-entry))
                (local.set $free-entry (call $get-next-free-entry (local.get $prior-free-entry)))))

           (local.set $next-free-entry (call $get-next-free-entry (local.get $free-entry)))

           (if (i32.eq (local.get $next-free-entry) (global.get $null))
               (then
                ;; If the free entry is the last one, then there is nothing left
                ;; to do, so start over.
                (call $set-blockset-defrag-cursor (local.get $blockset) (global.get $null)))

             (else
              ;; At this point, the conditions for a defragmentation step are satisfied.
              ;; Scan the cursor forward so that its successor is the free entry.
        (if (global.get $debug)
            (then
             (call $set-blockset-defrag-cursor (local.get $blockset) (local.get $cursor))
             (local.get $prior-free-entry)
             (local.get $free-entry)
             (local.get $next-free-entry)

             (return)))

              (local.set $free-ref (call $get-free-entry-block-ref (local.get $free-entry)))

              (loop $again
                (local.set $next (call $get-next-block-ref (local.get $cursor)))
                (if (i32.ne (local.get $next) (local.get $free-ref))
                    (then
                     (local.set $cursor (local.get $next))
                     (br $again))))

              (call $set-blockset-defrag-cursor (local.get $blockset) (local.get $cursor))))))))

   ;; Return values
   (local.get $prior-free-entry)
   (local.get $free-entry)
   (local.get $next-free-entry))

 (func $initialize-blockset-defrag (export "initialize-blockset-defrag")
   (param $blockset i32)
   (result i32)

   (local $free-head i32)
   (local $free-ref i32)
   (local $head i32)
   (local $next i32)
   (local $next-free i32)

   (local.set $head (call $get-blockset-block-list (local.get $blockset)))
   (local.set $free-head (call $get-blockset-free-list (local.get $blockset)))

   ;; Merge any initial sequence of free blocks in the block list into a single
   ;; free block

   (if (i32.and (i32.ne (local.get $head) (global.get $null))
                (i32.ne (local.get $free-head) (global.get $null)))
       (then
        (if (i32.eq (call $get-block-ref-addr (local.get $head))
                    (call $get-free-entry-addr (local.get $free-head)))
            (then
             (loop $again
               (local.set $free-head (call $get-blockset-free-list (local.get $blockset)))
               (local.set $next-free (call $get-next-free-entry (local.get $free-head)))
               (if (i32.ne (local.get $next-free) (global.get $null))
                   (then
                    (if (i32.eq (call $get-next-block-addr
                                      (call $get-free-entry-block (local.get $free-head)))
                                (call $get-free-entry-addr (local.get $next-free)))
                        (then
                         (call $merge-free-entries
                               (local.get $blockset)
                               (global.get $null)
                               (global.get $null)
                               (local.get $free-head)
                               (local.get $next-free))
                         (br $again))))))

             ;; If there is an allocated block after the now single initial free
             ;; block, then swap them.

             ;; The car of free head is the first block ref in the block list,
             ;; and its cadr is the second.
             (local.set $free-ref (call $get-free-entry-block-ref (local.get $free-head)))
             (local.set $head (call $get-next-block-ref (local.get $free-ref)))

             (if (i32.ne (local.get $head) (global.get $null))
                 (then
                  (local.set $next (call $get-next-block-ref (local.get $head)))

                  (call $relocate-blocks
                        (local.get $blockset)
                        (call $get-block-ref-addr (local.get $free-ref))
                        (local.get $head)
                        (local.get $next)
                        (call $get-block-ref-size (local.get $head)))

                  (call $set-blockset-block-list (local.get $blockset) (local.get $head))
                  (call $set-next-block-ref (local.get $head) (local.get $free-ref))
                  (call $set-next-block-ref (local.get $free-ref) (local.get $next))

                  (call $set-block-ref-addr
                        (local.get $free-ref)
                        (call $get-next-block-addr
                              (call $get-block-ref-block (local.get $head))))

                  (if (i32.eq (local.get $next) (global.get $null))
                      (then
                       (call $set-blockset-end-block-ref
                             (local.get $blockset)
                             (local.get $free-ref))))))))))

   (local.get $head))


 ;; Finding the predecessor of an entry in the free list is an expensive
 ;; operation.  The naive approach would be to search from the start of the free
 ;; list, but this quickly becomes inefficient, taking O(n) steps where n is the
 ;; length of the free list.  If instead we search the top half (depth-wise) of
 ;; the heap for the greatest entry which is less than our target, and from
 ;; there search linearly, we should have something like O(sqrt(n)).  The scan
 ;; of the top half of the heap is done in $estimate-free-entry-infimum, and the
 ;; linear scan from there is done in the body of this function. Returns $null
 ;; if there is no free list entry before the given block ref.
 (func $find-predecessor-free-list-entry (export "find-predecessor-free-list-entry")
   (param $blockset i32)
   (param $block-ref i32)
   (result i32)

   (local $block-addr i32)
   (local $free-entry i32)
   (local $head i32)
   (local $next i32)

   (local.set $block-addr (call $get-block-ref-addr (local.get $block-ref)))

   ;; $free-entry is the highest address free list entry in the top half of the
   ;; heap which is less than the address of $block-ref.  It will be $null
   ;; if there is no such entry in the top half of the heap.
   (if (i32.ne (call $get-blockset-free-list (local.get $blockset))
               (global.get $null))
       (then
        (local.set $free-entry
                   (call $estimate-free-entry-infimum
                         (local.get $blockset)
                         (local.get $block-addr))))
     (else
      (local.set $free-entry (global.get $null))))

   ;; If there wasn't a free entry in the top half of the heap, check if the
   ;; head of the free list is non-null and less than $block-ref's address.
   (if (i32.eq (local.get $free-entry) (global.get $null))
       (then
        (local.set $head (call $get-blockset-free-list (local.get $blockset)))
        (if (i32.ne (local.get $head) (global.get $null))
            (then
             (if (i32.lt_u (call $get-free-entry-addr (local.get $head))
                           (local.get $block-addr))
                 (then
                  (local.set $free-entry (local.get $head))))))))

   ;; Search forward, stopping when the address of the next free entry is
   ;; greater than or equal to the address of $block-ref
   (if (i32.ne (local.get $free-entry) (global.get $null))
       (then
        (local.set $head (local.get $free-entry))
        (loop $again
          (local.set $next (call $get-next-free-entry (local.get $head)))
          (if (i32.ne (local.get $next) (global.get $null))
              (then
               (if (i32.lt_u (call $get-free-entry-addr (local.get $next))
                             (local.get $block-addr))
                   (then
                    (local.set $head (local.get $next))
                    (br $again))))))
        (local.set $free-entry (local.get $head))))

   (local.get $free-entry))

 ;; equivalent to
 ;; def est_sqrt(n):
 ;;     x = 1 << (int(log2(n)+1) >> 1)
 ;;     return (int(n/x) + x) >> 1
 ;; this has an average percent error of -1.6% over the range 1, 10000:
 ;; >>> err = 0
 ;; >>> for x in range(1, 10000):
 ;; ...   err += 1-est_sqrt(x)/sqrt(x)
 ;; ...
 ;; >>> print(100*err/10000)
 ;; -1.590135150490832
 ;;
 ;; computes an estimate of the sqrt, x = 1 << ((log2(n)+1) >> 1), and
 ;; then refines the estimate by returning (n/x + x)/2
 (func $estimate-sqrt (export "estimate-sqrt")
   (param $n i32)
   (result i32)

   (local $x i32)

   (if (result i32) (local.get $n)
     (then
      (local.set $x (i32.shl (i32.const 1)
                             (i32.shr_u (i32.sub (i32.const 33)
                                                 (i32.clz (local.get $n)))
                                        (i32.const 1))))

      (i32.shr_u (i32.add (i32.div_u (local.get $n) (local.get $x))
                          (local.get $x))
                 (i32.const 1)))
     (else
      (i32.const 0))))

 (func $estimate-free-entry-infimum (export "estimate-free-entry-infimum")
   (param $blockset i32)
   (param $max-addr i32)
   (result i32)

   (local $addr i32)
   (local $end-idx i32)
   (local $free-entry i32)
   (local $heap i32)
   (local $inf-addr i32)
   (local $node-idx i32)

   (local.set $heap (call $get-blockset-heap (local.get $blockset)))

   (local.set $free-entry (global.get $null))
   (local.set $inf-addr (i32.const 0))

   (local.set $node-idx (i32.const 0))
   (local.set $end-idx (call $estimate-sqrt (call $get-blockset-heap-size (local.get $blockset))))

   (loop $again
     (local.set $addr (call $get-heap-block-addr (local.get $heap) (local.get $node-idx)))
     (if (i32.and (i32.lt_u (local.get $addr) (local.get $max-addr))
                  (i32.gt_u (local.get $addr) (local.get $inf-addr)))
         (then
          (local.set $free-entry
                     (call $get-heap-node-entry (local.get $heap) (local.get $node-idx)))
          (local.set $inf-addr (local.get $addr))))
     (local.set $node-idx (i32.add (local.get $node-idx) (i32.const 1)))
     (if (i32.lt_u (local.get $node-idx) (local.get $end-idx))
         (then
          (br $again))))

   (local.get $free-entry))

 (func $scan-relocatable-blocks (export "scan-relocatable-blocks")
   (param $blockset i32)
   (param $start-ref i32)
   (param $next-free-ref i32)
   (param $aggregate-size-limit i32)
   (param $single-block-size-limit i32)
   (result i32 i32)

   (local $head i32)
   (local $last i32)
   (local $count i32)
   (local $size i32)
   (local $size-remaining i32)

   (local.set $last (local.get $start-ref))
   (local.set $head (local.get $start-ref))
   (local.set $count (i32.const 0))
   (local.set $size-remaining (local.get $aggregate-size-limit))

   ;; The logic is simpler to start with the total number of bytes that can be
   ;; moved and subtract from it the size of each block that will be moved.
   ;; Note that this is a signed value, unlike all other values in this module.

   (loop $again
     (if (i32.ne (local.get $head) (local.get $next-free-ref))
         (then
          (local.set $size (call $get-block-ref-size (local.get $head)))
          (if (i32.le_s (local.get $size) (local.get $size-remaining))
              (then
               ;; The current block will fit with the remaining bytes available.
               (local.set $size-remaining (i32.sub (local.get $size-remaining)
                                                   (local.get $size)))
               (local.set $last (local.get $head))
               (local.set $head (call $get-next-block-ref (local.get $head)))
               (if (i32.ne (local.get $head) (global.get $null))
                   (then
                    (local.set $count (i32.add (local.get $count) (i32.const 1)))
                    (br $again))))
            (else
             ;; The current block won't fit. If this is the first block, then it is
             ;; be bigger than the size allowable for a sequence of blocks, but it might
             ;; be relocatable if it's below the single block size limit.
             (if (i32.and (i32.eqz (local.get $count))
                          (i32.lt_u (local.get $size)
                                    (local.get $single-block-size-limit)))
                 (then
                  ;; This is the statement that requires aggregate size limit to be
                  ;; a signed value.
                  (local.set $size-remaining (i32.sub (local.get $size-remaining)
                                                      (local.get $size)))
                  (local.set $last (local.get $head))
                  (local.set $head (call $get-next-block-ref (local.get $head))))))))))

   ;; Return values

   ;; Address of the block beyond the last block that can be moved
   (local.get $last)

   ;; The size remaining is the aggregate size limit minus the size of each block
   ;; that can be moved.  The difference below results in the sum of the sizes
   ;; of the blocks that can be moved.
   (i32.sub (local.get $aggregate-size-limit) (local.get $size-remaining)))

 (func $merge-free-entries (export "merge-free-entries")
   (param $blockset i32)
   (param $prior-block-ref i32)
   (param $prior-free-entry i32)
   (param $free-entry i32)
   (param $next-free-entry i32)

   (local $new-block-ref i32)
   (local $new-free-block i32)
   (local $new-free-entry i32)

   (local.set $new-free-block
              (call $make-block
                    (call $get-free-entry-addr (local.get $free-entry))
                    (i32.add (call $get-free-entry-size (local.get $free-entry))
                             (call $get-free-entry-size (local.get $next-free-entry)))))

   (call $mark-free-entry-unused (local.get $free-entry))
   (call $mark-free-entry-unused (local.get $next-free-entry))

   (local.set $new-block-ref (call $make-block-ref
                                   (local.get $new-free-block)
                                   (call $get-next-block-ref
                                         (call $get-free-entry-block-ref
                                               (local.get $next-free-entry)))))

   (local.set $new-free-entry (call $make-free-entry
                                    (local.get $new-block-ref)
                                    (call $get-next-free-entry (local.get $next-free-entry))))

   (if (i32.eq (local.get $prior-free-entry) (global.get $null))
       (then
        (call $set-blockset-free-list (local.get $blockset) (local.get $new-free-entry)))
     (else
      (call $set-next-free-entry (local.get $prior-free-entry) (local.get $new-free-entry))))

   (call $insert-heap-node (local.get $blockset) (local.get $new-free-entry))

   ;; add the new, merged free block after the last relocated block
   (if (i32.eq (local.get $prior-block-ref) (global.get $null))
       (then
        (call $set-blockset-block-list (local.get $blockset) (local.get $new-block-ref)))
     (else
      (call $set-next-block-ref (local.get $prior-block-ref) (local.get $new-block-ref))))

   (call $decr-blockset-free-list-length (local.get $blockset))
   (call $decr-blockset-block-count (local.get $blockset))

   ;; Check to see if the merged block was the end block
   (if (i32.eq (call $get-next-block-ref (local.get $new-block-ref)) (global.get $null))
       (then
        (call $set-blockset-end-block-ref
              (local.get $blockset)
              (local.get $new-block-ref)))))

 (func $relocate-blocks (export "relocate-blocks")
   (param $blockset i32)
   (param $dest-addr i32)
   (param $start-ref i32)
   (param $end-ref i32)
   (param $size i32)

   (local $head i32)
   (local $offset i32)
   (local $source-addr i32)

   (local.set $source-addr (call $get-block-ref-addr (local.get $start-ref)))

   (call_indirect $memory-copy
                  (type $memory-copy-sig)
                  (local.get $dest-addr)
                  (local.get $source-addr)
                  (local.get $size)
                  (call $get-blockset-id (local.get $blockset)))

   (local.set $head (local.get $start-ref))
   (local.set $offset (i32.sub (local.get $source-addr) (local.get $dest-addr)))

   (loop $again
     (if (i32.ne (local.get $head) (local.get $end-ref))
         (then
          (call $set-block-ref-addr
                (local.get $head)
                (i32.sub (call $get-block-ref-addr (local.get $head))
                         (local.get $offset)))
          (local.set $head (call $get-next-block-ref (local.get $head)))
          (br $again)))))

 (func $insert-heap-node (export "insert-heap-node")
   (param $blockset i32)
   (param $entry i32)

   (local $heap i32)
   (local $node-idx i32)

   (if (call $is-heap-full (local.get $blockset))
       (then
        (call $grow-blockset-heap (local.get $blockset))))

   (local.set $heap (call $get-blockset-heap (local.get $blockset)))
   (local.set $node-idx (call $get-blockset-heap-size (local.get $blockset)))
   (call $incr-blockset-heap-size (local.get $blockset))

   (call $set-heap-node-entry (local.get $heap) (local.get $node-idx) (local.get $entry))

   (call $raise-heap-node (local.get $blockset) (local.get $node-idx)))

 (func $is-heap-full (export "is-heap-full")
   (param $blockset i32)
   (result i32)

   (local $heap-ref i32)

   (local.set $heap-ref (call $get-blockset-heap-ref (local.get $blockset)))

   (i32.eq (call $get-blockset-heap-size (local.get $blockset))
           (i32.shr_u (call $get-block-ref-size (local.get $heap-ref))
                      (global.get $heap-node-size-bits))))

 (func $grow-blockset-heap (export "grow-blockset-heap")
   (param $blockset i32)

   (local $heap-ref i32)

   (local.set $heap-ref (call $get-blockset-heap-ref (local.get $blockset)))

   (call $set-blockset-heap-ref
         (local.get $blockset)
         (call $resize-block
               (global.get $block-mgr-blockset-id)
               (local.get $heap-ref)
               (i32.shl (call $get-block-ref-size (local.get $heap-ref))
                        (i32.const 1)))))

 (func $raise-heap-node (export "raise-heap-node")
   (param $blockset i32)
   (param $node-idx i32)

   (local $heap i32)
   (local $parent-idx i32)
   (local $size i32)

   (local.set $heap (call $get-blockset-heap (local.get $blockset)))

   (local.set $size (call $get-heap-block-size (local.get $heap) (local.get $node-idx)))

   (loop $again
     (if (local.get $node-idx)
         (then
          (local.set $parent-idx (call $calc-parent-idx (local.get $node-idx)))
          (if (i32.gt_u (local.get $size)
                        (call $get-heap-block-size (local.get $heap) (local.get $parent-idx)))
              (then
               (call $swap-heap-entries
                     (local.get $heap) (local.get $node-idx) (local.get $parent-idx))
               (local.set $node-idx (local.get $parent-idx))
               (br $again))
            ;; (else
            ;;  (if (call $is-unused-heap-block (local.get $heap) (local.get $parent-idx))
            ;;      (then
            ;;       (call $remove-unused-heap-node (local.get $blockset) (local.get $parent-idx)))))
            )))))

 (func $is-unused-heap-block (export "is-unused-heap-block")
   (param $heap i32)
   (param $idx i32)
   (result i32)
   (i32.eq (call $get-heap-block-addr (local.get $heap) (local.get $idx))
           (global.get $null)))

 (func $mark-free-entry-unused (export "mark-free-entry-unused")
   (param $entry i32)
   (call $set-free-entry-addr (local.get $entry) (global.get $null)))

 (func $sink-heap-node (export "sink-heap-node")
   (param $blockset i32)
   (param $node-idx i32)

   (local $heap i32)
   (local $heap-size i32)
   (local $left-idx i32)
   (local $left-size i32)
   (local $right-idx i32)
   (local $right-size i32)
   (local $size i32)

   (local.set $heap (call $get-blockset-heap (local.get $blockset)))
   (local.set $heap-size (call $get-blockset-heap-size (local.get $blockset)))
   (local.set $size (call $get-heap-block-size (local.get $heap) (local.get $node-idx)))

   (loop $again
     (local.set $left-idx (call $calc-left-idx (local.get $node-idx)))
     (local.set $right-idx (call $calc-right-idx (local.get $node-idx)))

     (if (i32.ge_u (local.get $left-idx) (local.get $heap-size))
         (then
          (local.set $left-size (i32.const 0)))
       (else
        (local.set $left-size
                   (call $get-heap-block-size (local.get $heap) (local.get $left-idx)))))

     (if (i32.ge_u (local.get $right-idx) (local.get $heap-size))
         (then
          (local.set $right-size (i32.const 0)))
       (else
        (local.set $right-size
                   (call $get-heap-block-size (local.get $heap) (local.get $right-idx)))))

     (if (i32.and (i32.lt_u (local.get $size) (local.get $left-size))
                  (i32.lt_u (local.get $size) (local.get $right-size)))
         (then
          (if (i32.ge_u (local.get $left-size) (local.get $right-size))
              (then
               (call $swap-heap-entries
                     (local.get $heap) (local.get $node-idx) (local.get $left-idx))
               (local.set $node-idx (local.get $left-idx))
               (br $again))
            (else
             (call $swap-heap-entries
                   (local.get $heap) (local.get $node-idx) (local.get $right-idx))
             (local.set $node-idx (local.get $right-idx))
             (br $again))))
       (else
        (if (i32.lt_u (local.get $size) (local.get $left-size))
            (then
             (call $swap-heap-entries
                   (local.get $heap) (local.get $node-idx) (local.get $left-idx))
             (local.set $node-idx (local.get $left-idx))
             (br $again))
          (else
           (if (i32.lt_u (local.get $size) (local.get $right-size))
               (then
                (call $swap-heap-entries
                      (local.get $heap) (local.get $node-idx) (local.get $right-idx))
                (local.set $node-idx (local.get $right-idx))
                (br $again)))))))))

 (func $step-clean-heap (export "step-clean-heap")
   (param $blockset i32)

   (local $end-idx i32)
   (local $heap i32)
   (local $node-idx i32)

   (local.set $heap (call $get-blockset-heap (local.get $blockset)))
   (local.set $end-idx (call $get-blockset-heap-size (local.get $blockset)))
   (local.set $node-idx (call $get-blockset-heap-sweep-cursor (local.get $blockset)))

   (if (i32.ge_u (local.get $node-idx) (local.get $end-idx))
       (then
        (local.set $node-idx (i32.const 0))))

   (loop $again
     (if (i32.lt_u (local.get $node-idx) (local.get $end-idx))
         (then
          (if (call $is-unused-heap-block (local.get $heap) (local.get $node-idx))
              (then
               (call $remove-unused-heap-node (local.get $blockset) (local.get $node-idx)))
            (else
             (local.set $node-idx (i32.add (local.get $node-idx) (i32.const 1)))
             (br $again))))))

   (call $set-blockset-heap-sweep-cursor (local.get $blockset) (local.get $node-idx)))

 (func $swap-heap-entries (export "swap-heap-entries")
   (param $heap i32)
   (param $a-idx i32)
   (param $b-idx i32)

   (local $a-addr i32)
   (local $a-value i64)
   (local $b-addr i32)

   (local.set $a-addr (call $calc-heap-node-addr (local.get $heap) (local.get $a-idx)))
   (local.set $b-addr (call $calc-heap-node-addr (local.get $heap) (local.get $b-idx)))

   (local.set $a-value (i64.load (local.get $a-addr)))

   (i64.store (local.get $a-addr) (i64.load (local.get $b-addr)))
   (i64.store (local.get $b-addr) (local.get $a-value)))

 (func $remove-heap-node (export "remove-heap-node")
   (param $blockset i32)
   (param $node-idx i32)

   (local $end-idx i32)
   (local $heap i32)
   (local $heap-size i32)

   (local.set $heap (call $get-blockset-heap (local.get $blockset)))
   (local.set $heap-size (call $get-blockset-heap-size (local.get $blockset)))

   (loop $again
     (local.set $end-idx (i32.sub (local.get $heap-size) (i32.const 1)))
     (if (call $is-unused-heap-block (local.get $heap) (local.get $end-idx))
         (then
          (call $dealloc-free-list-entry
                (call $get-heap-node-entry (local.get $heap) (local.get $end-idx)))
          (local.set $heap-size (local.get $end-idx))
          (br $again))))

   (call $set-blockset-heap-size (local.get $blockset) (local.get $end-idx))

   (if (i32.lt_u (local.get $node-idx) (local.get $end-idx))
       (then
        (call $set-heap-node-entry
              (local.get $heap)
              (local.get $node-idx)
              (call $get-heap-node-entry (local.get $heap) (local.get $end-idx)))

        (call $sink-heap-node (local.get $blockset) (local.get $node-idx))
        (call $raise-heap-node (local.get $blockset) (local.get $node-idx)))))

 (func $remove-unused-heap-node (export "remove-unused-heap-node")
   (param $blockset i32)
   (param $node-idx i32)

   (local $end-idx i32)
   (local $heap i32)
   (local $heap-size i32)

   (local.set $heap (call $get-blockset-heap (local.get $blockset)))
   (local.set $end-idx (i32.sub (call $get-blockset-heap-size (local.get $blockset))
                                (i32.const 1)))

   (loop $again
     (if (i32.and (call $is-unused-heap-block (local.get $heap) (local.get $end-idx))
                  (i32.gt_u (local.get $end-idx) (local.get $node-idx)))
         (then
          (call $dealloc-free-list-entry
                (call $get-heap-node-entry (local.get $heap) (local.get $end-idx)))
          (local.set $end-idx (i32.sub (local.get $end-idx) (i32.const 1)))
          (br $again))))

   (call $dealloc-free-list-entry
         (call $get-heap-node-entry (local.get $heap) (local.get $node-idx)))

   (call $set-blockset-heap-size (local.get $blockset) (local.get $end-idx))

   (if (i32.gt_u (local.get $end-idx) (local.get $node-idx))
       (then
        (call $set-heap-node-entry
              (local.get $heap)
              (local.get $node-idx)
              (call $get-heap-node-entry (local.get $heap) (local.get $end-idx)))

        (call $sink-heap-node (local.get $blockset) (local.get $node-idx))
        (call $raise-heap-node (local.get $blockset) (local.get $node-idx)))))

 (func $dealloc-free-list-entry (export "dealloc-free-list-entry")
   (param $entry i32)

   ;; the block: contains (addr . size)
   (call $dealloc-pair (call $get-free-entry-block (local.get $entry)))

   ;; the block ref: contains (block . null)
   (call $dealloc-pair (call $get-free-entry-block-ref (local.get $entry)))

   ;; the free list entry: contains (block-ref . null)
   (call $dealloc-pair (local.get $entry))))

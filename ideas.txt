generational garbage collection
  if there is no mutation, then memory changes only
    come from adding/removing roots
    any

  if there is mutation, then each mutated value

let M be a directional graph of nodes m_i and R = { r_i } subset M.
let R* be the transitive closure of R.

A node m in M is reachable if there is a path P { p_i } in M of length n  where there exists
r in R st r = p_0, p_k -> p_k+1 for 0 <= k < n, and p_n = m.

keep inverse index
on mutation, mark former target pending
scan pending for inbound using inverse index
  remove source links from inverse index
  if not present, mark children pending
  mark free

keep refindex in blockstore
pair memory lifecycle
  cons:
    get from head of free list
    insert refs to ref list

  vector-set! set-cdr! set-car! -> erase entry in index

  begin sweep
    assign i0 -> i1, i1 -> i2, etc, then sort ref list -> i0,
    init iterators

  sweep step
    check pair flags of each item, etc, searching i0, i1, ...

  end sweep
    if len(i0) > len(i1)/log2(len(i1), merge i0 into i1

index
  actions
    init index
    init page
      idx = mem page + 2048
      addr = idx page
      write idx to addr
      write null to addr+4
      if i%32 != 0
        addr += 8
      idx += 8
    insert entry (idx, tgt)
      bsearch
      search outward bidirectionally for entry with tgt == null (prefer high addr on tie)
      move block, set new entry
      track # of entries moved in ema
    remove entry
      bsearch
      set
    lookup entries by idx
      bsearch, return 1st index
    begin relocation
    relocation step
    end relocation
    begin expansion
    expansion step
    end expansion

  aux fns
    bsearch
      note, lexicographic, 8 byte, in 4 byte words
    update ema
      normal is ema_n = ((k-1)ema_n-1 + v)/k
      for k = 2^n for some n, then mul-shift works
        say (15*e + v ) >> 4 or (32*e +v) >> 5
      for #s typically less than 16, use << 4 to provide fractions


  odd cases:
    expansion triggered during relocation
    relocation triggered during expansion

  worst case index to storage is 2:1 where all pairs refer to other pairs, but
  typical usage is closer to 1:1. By default, there will be 32/31 index entries
  per pair.

  allocate 1 index page per memory page, keep index pages contiguous
  and above all memory pages

  keep one empty page above the last allocated memory page, to allow
  incremental copying of index to higher memory. => copy N+1 index entries
  per allocation, where N is the number of memory pages

  initialize a full 64kb page with empty 8 byte entries evenly spaced with
  keys between the lowest cell and highest cells in a new memory page,
  i.e page + 2048 to page + 65528, aligned to 8 bytes. an empty entry has
  $null = (0xffffffff) in the second 4 bytes

  when activating a new memory page, schedule an insertion of new block of f
  empty entries into the index.

  a sorted array of pairs with a semi-dense set of gaps, avg 1 gap per k entries
  gaps have the index of the entry below, but an empty value

  operations
    lookup O(log n) -- binary search
    delete O(log n) -- find by binary search, leave entry, but set value empty
    insert O(log n) + O(k) where k is the gap radius -- find by binary search,
      find nearest gap by linear search (bidirectional, outward), shift
      entries to move gap to desired location, set value
    expand O(n) -- copies array to new array, inserting a gap every k entries

  attributes
    k, n
    filled entries
    base addr
    capacity threshold
    EMA threshold
    state (stable/expanding)
    when expanding
      new addr
      i -- index into old of next item to copy to new
      j -- index into new of next item from old

    stats
      EMA of shift radius per insert
      ratio filled/capacity

  when EMA or ratio gets above threshold
    increase size of table by 2/k
    inserting a gap for every k/2 entries

explore:
  flags page holds pending/reachable flags for 32 64kb pages (2MB).

another refindex design

  stored as blocks and pairs
  reflist: linked list of ( pair addr . ref addr )
  idxlist: linked list of vector or ( ( i_n . idx_n ) ( i_n+1 . idx_n+1 ) ( j . idx ) )

  on alloc or set, add items to reflist
  on set or root change
    compact refindex

  compact
    create vector of length of refindex * 2
    sort by key
    add reflist to pair free list
    push to head of idxlist

    for each idx_n and idx_n+1 in idx list
      if len(idx_n) > len(idx_n+1)/log2(len(idx_n+1))
        if len(idx_n) + len(idx_n+1) < chunk size
          merge sored, replace the two by the merged list
          dealloc 1 pair and the two old vector blocks and their owners
        else
          begin merge sorted
            create idx of length len(idx_n) + len(iex_n+1)
            replace idx_n, idx_n+1 with ( ( 0 . idx_n ) ( 0 . idx_n+1 ) ( 0 . idx ) )
            process chunk size elements so that idx has the 1st chunk size values
            filled in.

project organization
  file dependencies
    memory.wat defines the memory, anything that has to accees
      memory has to import it from there

    algorithms.wat
      provide standard algorithms
      imports memory

    lex.wat
      r7rs tokenizer, per spec
      imports memory

    kernel
      data representation
  kernel.wat

number encoding
  small integer as tagged value (up to 29 bits)
  boxed number
    f32 and i32 (for 32 bits) stored as boxed value
    box flags indicate exact/inexact, real only
  block number
    box flags indicate storage type
      double format 00xxxxxx xxxxxxxx
      small format  01xxxxxx xxxxxxxx
      [ medium format 10xxxxxx xxxxxxxx ]
      large format  11xxxxxx xxxxxxxx

      double format
        00cxxxxx xxxxxxxx
        c = 0 => imag part is not present, block is one 64 bit float
        c = 1 => imag part is present, block is two 64 bit floats

      small format
        01RCxxxx xxxxxxxx
        RC = 00 => real integer
          0100rrrr rrrrrrrr
          12 bits for count of 32 bit words = 131040 binary digits
          good enough for all pre-quantum crypto

        RC = 10 => rationals
          0011nnnn nndddddd
          6 bits each for the num and denom = 2016 binary digits each

        RC = 01 => gaussian integers
          0010rrrr rriiiiii
          6 bits each for counts of 32-bit units for real/imag parts = 2016 binary digits each

        RC = 11 => gaussian rationals
          0011aaab bbcccddd
          3 bits each for counts of 32-bit units for real/image parts and num/denoms
          7 * 32 = 224 binary digits for each

      large format
        11xxxxxx xxxxxxxx
        1st 128 bits of block provide lengths (in 32 bit units) of num/denom for real/imag parts
          each 32 bits, providing more digits than the wasm address space allows
        unlikely to have a practical use
        probably for testing only.

      exact/inexact flag. inexact => small format
      small flag => 3 bit sizes for num/denom for real/imag (12 bits)
      real flag set =>
      small flag clear + med flag set

        => 1st value allocates
  value
    exact
      integer (length)
      rational (num length, denom length)
    inexact
      f32/f64
  real part value
  imag part value

  value flags
    real exact/inexact
    imag exact/inexact

  real denom/float size (in 32 bit chunks, inexact => 1 or 2)
  real denom size (in 32 bit chunks) (0 => integer, inexact => 0)


TODO:
  string repr choices
    ucs-4 ... wasteful for most common cases
    utf-8 efficient, but slow to index
    emacs: unibyte, multibyte types
    index for utf-8
     each string has a most common character length. in some languages,
       that may be 2 -- many asian languages, for example
     what would an index look like that had a max 10% memory overhead budget? 20%?
     ... ie. a 256 byte string gets 24 bytes of index
     entry only for multibyte chars => most indexes would be 0.
     also, perhaps only store index entries for some subset of multibyte chars,
     say every 16 or more.
     index fmt (sorted array):
     short strings (n <256 bytes) -- idx byte offset
     medium strings (256 <= n < 65536 bytes) -- idx

  possible impls
    simple string -- ascii, length < 256
    short text -- some non-ascii chars, length < 256
    text -- utf-8, length < 64KB
    long text -- utf-8, length < 4GB

    memory layout
      simple string
        1 byte length, then the bytes of the string

      small string
        1 byte length
        up to 15 bytes index of 1 byte offsets (one between each 16 character chunk)

      medium string
        2 byte length
        up to 4KB index of 2 byte offsets, one between each 32 character chunk

      large string
        4 byte length
        up to 250MB index of 4 byte offsets, one between each 64 character chunk


parser
  interface with string
    scan token to determine string length and size
    call alloc-string
    loop for each char
      call set-string-bytes for each char
    call build-string-index

  interface with bytevector
    scan token to determine length
    call alloc-bytevector
    loop for each byte
      call set-bytevector-u8 for each byte (TODO)

  interface with symbol
    create new string
    call inter-symbol
    if symbol string != new string,  dealloc new string

  interface with number
    float
      ...
    inf/nan
      specialized call
    digits
      loop
        multiply base, add
    complex/rational
      create numbers for components
      build with call make-rational or make-complex

tooling improvements
  wat
    different face for local.set and local.get

  wam.py
    error messages
    check syntax of expr vs label in macros
    add line no to IR

  test
    tests for non-debug builds
    better cli for block_mgr perf test
    better cli/cleanup of block_mgr stochastic test bench
    rework block_mgr_utils for to support both debug/non-debug
    test suite for wam.py

  build
    put build artifacts in subdirectory

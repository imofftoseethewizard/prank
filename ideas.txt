generational garbage collection
  if there is no mutation, then memory changes only
    come from adding/removing roots
    any

  if there is mutation, then each mutated value

let M be a directional graph of nodes m_i and R = { r_i } subset M.
let R* be the transitive closure of R.

A node m in M is reachable if there is a path P { p_i } in M of length n  where there exists
r in R st r = p_0, p_k -> p_k+1 for 0 <= k < n, and p_n = m.

keep inverse index
on mutation, mark former target pending
scan pending for inbound using inverse index
  remove source links from inverse index
  if not present, mark children pending
  mark free

keep refindex in blockstore
pair memory lifecycle
  cons:
    get from head of free list
    insert refs to ref list

  vector-set! set-cdr! set-car! -> erase entry in index

  begin sweep
    assign i0 -> i1, i1 -> i2, etc, then sort ref list -> i0,
    init iterators

  sweep step
    check pair flags of each item, etc, searching i0, i1, ...

  end sweep
    if len(i0) > len(i1)/log2(len(i1), merge i0 into i1

index
  actions
    init index
    init page
      idx = mem page + 2048
      addr = idx page
      write idx to addr
      write null to addr+4
      if i%32 != 0
        addr += 8
      idx += 8
    insert entry (idx, tgt)
      bsearch
      search outward bidirectionally for entry with tgt == null (prefer high addr on tie)
      move block, set new entry
      track # of entries moved in ema
    remove entry
      bsearch
      set
    lookup entries by idx
      bsearch, return 1st index
    begin relocation
    relocation step
    end relocation
    begin expansion
    expansion step
    end expansion

  aux fns
    bsearch
      note, lexicographic, 8 byte, in 4 byte words
    update ema
      normal is ema_n = ((k-1)ema_n-1 + v)/k
      for k = 2^n for some n, then mul-shift works
        say (15*e + v ) >> 4 or (32*e +v) >> 5
      for #s typically less than 16, use << 4 to provide fractions


  odd cases:
    expansion triggered during relocation
    relocation triggered during expansion

  worst case index to storage is 2:1 where all pairs refer to other pairs, but
  typical usage is closer to 1:1. By default, there will be 32/31 index entries
  per pair.

  allocate 1 index page per memory page, keep index pages contiguous
  and above all memory pages

  keep one empty page above the last allocated memory page, to allow
  incremental copying of index to higher memory. => copy N+1 index entries
  per allocation, where N is the number of memory pages

  initialize a full 64kb page with empty 8 byte entries evenly spaced with
  keys between the lowest cell and highest cells in a new memory page,
  i.e page + 2048 to page + 65528, aligned to 8 bytes. an empty entry has
  $null = (0xffffffff) in the second 4 bytes

  when activating a new memory page, schedule an insertion of new block of f
  empty entries into the index.

  a sorted array of pairs with a semi-dense set of gaps, avg 1 gap per k entries
  gaps have the index of the entry below, but an empty value

  operations
    lookup O(log n) -- binary search
    delete O(log n) -- find by binary search, leave entry, but set value empty
    insert O(log n) + O(k) where k is the gap radius -- find by binary search,
      find nearest gap by linear search (bidirectional, outward), shift
      entries to move gap to desired location, set value
    expand O(n) -- copies array to new array, inserting a gap every k entries

  attributes
    k, n
    filled entries
    base addr
    capacity threshold
    EMA threshold
    state (stable/expanding)
    when expanding
      new addr
      i -- index into old of next item to copy to new
      j -- index into new of next item from old

    stats
      EMA of shift radius per insert
      ratio filled/capacity

  when EMA or ratio gets above threshold
    increase size of table by 2/k
    inserting a gap for every k/2 entries

explore:
  flags page holds pending/reachable flags for 32 64kb pages (2MB).

another refindex design

  stored as blocks and pairs
  reflist: linked list of ( pair addr . ref addr )
  idxlist: linked list of vector or ( ( i_n . idx_n ) ( i_n+1 . idx_n+1 ) ( j . idx ) )

  on alloc or set, add items to reflist
  on set or root change
    compact refindex

  compact
    create vector of length of refindex * 2
    sort by key
    add reflist to pair free list
    push to head of idxlist

    for each idx_n and idx_n+1 in idx list
      if len(idx_n) > len(idx_n+1)/log2(len(idx_n+1))
        if len(idx_n) + len(idx_n+1) < chunk size
          merge sored, replace the two by the merged list
          dealloc 1 pair and the two old vector blocks and their owners
        else
          begin merge sorted
            create idx of length len(idx_n) + len(iex_n+1)
            replace idx_n, idx_n+1 with ( ( 0 . idx_n ) ( 0 . idx_n+1 ) ( 0 . idx ) )
            process chunk size elements so that idx has the 1st chunk size values
            filled in.

parser
  wasi examples
    https://github.com/bytecodealliance/wasmtime-py/tree/main/examples
  wasi snapshot preview 1 doc
    https://docs.rs/wasi/latest/wasi/wasi_snapshot_preview1/

  split lex module into lex and r7rs-lex
  errors
    distinguished error objects that cannot be read

  interface with string
    scan token to determine string length and size
    call alloc-string
    loop for each char
      call set-string-bytes s offset encoded-char
      offset += char-width
    call build-string-index

  interface with bytevector
    scan token to determine length
    call alloc-bytevector
    loop for each byte
      call set-bytevector-u8 for each byte (TODO)

  interface with symbol
    create new string
    call inter-symbol
    if symbol string != new string,  dealloc new string

  interface with number
    float
      parse mantissa digits as x64
        check bit length
        shift, mask, trim high bit
      parse abcissa as x64
        apply sign
        add bias
        shift/mask/update abcissa bits
      reinterpret f64
      apply sign
    inf/nan
      specialized call
    digits
      loop
        multiply base, add
    complex/rational
      create numbers for components
      build with call make-rational or make-complex

tooling improvements
  wat
    different face for local.set and local.get

  wam.py
    rename to sweet, create repo
    error messages
    check syntax of expr vs label in macros

    non-debug equivalent to (debug ...)

    expr comments

      (-<token> ) is a comment.

      that is, to comment out
        (if (i32.eq (local.get $a) (local.get $b)
            (then
              (call $foo (local.get $x)))
          (else
            (call $bar))))

      just add a '-' to the start of "if":

        (-if (i32.eq (local.get $a) (local.get $b)
            (then
              (call $foo (local.get $x)))
          (else
            (call $bar))))

    length-prefixed string literals
      use single quotes
      resolves to, eg
        'abcd' -> "\04abcd"

    wam-time eval
      (eval (expr))
        where expr is an s-exp
          operators: * + - / % & | ~ ^ log2 pow2
          literals: integers in base 10, 16, 2

    environment expr
      (env name [default])
      error if not present and no default

    conditional processing
      (config NAME value)

      (option (config-expr)
        body)


  test
    tests for non-debug builds
    better cli for block_mgr perf test
    better cli/cleanup of block_mgr stochastic test bench
    rework block_mgr_utils for to support both debug/non-debug
    test suite for wam.py

  what would it take to have one codebase for i32 addressing and i64 addressing?
    use of macro with class at the module level
      (macro %block-mgr
        (class W)
        (module ...
          (macro %get-heap-block
            (expr ,heap)
            (expr ,idx)
            (W.load (%calc-heap-node-addr ,heap ,idx)))

          (macro %get-heap-node-entry
            (expr ,heap)
            (expr ,idx)
            (W.wrap_i64 (i64.shr_u (%get-heap-node ,heap ,idx) ;; problematic
                                   (i64.const 32))))           ;; also problematic

        ))

    then

      (%block-mgr i32)

    or

      (%block-mgr i64)

    There is going to be code that is not just a simple substitution of one
    identifier or value for another, but that is structurally different.

    So
      (macro %get-heap-node-entry
        (expr ,heap)
        (expr ,idx)
        (i32.wrap_i64 (i64.shr_u (%get-heap-node ,heap ,idx)
                                 (i64.const 32))))
      (%block-mgr i32)

    or

      (macro %get-heap-node-entry
        (expr ,heap)
        (expr ,idx)
        (i64x2.extract_lane (%get-heap-node ,heap ,idx) 1))

      (%block-mgr i32)

values release punchlist
  identify required new/updated documentation
    block-mgr
      finish header comment
        explain
          free lists
          fragments
          defragmentation
          allocated vs free vs unused
          block refs
      function comments
        link-blocks
        init-blockset-manager
        init-blockset
        alloc-blocks
        quantize-size
        calc-free-list-offset
        pop-free-block
        provision-free-block
        split-free-block
        resize-block
        dealloc-block
        add-free-block
        step-defragment-blockset
        relocate-free-block
        coalesce-free-blocks
        incr-block-size
        scan-relocatable-blocks

    numbers
      explain number type flags
      all fns
    pairs
      move stuff to extras
    values
      review header comment
    vectors
      general comments


  rough in parser to verify interface
  move to extras all non-required functions (and supporting globals, etc)
  reorder code to standard order:
    imports
    includes
    globals
    macros
    accessors
    init
    primary interface
      alloc
      dealloc

regular expression implementation
  https://github.com/c0stya/brzozowski

rework symbols not to use blockset

generational garbage collection
  if there is no mutation, then memory changes only
    come from adding/removing roots
    any

  if there is mutation, then each mutated value

let M be a directional graph of nodes m_i and R = { r_i } subset M.
let R* be the transitive closure of R.

A node m in M is reachable if there is a path P { p_i } in M of length n  where there exists
r in R st r = p_0, p_k -> p_k+1 for 0 <= k < n, and p_n = m.

keep inverse index
on mutation, mark former target pending
scan pending for inbound using inverse index
  remove source links from inverse index
  if not present, mark children pending
  mark free

keep refindex in blockstore
pair memory lifecycle
  cons:
    get from head of free list
    insert refs to ref list

  vector-set! set-cdr! set-car! -> erase entry in index

  begin sweep
    assign i0 -> i1, i1 -> i2, etc, then sort ref list -> i0,
    init iterators

  sweep step
    check pair flags of each item, etc, searching i0, i1, ...

  end sweep
    if len(i0) > len(i1)/log2(len(i1), merge i0 into i1

index
  actions
    init index
    init page
      idx = mem page + 2048
      addr = idx page
      write idx to addr
      write null to addr+4
      if i%32 != 0
        addr += 8
      idx += 8
    insert entry (idx, tgt)
      bsearch
      search outward bidirectionally for entry with tgt == null (prefer high addr on tie)
      move block, set new entry
      track # of entries moved in ema
    remove entry
      bsearch
      set
    lookup entries by idx
      bsearch, return 1st index
    begin relocation
    relocation step
    end relocation
    begin expansion
    expansion step
    end expansion

  aux fns
    bsearch
      note, lexicographic, 8 byte, in 4 byte words
    update ema
      normal is ema_n = ((k-1)ema_n-1 + v)/k
      for k = 2^n for some n, then mul-shift works
        say (15*e + v ) >> 4 or (32*e +v) >> 5
      for #s typically less than 16, use << 4 to provide fractions


  odd cases:
    expansion triggered during relocation
    relocation triggered during expansion

  worst case index to storage is 2:1 where all pairs refer to other pairs, but
  typical usage is closer to 1:1. By default, there will be 32/31 index entries
  per pair.

  allocate 1 index page per memory page, keep index pages contiguous
  and above all memory pages

  keep one empty page above the last allocated memory page, to allow
  incremental copying of index to higher memory. => copy N+1 index entries
  per allocation, where N is the number of memory pages

  initialize a full 64kb page with empty 8 byte entries evenly spaced with
  keys between the lowest cell and highest cells in a new memory page,
  i.e page + 2048 to page + 65528, aligned to 8 bytes. an empty entry has
  $null = (0xffffffff) in the second 4 bytes

  when activating a new memory page, schedule an insertion of new block of f
  empty entries into the index.

  a sorted array of pairs with a semi-dense set of gaps, avg 1 gap per k entries
  gaps have the index of the entry below, but an empty value

  operations
    lookup O(log n) -- binary search
    delete O(log n) -- find by binary search, leave entry, but set value empty
    insert O(log n) + O(k) where k is the gap radius -- find by binary search,
      find nearest gap by linear search (bidirectional, outward), shift
      entries to move gap to desired location, set value
    expand O(n) -- copies array to new array, inserting a gap every k entries

  attributes
    k, n
    filled entries
    base addr
    capacity threshold
    EMA threshold
    state (stable/expanding)
    when expanding
      new addr
      i -- index into old of next item to copy to new
      j -- index into new of next item from old

    stats
      EMA of shift radius per insert
      ratio filled/capacity

  when EMA or ratio gets above threshold
    increase size of table by 2/k
    inserting a gap for every k/2 entries

explore:
  flags page holds pending/reachable flags for 32 64kb pages (2MB).

another refindex design

  stored as blocks and pairs
  reflist: linked list of ( pair addr . ref addr )
  idxlist: linked list of vector or ( ( i_n . idx_n ) ( i_n+1 . idx_n+1 ) ( j . idx ) )

  on alloc or set, add items to reflist
  on set or root change
    compact refindex

  compact
    create vector of length of refindex * 2
    sort by key
    add reflist to pair free list
    push to head of idxlist

    for each idx_n and idx_n+1 in idx list
      if len(idx_n) > len(idx_n+1)/log2(len(idx_n+1))
        if len(idx_n) + len(idx_n+1) < chunk size
          merge sored, replace the two by the merged list
          dealloc 1 pair and the two old vector blocks and their owners
        else
          begin merge sorted
            create idx of length len(idx_n) + len(iex_n+1)
            replace idx_n, idx_n+1 with ( ( 0 . idx_n ) ( 0 . idx_n+1 ) ( 0 . idx ) )
            process chunk size elements so that idx has the 1st chunk size values
            filled in.

project organization
  file dependencies
    memory.wat defines the memory, anything that has to accees
      memory has to import it from there

    algorithms.wat
      provide standard algorithms
      imports memory

    lex.wat
      r7rs tokenizer, per spec
      imports memory

    kernel
      data representation
  kernel.wat

number encoding
  small integer as tagged value (up to 29 bits)
  boxed number
    f32 and i32 (for 32 bits) stored as boxed value
    box flags indicate exact/inexact, real only
  block number
    box flags indicate storage type
      double format 00xxxxxx xxxxxxxx
      small format  01xxxxxx xxxxxxxx
      [ medium format 10xxxxxx xxxxxxxx ]
      large format  11xxxxxx xxxxxxxx

      double format
        00cxxxxx xxxxxxxx
        c = 0 => imag part is not present, block is one 64 bit float
        c = 1 => imag part is present, block is two 64 bit floats

      small format
        01RCxxxx xxxxxxxx
        RC = 00 => real integer
          0100rrrr rrrrrrrr
          12 bits for count of 32 bit words = 131040 binary digits
          good enough for all pre-quantum crypto

        RC = 10 => rationals
          0011nnnn nndddddd
          6 bits each for the num and denom = 2016 binary digits each

        RC = 01 => gaussian integers
          0010rrrr rriiiiii
          6 bits each for counts of 32-bit units for real/imag parts = 2016 binary digits each

        RC = 11 => gaussian rationals
          0011aaab bbcccddd
          3 bits each for counts of 32-bit units for real/image parts and num/denoms
          7 * 32 = 224 binary digits for each

      large format
        11xxxxxx xxxxxxxx
        1st 128 bits of block provide lengths (in 32 bit units) of num/denom for real/imag parts
          each 32 bits, providing more digits than the wasm address space allows
        unlikely to have a practical use
        probably for testing only.

      exact/inexact flag. inexact => small format
      small flag => 3 bit sizes for num/denom for real/imag (12 bits)
      real flag set =>
      small flag clear + med flag set

        => 1st value allocates
  value
    exact
      integer (length)
      rational (num length, denom length)
    inexact
      f32/f64
  real part value
  imag part value

  value flags
    real exact/inexact
    imag exact/inexact

  real denom/float size (in 32 bit chunks, inexact => 1 or 2)
  real denom size (in 32 bit chunks) (0 => integer, inexact => 0)


new block design
  objective: create block mgr w/o own memory
  owner, length not stored in block memory
  block list ->
    ( ( addr . length ) ... )
  box ->
    ( box-flags addr . length )

  block mgr
    ( block-list free-list free-area . top )
    indirect call tables
      memory-size
      memory-grow
      memory-copy

    indexed by module-id


  block list
    list of ( addr . length )

  block
    sublist of block list with ( addr . length ) of memory at head

  free list
    list of free blocks (wh block is as above)

  leave 0 length free list entries on move
    cost 2 free list steps per 0 length entry for each end allocation
    each memory compaction step creates another one
    start from block list head if free list head has a length 0 block
    otherwise start from last free list item with non-zero length block\

    every step process block k list entries, for some function
      k = k(#blocks, #free-blocks, #0-length free blocks)

    which minimizes total work

  block allocator
    max heap
    head = root
    if head > size
      if left is unused, bury left
      if right is unused, bury right
      if left and right < size then split head
      if left and right >= size then recur with head = min of left or right
      otherwise recur with head = left or right, whichever is >= size

    if head = size
      search free list for pred of head
      remove head from free list
      replace head with last element of heap
    else
      split head, sift down

    unused free block
      addr = (unsigned) -1 => free block
      not in free list => separate heap count and free count
      when heap encounters unused free block, bury block

    bury block
      set block size to 0
      sift down

    insert k v h

      if target parent is size 0 and unused
         then replace, do not incr count
         else add as appropriate

      sift up

      if k == 0 add to left
      if k == 1 add to right
      if k & 1
        then insert k >> 1, v, right
        else insert k >> 1, v, left

blocks defragmentation
  incremental => cursor that runs along block list, persistent in blockset
  general idea:
    merge free blocks as cursor sweeps up through memory, copying allocated blocks down
  algo:
    terms
      cursor
      base free block
      lower free block
      upper free block
    find free block before first free block above cursor
      max of addr <= next block after cursor
        top (log2 (sqrt heap size)) levels of heap
          approx with (32-clz((32-clz)/2)
        early exit for equality
        otherwise scan forward from there until free block addr >= next block after cursor
    find next free block after that
      next in list
      if none, reset cursor
    move allocated blocks between down to addr of lower free block
      move memory as a block
      traverse block list
        subtract size of lower block from each address
      set cursor to addr of last allocated block moved
    merge upper free block into lower
      rm upper free block from the block list
      rm upper free block from the free list
      if upper free block is end block, set end block to lower free block
      set upper free block addr to -1 to mark that it is unused
      set lower free block addr to top of last allocated block moved

TODO:
  string repr choices
    ucs-4 ... wasteful for most common cases
    utf-8 efficient, but slow to index
    emacs: unibyte, multibyte types
    index for utf-8
     each string has a most common character length. in some languages,
       that may be 2 -- many asian languages, for example
     what would an index look like that had a max 10% memory overhead budget? 20%?
     ... ie. a 256 byte string gets 24 bytes of index
     entry only for multibyte chars => most indexes would be 0.
     also, perhaps only store index entries for some subset of multibyte chars,
     say every 16 or more.
     index fmt (sorted array):
     short strings (n <256 bytes) -- idx byte offset
     medium strings (256 <= n < 65536 bytes) -- idx
